<!doctype html><html lang=en><!-- Online page at https://ziglang.org/documentation/0.10.0/std/#root;testing.checkAllAllocationFailures --><head> <meta charset=utf-8> <meta name=viewport content="width=device-width,initial-scale=1"> <title>checkAllAllocationFailures</title> <link href=../../style.css rel=stylesheet></head> <body class=canvas> <div class=banner> This is a beta autodoc build; expect bugs and missing information.</div> <div class=flex-main> <div id=docs class=flex-right> <div class=wrap> <section class=docs> <div style=position:relative> </div> <div id=sectNav class=""><ul id=listNav><li><a href=../../std.html class="">std</a></li><li><a href=../../std/testing.html class="">testing</a></li><li><a href=checkAllAllocationFailures.html class=active>checkAllAllocationFailures</a></li></ul></div> <div id=fnProto class=""> <div class=mobile-scroll-container><pre id=fnProtoCode class=scroll-item><a target=_blank href=https://ziglang.org/documentation/0.10.0/std/src/testing.zig.html#L643>checkAllAllocationFailures</a>(<span class=argBreaker><br>&nbsp;&nbsp;&nbsp;&nbsp;</span>backing_allocator: <a href=""><span class=tok-kw style=color:#add8e6>std.mem.Allocator</span></a>, <span class=argBreaker><br>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=tok-kw>comptime</span> test_fn: <span class=tok-kw>anytype</span>, <span class=argBreaker><br>&nbsp;&nbsp;&nbsp;&nbsp;</span>extra_args: <span class=tok-kw>anytype</span><span class=argBreaker>,<br></span>) !<span class=tok-type>void</span></pre></div> </div> <div id=tldDocs class=""><p> Exhaustively check that allocation failures within <code>test_fn</code> are handled without introducing memory leaks. If used with the <code>testing.allocator</code> as the <code>backing_allocator</code>, it will also be able to detect double frees, etc (when runtime safety is enabled). </p> <p> The provided <code>test_fn</code> must have a <code>std.mem.Allocator</code> as its first argument, and must have a return type of <code>!void</code>. Any extra arguments of <code>test_fn</code> can be provided via the <code>extra_args</code> tuple. </p> <p> Any relevant state shared between runs of <code>test_fn</code> <em>must</em> be reset within <code>test_fn</code>. </p> <p> The strategy employed is to: </p> <ul> <li> Run the test function once to get the total number of allocations.</li> <li> Then, iterate and run the function X more times, incrementing</li> </ul> <p> the failing index each iteration (where X is the total number of allocations determined previously) </p> <p> Expects that <code>test_fn</code> has a deterministic number of memory allocations: </p> <ul> <li> If an allocation was made to fail during a run of <code>test_fn</code>, but <code>test_fn</code></li> </ul> <p> didn't return <code>error.OutOfMemory</code>, then <code>error.SwallowedOutOfMemoryError</code> is returned from <code>checkAllAllocationFailures</code>. You may want to ignore this depending on whether or not the code you're testing includes some strategies for recovering from <code>error.OutOfMemory</code>. </p> <ul> <li> If a run of <code>test_fn</code> with an expected allocation failure executes without</li> </ul> <p> an allocation failure being induced, then <code>error.NondeterministicMemoryUsage</code> is returned. This error means that there are allocation points that won't be tested by the strategy this function employs (that is, there are sometimes more points of allocation than the initial run of <code>test_fn</code> detects). </p> <ul> <li>--</li> </ul> <p> Here's an example using a simple test case that will cause a leak when the allocation of <code>bar</code> fails (but will pass normally): </p> <p> <code>zig test { const length: usize = 10; const allocator = std.testing.allocator; var foo = try allocator.alloc(u8, length); var bar = try allocator.alloc(u8, length); </code></p><code> <p> allocator.free(foo); allocator.free(bar); } </p> <pre><code>
The test case can be converted to something that this function can use by
doing:

```zig
fn testImpl(allocator: std.mem.Allocator, length: usize) !void {
    var foo = try allocator.alloc(u8, length);
    var bar = try allocator.alloc(u8, length);

    allocator.free(foo);
    allocator.free(bar);
}

test {
    const length: usize = 10;
    const allocator = std.testing.allocator;
    try std.testing.checkAllAllocationFailures(allocator, testImpl, .{length});
}
</code></pre> <p> Running this test will show that <code>foo</code> is leaked when the allocation of <code>bar</code> fails. The simplest fix, in this case, would be to use defer like so: </p> <p> <code>zig fn testImpl(allocator: std.mem.Allocator, length: usize) !void { var foo = try allocator.alloc(u8, length); defer allocator.free(foo); var bar = try allocator.alloc(u8, length); defer allocator.free(bar); } </code></p><code> </code></code></div> <div id=sectParams class=""> <a name=//apple_ref/cpp/Section/Parameters class=dashAnchor></a><h2>Parameters</h2> <div id=listParams><div><pre>backing_allocator: <span class=tok-kw>std.mem.Allocator</span>,</pre></div><div><pre>test_fn: <span class=tok-kw>anytype</span>,</pre></div><div><pre>extra_args: <span class=tok-kw>anytype</span>,</pre></div></div> </div> </section> </div> <div class=flex-filler></div> </div> </div> </body></html>