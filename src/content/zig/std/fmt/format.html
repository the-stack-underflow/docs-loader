<!doctype html><html lang=en><!-- Online page at https://ziglang.org/documentation/0.10.0/std/#root;fmt.format --><head> <meta charset=utf-8> <meta name=viewport content="width=device-width,initial-scale=1"> <title>format</title> <link href=../../style.css rel=stylesheet></head> <body class=canvas> <div class=banner> This is a beta autodoc build; expect bugs and missing information.</div> <div class=flex-main> <div id=docs class=flex-right> <div class=wrap> <section class=docs> <div style=position:relative> </div> <div id=sectNav class=""><ul id=listNav><li><a href=../../std.html class="">std</a></li><li><a href=../../std/fmt.html class="">fmt</a></li><li><a href=format.html class=active>format</a></li></ul></div> <div id=fnProto class=""> <div class=mobile-scroll-container><pre id=fnProtoCode class=scroll-item><a target=_blank href=https://ziglang.org/documentation/0.10.0/std/src/fmt.zig.html#L78>format</a>(<span class=argBreaker><br>&nbsp;&nbsp;&nbsp;&nbsp;</span>writer: <span class=tok-kw>anytype</span>, <span class=argBreaker><br>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class=tok-kw>comptime</span> fmt: <span class=tok-kw>[]const u8</span>, <span class=argBreaker><br>&nbsp;&nbsp;&nbsp;&nbsp;</span>args: <span class=tok-kw>anytype</span><span class=argBreaker>,<br></span>) !<span class=tok-type>void</span></pre></div> </div> <div id=tldDocs class=""><p> Renders fmt string with args, calling <code>writer</code> with slices of bytes. If <code>writer</code> returns an error, the error is returned from <code>format</code> and <code>writer</code> is not called again. </p> <p> The format string must be comptime-known and may contain placeholders following this format: <code>{[argument][specifier]:[fill][alignment][width].[precision]}</code> </p> <p> Above, each word including its surrounding [ and ] is a parameter which you have to replace with something: </p> <ul> <li> <em>argument</em> is either the numeric index or the field name of the argument that should be inserted</li> <ul> <li> when using a field name, you are required to enclose the field name (an identifier) in square</li> </ul> <p> brackets, e.g. {[score]...} as opposed to the numeric index form which can be written e.g. {2...} </p> <ul> <li> <em>specifier</em> is a type-dependent formatting option that determines how a type should formatted (see below)</li> <li> <em>fill</em> is a single character which is used to pad the formatted text</li> <li> <em>alignment</em> is one of the three characters <code>&lt;</code>, <code>^</code> or <code>&gt;</code>. they define if the text is <em>left</em>, <em>center</em>, or <em>right</em> aligned</li> <li> <em>width</em> is the total width of the field in characters</li> <li> <em>precision</em> specifies how many decimals a formatted number should have</li> </ul> <p> Note that most of the parameters are optional and may be omitted. Also you can leave out separators like <code>:</code> and <code>.</code> when all parameters after the separator are omitted. Only exception is the <em>fill</em> parameter. If <em>fill</em> is required, one has to specify <em>alignment</em> as well, as otherwise the digits after <code>:</code> is interpreted as <em>width</em>, not <em>fill</em>. </p> <p> The <em>specifier</em> has several options for types: </p> <ul> <li> <code>x</code> and <code>X</code>: output numeric value in hexadecimal notation</li> <li> <code>s</code>:</li> <ul> <li> for pointer-to-many and C pointers of u8, print as a C-string using zero-termination</li> <li> for slices of u8, print the entire slice as a string without zero-termination</li> </ul> <li> <code>e</code>: output floating point value in scientific notation</li> <li> <code>d</code>: output numeric value in decimal notation</li> <li> <code>b</code>: output integer value in binary notation</li> <li> <code>o</code>: output integer value in octal notation</li> <li> <code>c</code>: output integer as an ASCII character. Integer type must have 8 bits at max.</li> <li> <code>u</code>: output integer as an UTF-8 sequence. Integer type must have 21 bits at max.</li> <li> <code>?</code>: output optional value as either the unwrapped value, or <code>null</code>; may be followed by a format specifier for the underlying value.</li> <li> <code>!</code>: output error union value as either the unwrapped value, or the formatted error value; may be followed by a format specifier for the underlying value.</li> <li> <code>*</code>: output the address of the value instead of the value itself.</li> <li> <code>any</code>: output a value of any type using its default format.</li> </ul> <p> If a formatted user type contains a function of the type </p> <pre><code>pub fn format(value: ?, comptime fmt: []const u8, options: std.fmt.FormatOptions, writer: anytype) !void
</code></pre> <p> with <code>?</code> being the type formatted, this function will be called instead of the default implementation. This allows user types to be formatted in a logical manner instead of dumping all fields of the type. </p> <p> A user type may be a <code>struct</code>, <code>vector</code>, <code>union</code> or <code>enum</code> type. </p> <p> To print literal curly braces, escape them by writing them twice, e.g. <code>{{</code> or <code>}}</code>. </p> </ul></div> <div id=sectParams class=""> <a name=//apple_ref/cpp/Section/Parameters class=dashAnchor></a><h2>Parameters</h2> <div id=listParams><div><pre>writer: <span class=tok-kw>anytype</span>,</pre></div><div><pre>fmt: <span class=tok-kw>[]const u8</span>,</pre></div><div><pre>args: <span class=tok-kw>anytype</span>,</pre></div></div> </div> </section> </div> <div class=flex-filler></div> </div> </div> </body></html>