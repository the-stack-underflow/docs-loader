<!doctype html><html lang=en><!-- Online page at https://ziglang.org/documentation/0.10.0/ --><head> <meta charset=utf-8> <meta name=viewport content="width=device-width,initial-scale=1"> <title>Zig Language Reference (0.10.0)</title> <style>:root{--nav-width:24em;--nav-margin-l:1em}body{font-family:system-ui,-apple-system,Roboto,"Segoe UI",sans-serif;margin:0;line-height:1.5}header{padding:0 1em}#contents{max-width:60em;margin:auto;padding:0 1em}#navigation{padding:0 1em}@media screen and (min-width:1025px){header{margin-left:calc(var(--nav-width) + var(--nav-margin-l))}header h1{margin:auto;max-width:30em}#navigation{overflow:auto;width:var(--nav-width);height:100vh;position:fixed;top:0;left:0;bottom:0;padding:unset;margin-left:var(--nav-margin-l)}#navigation nav ul{padding-left:1em}#contents-wrapper{margin-left:calc(var(--nav-width) + var(--nav-margin-l))}}a:focus,a:hover{background:#fff2a8}dt{font-weight:700}table,td,th{border-collapse:collapse;border:1px solid grey}td,th{padding:.1em}th[scope=row]{text-align:left;font-weight:400}.t0_1,.t37,.t37_1{font-weight:700}.t2_0{color:#575757}.t31_1{color:#b40000}.t32_1{color:green}.t36_1{color:#005c7a}.file{font-weight:700;border:unset}code{background:#f8f8f8;border:1px dotted silver;padding-left:.3em;padding-right:.3em}pre>code{display:block;overflow:auto;padding:.5em;border:1px solid #eee;line-height:normal}samp{background:#fafafa}pre>samp{display:block;overflow:auto;padding:.5em;border:1px solid #eee;line-height:normal}kbd{font-weight:700}.table-wrapper{width:100%;overflow-x:auto}.tok-kw{color:#333;font-weight:700}.tok-str{color:#d14}.tok-builtin{color:#005c7a}.tok-comment{color:#545454;font-style:italic}.tok-fn{color:#900;font-weight:700}.tok-null{color:#005c5c}.tok-number{color:#005c5c}.tok-type{color:#458;font-weight:700}figure{margin:auto 0}figure pre{margin-top:0}figcaption{padding-left:.5em;font-size:small;border-top-left-radius:5px;border-top-right-radius:5px}figcaption.zig-cap{background:#fcdba5}figcaption.c-cap{background:#a8b9cc;color:#000}figcaption.peg-cap{background:#fcdba5}figcaption.javascript-cap{background:#365d95;color:#fff}figcaption.shell-cap{background:#ccc;color:#000}aside{border-left:.25em solid #f7a41d;padding:0 1em 0 1em}h1 a,h2 a,h3 a,h4 a,h5 a{text-decoration:none;color:#333}a.hdr{visibility:hidden}h1:hover>a.hdr,h2:hover>a.hdr,h3:hover>a.hdr,h4:hover>a.hdr,h5:hover>a.hdr{visibility:visible}pre{counter-reset:line}pre .line:before{counter-increment:line;content:counter(line);display:inline-block;padding-right:1em;width:2em;text-align:right;color:#999}th pre code{background:0 0}th .line:before{display:none}@media (prefers-color-scheme:dark){body{background:#121212;color:#ccc}a{color:#88f}a:focus,a:hover{color:#000}table,td,th{border-color:grey}.t2_0{color:grey}.t31_1{color:red}.t32_1{color:#00b800}.t36_1{color:#0086b3}code{background:#222;border-color:#444}pre>code{color:#ccc;background:#222;border:unset}samp{background:#000;color:#ccc}pre>samp{border:unset}.tok-kw{color:#eee}.tok-str{color:#2e5}.tok-builtin{color:#ff894c}.tok-comment{color:#aa7}.tok-fn{color:#b1a0f8}.tok-null{color:#ff8080}.tok-number{color:#ff8080}.tok-type{color:#68f}h1 a,h2 a,h3 a,h4 a,h5 a{color:#aaa}figcaption.zig-cap{background-color:#b27306;color:#000}figcaption.peg-cap{background-color:#b27306;color:#000}figcaption.shell-cap{background:#2a2a2a;color:#fff}}#contents-wrapper,header{margin-left:0}header h1{margin-top:1em}</style> </head> <body> <header><h1>Zig Language Reference (0.10.0)</h1></header> <div id=main-wrapper> <div id=contents-wrapper><main id=contents> <a name=//apple_ref/cpp/Guide/Introduction class=dashAnchor></a><h2 id=Introduction>Introduction</h2> <p> <a href=https://ziglang.org>Zig</a> is a general-purpose programming language and toolchain for maintaining <strong>robust</strong>, <strong>optimal</strong>, and <strong>reusable</strong> software. </p> <dl> <dt>Robust</dt><dd>Behavior is correct even for edge cases such as out of memory.</dd> <dt>Optimal</dt><dd>Write programs the best way they can behave and perform.</dd> <dt>Reusable</dt><dd>The same code works in many environments which have different constraints.</dd> <dt>Maintainable</dt><dd>Precisely communicate intent to the compiler and other programmers. The language imposes a low overhead to reading code and is resilient to changing requirements and environments.</dd> </dl> <p> Often the most efficient way to learn something new is to see examples, so this documentation shows how to use each of Zig's features. It is all on one page so you can search with your browser's search tool. </p> <p> The code samples in this document are compiled and tested as part of the main test suite of Zig. </p> <p> This HTML document depends on no external files, so you can use it offline. </p> <a name=//apple_ref/cpp/Guide/Zig%20Standard%20Library class=dashAnchor></a><h2 id=Zig-Standard-Library>Zig Standard Library</h2> <p> The <a href=std.html>Zig Standard Library</a> has its own documentation. </p> <p> Zig's Standard Library contains commonly used algorithms, data structures, and definitions to help you build programs or libraries. You will see many examples of Zig's Standard Library used in this documentation. To learn more about the Zig Standard Library, visit the link above. </p> <a name=//apple_ref/cpp/Guide/Hello%20World class=dashAnchor></a><h2 id=Hello-World>Hello World</h2> <figure><figcaption class=zig-cap><cite class=file>hello.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> stdout = std.io.getStdOut().writer();</span>
<span class=line>    <span class=tok-kw>try</span> stdout.print(<span class=tok-str>"Hello, {s}!\n"</span>, .{<span class=tok-str>"world"</span>});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe hello.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./hello</kbd></span>
<span class=line>Hello, world!</span>
</samp></pre></figure> <p> The Zig code sample above demonstrates one way to create a program that will output: <samp>Hello, world!</samp>. </p> <p> The code sample shows the contents of a file named <code class=file>hello.zig</code>. Files storing Zig source code are <a href=#Source-Encoding>UTF-8 encoded</a> text files. The files storing Zig source code are usually named with the <code class=file><em>.zig</em></code> extension. </p> <p> Following the <code class=file>hello.zig</code> Zig code sample, the <a href=#Zig-Build-System>Zig Build System</a> is used to build an executable program from the <code class=file>hello.zig</code> source code. Then, the <code class=file>hello</code> program is executed showing its output <samp>Hello, world!</samp>. The lines beginning with <samp>$</samp> represent command line prompts and a command. Everything else is program output. </p> <p> The code sample begins by adding the <a href=#Zig-Standard-Library>Zig Standard Library</a> to the build using the <a href=#import>@import</a> builtin function. The <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>)</span></code> function call creates a structure that represents the Zig Standard Library. The code then <a href=#Container-Level-Variables>declares</a> a <a href=#Assignment>constant identifier</a>, named <code><span class=line>std</span></code>, that gives access to the features of the Zig Standard Library. </p> <p> Next, a <a href=#Functions>public function</a>, <code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span></span></code>, named <code><span class=line>main</span></code> is declared. The <code><span class=line>main</span></code> function is necessary because it tells the Zig compiler where the start of the program exists. Programs designed to be executed will need a <code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span></span></code> function. </p> <aside role=note aria-label="Note about main function"> <p> For more advanced use cases, Zig offers other features to inform the compiler where the start of the program exists. Also, libraries do not need a <code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span></span></code> function because library code is called by other programs or libraries. </p> </aside> <p> A function is a block of any number of statements and expressions that, as a whole, perform a task. Functions may or may not return data after they are done performing their task. If a function cannot perform its task, it might return an error. Zig makes all of this explicit. </p> <p> In the <code class=file>hello.zig</code> code sample, the <code>main</code> function is declared with the <code><span class=line>!<span class=tok-type>void</span></span></code> return type. This return type is known as an <a href=#Error-Union-Type>Error Union Type</a>. This syntax tells the Zig compiler that the function will either return an error or a value. An error union type combines an <a href=#Error-Set-Type>Error Set Type</a> and any other data type (e.g. a <a href=#Primitive-Types>Primitive Type</a> or a user-defined type such as a <a href=#struct>struct</a>, <a href=#enum>enum</a>, or <a href=#union>union</a>). The full form of an error union type is <code>&lt;error set type&gt;</code><code><span class=line>!</span></code><code>&lt;any data type&gt;</code>. In the code sample, the error set type is not explicitly written on the left side of the <code><span class=line>!</span></code> operator. When written this way, the error set type is an <a href=#Inferred-Error-Sets>inferred error set type</a>. The <code><span class=line><span class=tok-type>void</span></span></code> after the <code><span class=line>!</span></code> operator tells the compiler that the function will not return a value under normal circumstances (i.e. when no errors occur). </p> <aside role=note aria-label="Note to disambiguate exclamation mark operator"> <p> Note to experienced programmers: Zig also has the boolean <a href=#Operators>operator</a> <code><span class=line>!a</span></code> where <code><span class=line>a</span></code> is a value of type <code><span class=line><span class=tok-type>bool</span></span></code>. Error union types contain the name of the type in the syntax: <code><span class=line>!</span></code><code>&lt;any data type&gt;</code>. </p> </aside> <p> In Zig, a function's block of statements and expressions are surrounded by an open curly-brace <code>{</code> and close curly-brace <code>}</code>. Inside of the <code><span class=line>main</span></code> function are expressions that perform the task of outputting <samp>Hello, world!</samp> to standard output. </p> <p> First, a constant identifier, <code><span class=line>stdout</span></code>, is initialized to represent standard output's writer. Then, the program tries to print the <samp>Hello, world!</samp> message to standard output. </p> <p> Functions sometimes need information to perform their task. In Zig, information is passed to functions between an open parenthesis <code><span class=line>(</span></code> and a close parenthesis <code><span class=line>)</span></code> placed after the function's name. This information is also known as arguments. When there are multiple arguments passed to a function, they are separated by commas <code><span class=line>,</span></code>. </p> <p> The two arguments passed to the <code><span class=line>stdout.print()</span></code> function, <code><span class=line><span class=tok-str>"Hello, {s}!\n"</span></span></code> and <code><span class=line>.{<span class=tok-str>"world"</span>}</span></code>, are evaluated at <a href=#comptime>compile-time</a>. The code sample is purposely written to show how to perform <a href=#String-Literals-and-Unicode-Code-Point-Literals>string</a> substitution in the <code><span class=line>print</span></code> function. The curly-braces inside of the first argument are substituted with the compile-time known value inside of the second argument (known as an <a href=#Anonymous-Struct-Literals>anonymous struct literal</a>). The <code>\n</code> inside of the double-quotes of the first argument is the <a href=#Escape-Sequences>escape sequence</a> for the newline character. The <a href=#try>try</a> expression evaluates the result of <code><span class=line>stdout.print</span></code>. If the result is an error, then the <code><span class=line><span class=tok-kw>try</span></span></code> expression will return from <code><span class=line>main</span></code> with the error. Otherwise, the program will continue. In this case, there are no more statements or expressions left to execute in the <code><span class=line>main</span></code> function, so the program exits. </p> <p> In Zig, the standard output writer's <code><span class=line>print</span></code> function is allowed to fail because it is actually a function defined as part of a generic Writer. Consider a generic Writer that represents writing data to a file. When the disk is full, a write to the file will fail. However, we typically do not expect writing text to the standard output to fail. To avoid having to handle the failure case of printing to standard output, you can use alternate functions: the functions in <code><span class=line>std.log</span></code> for proper logging or the <code><span class=line>std.debug.print</span></code> function. This documentation will use the latter option to print to standard error (stderr) and silently return on failure. The next code sample, <code class=file>hello_again.zig</code> demonstrates the use of <code><span class=line>std.debug.print</span></code>. </p> <figure><figcaption class=zig-cap><cite class=file>hello_again.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    print(<span class=tok-str>"Hello, world!\n"</span>, .{});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe hello_again.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./hello_again</kbd></span>
<span class=line>Hello, world!</span>
</samp></pre></figure> <p> Note that you can leave off the <code><span class=line>!</span></code> from the return type because <code><span class=line>std.debug.print</span></code> cannot fail. </p> <p>See also:</p><ul> <li><a href=#Values>Values</a></li> <li><a href=#import>@import</a></li> <li><a href=#Errors>Errors</a></li> <li><a href=#Root-Source-File>Root Source File</a></li> <li><a href=#Source-Encoding>Source Encoding</a></li> </ul> <a name=//apple_ref/cpp/Guide/Comments class=dashAnchor></a><h2 id=Comments>Comments</h2> <figure><figcaption class=zig-cap><cite class=file>comments.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-comment>// Comments in Zig start with "//" and end at the next LF byte (end of line).</span></span>
<span class=line>    <span class=tok-comment>// The line below is a comment and won't be executed.</span></span>
<span class=line></span>
<span class=line>    <span class=tok-comment>//print("Hello?", .{});</span></span>
<span class=line></span>
<span class=line>    print(<span class=tok-str>"Hello, world!\n"</span>, .{}); <span class=tok-comment>// another comment</span></span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe comments.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./comments</kbd></span>
<span class=line>Hello, world!</span>
</samp></pre></figure> <p> There are no multiline comments in Zig (e.g. like <code class=c>/* */</code> comments in C). This helps allow Zig to have the property that each line of code can be tokenized out of context. </p> <a name=//apple_ref/cpp/Guide/Doc%20comments class=dashAnchor></a><h3 id=Doc-comments>Doc comments</h3> <p> A doc comment is one that begins with exactly three slashes (i.e. <code><span class=line><span class=tok-comment>///</span></span></code> but not <code><span class=line><span class=tok-comment>////</span></span></code>); multiple doc comments in a row are merged together to form a multiline doc comment. The doc comment documents whatever immediately follows it. </p> <figure><figcaption class=zig-cap><cite class=file>doc_comments.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>/// A structure for storing a timestamp, with nanosecond precision (this is a</span></span>
<span class=line><span class=tok-comment>/// multiline doc comment).</span></span>
<span class=line><span class=tok-kw>const</span> Timestamp = <span class=tok-kw>struct</span> {</span>
<span class=line>    <span class=tok-comment>/// The number of seconds since the epoch (this is also a doc comment).</span></span>
<span class=line>    seconds: <span class=tok-type>i64</span>,  <span class=tok-comment>// signed so we can represent pre-1970 (not a doc comment)</span></span>
<span class=line>    <span class=tok-comment>/// The number of nanoseconds past the second (doc comment again).</span></span>
<span class=line>    nanos: <span class=tok-type>u32</span>,</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>/// Returns a `Timestamp` struct representing the Unix epoch; that is, the</span></span>
<span class=line>    <span class=tok-comment>/// moment of 1970 Jan 1 00:00:00 UTC (this is a doc comment too).</span></span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>unixEpoch</span>() Timestamp {</span>
<span class=line>        <span class=tok-kw>return</span> Timestamp{</span>
<span class=line>            .seconds = <span class=tok-number>0</span>,</span>
<span class=line>            .nanos = <span class=tok-number>0</span>,</span>
<span class=line>        };</span>
<span class=line>    }</span>
<span class=line>};</span></code></pre></figure> <p> Doc comments are only allowed in certain places; eventually, it will become a compile error to have a doc comment in an unexpected place, such as in the middle of an expression, or just before a non-doc comment. </p> <a name=//apple_ref/cpp/Guide/Top-Level%20Doc%20Comments class=dashAnchor></a><h3 id=Top-Level-Doc-Comments>Top-Level Doc Comments</h3> <p>User documentation that doesn't belong to whatever immediately follows it, like container-level documentation, goes in top-level doc comments. A top-level doc comment is one that begins with two slashes and an exclamation point: <code><span class=line><span class=tok-comment>//!</span></span></code>.</p> <figure><figcaption class=zig-cap><cite class=file>tldoc_comments.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>//! This module provides functions for retrieving the current date and</span></span>
<span class=line><span class=tok-comment>//! time with varying degrees of precision and accuracy. It does not</span></span>
<span class=line><span class=tok-comment>//! depend on libc, but will use functions from it if available.</span></span></code></pre></figure> <a name=//apple_ref/cpp/Guide/Values class=dashAnchor></a><h2 id=Values>Values</h2> <figure><figcaption class=zig-cap><cite class=file>values.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>// Top-level declarations are order-independent:</span></span>
<span class=line><span class=tok-kw>const</span> print = std.debug.print;</span>
<span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> os = std.os;</span>
<span class=line><span class=tok-kw>const</span> assert = std.debug.assert;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-comment>// integers</span></span>
<span class=line>    <span class=tok-kw>const</span> one_plus_one: <span class=tok-type>i32</span> = <span class=tok-number>1</span> + <span class=tok-number>1</span>;</span>
<span class=line>    print(<span class=tok-str>"1 + 1 = {}\n"</span>, .{one_plus_one});</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// floats</span></span>
<span class=line>    <span class=tok-kw>const</span> seven_div_three: <span class=tok-type>f32</span> = <span class=tok-number>7.0</span> / <span class=tok-number>3.0</span>;</span>
<span class=line>    print(<span class=tok-str>"7.0 / 3.0 = {}\n"</span>, .{seven_div_three});</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// boolean</span></span>
<span class=line>    print(<span class=tok-str>"{}\n{}\n{}\n"</span>, .{</span>
<span class=line>        <span class=tok-null>true</span> <span class=tok-kw>and</span> <span class=tok-null>false</span>,</span>
<span class=line>        <span class=tok-null>true</span> <span class=tok-kw>or</span> <span class=tok-null>false</span>,</span>
<span class=line>        !<span class=tok-null>true</span>,</span>
<span class=line>    });</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// optional</span></span>
<span class=line>    <span class=tok-kw>var</span> optional_value: ?[]<span class=tok-kw>const</span> <span class=tok-type>u8</span> = <span class=tok-null>null</span>;</span>
<span class=line>    assert(optional_value == <span class=tok-null>null</span>);</span>
<span class=line></span>
<span class=line>    print(<span class=tok-str>"\noptional 1\ntype: {s}\nvalue: {?s}\n"</span>, .{</span>
<span class=line>        <span class=tok-builtin>@typeName</span>(<span class=tok-builtin>@TypeOf</span>(optional_value)),</span>
<span class=line>        optional_value,</span>
<span class=line>    });</span>
<span class=line></span>
<span class=line>    optional_value = <span class=tok-str>"hi"</span>;</span>
<span class=line>    assert(optional_value != <span class=tok-null>null</span>);</span>
<span class=line></span>
<span class=line>    print(<span class=tok-str>"\noptional 2\ntype: {s}\nvalue: {?s}\n"</span>, .{</span>
<span class=line>        <span class=tok-builtin>@typeName</span>(<span class=tok-builtin>@TypeOf</span>(optional_value)),</span>
<span class=line>        optional_value,</span>
<span class=line>    });</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// error union</span></span>
<span class=line>    <span class=tok-kw>var</span> number_or_error: <span class=tok-type>anyerror</span>!<span class=tok-type>i32</span> = <span class=tok-kw>error</span>.ArgNotFound;</span>
<span class=line></span>
<span class=line>    print(<span class=tok-str>"\nerror union 1\ntype: {s}\nvalue: {!}\n"</span>, .{</span>
<span class=line>        <span class=tok-builtin>@typeName</span>(<span class=tok-builtin>@TypeOf</span>(number_or_error)),</span>
<span class=line>        number_or_error,</span>
<span class=line>    });</span>
<span class=line></span>
<span class=line>    number_or_error = <span class=tok-number>1234</span>;</span>
<span class=line></span>
<span class=line>    print(<span class=tok-str>"\nerror union 2\ntype: {s}\nvalue: {!}\n"</span>, .{</span>
<span class=line>        <span class=tok-builtin>@typeName</span>(<span class=tok-builtin>@TypeOf</span>(number_or_error)),</span>
<span class=line>        number_or_error,</span>
<span class=line>    });</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe values.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./values</kbd></span>
<span class=line>1 + 1 = 2</span>
<span class=line>7.0 / 3.0 = 2.33333325e+00</span>
<span class=line>false</span>
<span class=line>true</span>
<span class=line>false</span>
<span class=line></span>
<span class=line>optional 1</span>
<span class=line>type: ?[]const u8</span>
<span class=line>value: null</span>
<span class=line></span>
<span class=line>optional 2</span>
<span class=line>type: ?[]const u8</span>
<span class=line>value: hi</span>
<span class=line></span>
<span class=line>error union 1</span>
<span class=line>type: anyerror!i32</span>
<span class=line>value: error.ArgNotFound</span>
<span class=line></span>
<span class=line>error union 2</span>
<span class=line>type: anyerror!i32</span>
<span class=line>value: 1234</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Primitive%20Types class=dashAnchor></a><a name=//apple_ref/cpp/Type/i8 class=dashAnchor></a><a name=//apple_ref/cpp/Type/u8 class=dashAnchor></a><a name=//apple_ref/cpp/Type/i16 class=dashAnchor></a><a name=//apple_ref/cpp/Type/u16 class=dashAnchor></a><a name=//apple_ref/cpp/Type/i32 class=dashAnchor></a><a name=//apple_ref/cpp/Type/u32 class=dashAnchor></a><a name=//apple_ref/cpp/Type/i64 class=dashAnchor></a><a name=//apple_ref/cpp/Type/u64 class=dashAnchor></a><a name=//apple_ref/cpp/Type/i128 class=dashAnchor></a><a name=//apple_ref/cpp/Type/u128 class=dashAnchor></a><a name=//apple_ref/cpp/Type/isize class=dashAnchor></a><a name=//apple_ref/cpp/Type/usize class=dashAnchor></a><a name=//apple_ref/cpp/Type/c_short class=dashAnchor></a><a name=//apple_ref/cpp/Type/c_ushort class=dashAnchor></a><a name=//apple_ref/cpp/Type/c_int class=dashAnchor></a><a name=//apple_ref/cpp/Type/c_uint class=dashAnchor></a><a name=//apple_ref/cpp/Type/c_long class=dashAnchor></a><a name=//apple_ref/cpp/Type/c_ulong class=dashAnchor></a><a name=//apple_ref/cpp/Type/c_longlong class=dashAnchor></a><a name=//apple_ref/cpp/Type/c_ulonglong class=dashAnchor></a><a name=//apple_ref/cpp/Type/c_longdouble class=dashAnchor></a><a name=//apple_ref/cpp/Type/f16 class=dashAnchor></a><a name=//apple_ref/cpp/Type/f32 class=dashAnchor></a><a name=//apple_ref/cpp/Type/f64 class=dashAnchor></a><a name=//apple_ref/cpp/Type/f80 class=dashAnchor></a><a name=//apple_ref/cpp/Type/f128 class=dashAnchor></a><a name=//apple_ref/cpp/Type/bool class=dashAnchor></a><a name=//apple_ref/cpp/Type/anyopaque class=dashAnchor></a><a name=//apple_ref/cpp/Type/void class=dashAnchor></a><a name=//apple_ref/cpp/Type/noreturn class=dashAnchor></a><a name=//apple_ref/cpp/Type/type class=dashAnchor></a><a name=//apple_ref/cpp/Type/anyerror class=dashAnchor></a><a name=//apple_ref/cpp/Type/comptime_int class=dashAnchor></a><a name=//apple_ref/cpp/Type/comptime_float class=dashAnchor></a><h3 id=Primitive-Types>Primitive Types</h3> <div class=table-wrapper> <table> <caption>Primitive Types</caption> <thead> <tr> <th scope=col>Type</th> <th scope=col>C Equivalent</th> <th scope=col>Description</th> </tr> </thead> <tbody> <tr> <th scope=row><code><span class=line><span class=tok-type>i8</span></span></code></th> <td><code class=c>int8_t</code></td> <td>signed 8-bit integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>u8</span></span></code></th> <td><code class=c>uint8_t</code></td> <td>unsigned 8-bit integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>i16</span></span></code></th> <td><code class=c>int16_t</code></td> <td>signed 16-bit integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>u16</span></span></code></th> <td><code class=c>uint16_t</code></td> <td>unsigned 16-bit integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>i32</span></span></code></th> <td><code class=c>int32_t</code></td> <td>signed 32-bit integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>u32</span></span></code></th> <td><code class=c>uint32_t</code></td> <td>unsigned 32-bit integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>i64</span></span></code></th> <td><code class=c>int64_t</code></td> <td>signed 64-bit integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>u64</span></span></code></th> <td><code class=c>uint64_t</code></td> <td>unsigned 64-bit integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>i128</span></span></code></th> <td><code class=c>__int128</code></td> <td>signed 128-bit integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>u128</span></span></code></th> <td><code class=c>unsigned __int128</code></td> <td>unsigned 128-bit integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>isize</span></span></code></th> <td><code class=c>intptr_t</code></td> <td>signed pointer sized integer</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>usize</span></span></code></th> <td><code class=c>uintptr_t</code>, <code class=c>size_t</code></td> <td>unsigned pointer sized integer. Also see <a href=https://github.com/ziglang/zig/issues/5185>#5185</a></td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>c_short</span></span></code></th> <td><code class=c>short</code></td> <td>for ABI compatibility with C</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>c_ushort</span></span></code></th> <td><code class=c>unsigned short</code></td> <td>for ABI compatibility with C</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>c_int</span></span></code></th> <td><code class=c>int</code></td> <td>for ABI compatibility with C</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>c_uint</span></span></code></th> <td><code class=c>unsigned int</code></td> <td>for ABI compatibility with C</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>c_long</span></span></code></th> <td><code class=c>long</code></td> <td>for ABI compatibility with C</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>c_ulong</span></span></code></th> <td><code class=c>unsigned long</code></td> <td>for ABI compatibility with C</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>c_longlong</span></span></code></th> <td><code class=c>long long</code></td> <td>for ABI compatibility with C</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>c_ulonglong</span></span></code></th> <td><code class=c>unsigned long long</code></td> <td>for ABI compatibility with C</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>c_longdouble</span></span></code></th> <td><code class=c>long double</code></td> <td>for ABI compatibility with C</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>f16</span></span></code></th> <td><code class=c>_Float16</code></td> <td>16-bit floating point (10-bit mantissa) IEEE-754-2008 binary16</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>f32</span></span></code></th> <td><code class=c>float</code></td> <td>32-bit floating point (23-bit mantissa) IEEE-754-2008 binary32</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>f64</span></span></code></th> <td><code class=c>double</code></td> <td>64-bit floating point (52-bit mantissa) IEEE-754-2008 binary64</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>f80</span></span></code></th> <td><code class=c>double</code></td> <td>80-bit floating point (64-bit mantissa) IEEE-754-2008 80-bit extended precision</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>f128</span></span></code></th> <td><code class=c>_Float128</code></td> <td>128-bit floating point (112-bit mantissa) IEEE-754-2008 binary128</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>bool</span></span></code></th> <td><code class=c>bool</code></td> <td><code><span class=line><span class=tok-null>true</span></span></code> or <code><span class=line><span class=tok-null>false</span></span></code></td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>anyopaque</span></span></code></th> <td><code class=c>void</code></td> <td>Used for type-erased pointers.</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>void</span></span></code></th> <td>(none)</td> <td>Always the value <code><span class=line><span class=tok-type>void</span>{}</span></code></td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>noreturn</span></span></code></th> <td>(none)</td> <td>the type of <code><span class=line><span class=tok-kw>break</span></span></code>, <code><span class=line><span class=tok-kw>continue</span></span></code>, <code><span class=line><span class=tok-kw>return</span></span></code>, <code><span class=line><span class=tok-kw>unreachable</span></span></code>, and <code><span class=line><span class=tok-kw>while</span> (<span class=tok-null>true</span>) {}</span></code></td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>type</span></span></code></th> <td>(none)</td> <td>the type of types</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>anyerror</span></span></code></th> <td>(none)</td> <td>an error code</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>comptime_int</span></span></code></th> <td>(none)</td> <td>Only allowed for <a href=#comptime>comptime</a>-known values. The type of integer literals.</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-type>comptime_float</span></span></code></th> <td>(none)</td> <td>Only allowed for <a href=#comptime>comptime</a>-known values. The type of float literals.</td> </tr> </tbody> </table> </div> <p> In addition to the integer types above, arbitrary bit-width integers can be referenced by using an identifier of <code>i</code> or <code>u</code> followed by digits. For example, the identifier <code><span class=line><span class=tok-type>i7</span></span></code> refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is <code><span class=line><span class=tok-number>65535</span></span></code>. </p> <p>See also:</p><ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> <li><a href=#void>void</a></li> <li><a href=#Errors>Errors</a></li> <li><a href=#Type>@Type</a></li> </ul> <a name=//apple_ref/cpp/Guide/Primitive%20Values class=dashAnchor></a><h3 id=Primitive-Values>Primitive Values</h3> <div class=table-wrapper> <table> <caption>Primitive Values</caption> <thead> <tr> <th scope=col>Name</th> <th scope=col>Description</th> </tr> </thead> <tbody> <tr> <th scope=row><code><span class=line><span class=tok-null>true</span></span></code> and <code><span class=line><span class=tok-null>false</span></span></code></th> <td><code><span class=line><span class=tok-type>bool</span></span></code> values</td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-null>null</span></span></code></th> <td>used to set an optional type to <code><span class=line><span class=tok-null>null</span></span></code></td> </tr> <tr> <th scope=row><code><span class=line><span class=tok-null>undefined</span></span></code></th> <td>used to leave a value unspecified</td> </tr> </tbody> </table> </div> <p>See also:</p><ul> <li><a href=#Optionals>Optionals</a></li> <li><a href="#undefined">undefined</a></li> </ul> <a name=//apple_ref/cpp/Guide/String%20Literals%20and%20Unicode%20Code%20Point%20Literals class=dashAnchor></a><h3 id=String-Literals-and-Unicode-Code-Point-Literals>String Literals and Unicode Code Point Literals</h3> <p> String literals are constant single-item <a href=#Pointers>Pointers</a> to null-terminated byte arrays. The type of string literals encodes both the length, and the fact that they are null-terminated, and thus they can be <a href=#Type-Coercion>coerced</a> to both <a href=#Slices>Slices</a> and <a href=#Sentinel-Terminated-Pointers>Null-Terminated Pointers</a>. Dereferencing string literals converts them to <a href=#Arrays>Arrays</a>. </p> <p> The encoding of a string in Zig is de-facto assumed to be UTF-8. Because Zig source code is <a href=#Source-Encoding>UTF-8 encoded</a>, any non-ASCII bytes appearing within a string literal in source code carry their UTF-8 meaning into the content of the string in the Zig program; the bytes are not modified by the compiler. However, it is possible to embed non-UTF-8 bytes into a string literal using <code>\xNN</code> notation. </p> <p> Unicode code point literals have type <code><span class=line><span class=tok-type>comptime_int</span></span></code>, the same as <a href=#Integer-Literals>Integer Literals</a>. All <a href=#Escape-Sequences>Escape Sequences</a> are valid in both string literals and Unicode code point literals. </p> <p> In many other programming languages, a Unicode code point literal is called a "character literal". However, there is <a href=https://unicode.org/glossary>no precise technical definition of a "character"</a> in recent versions of the Unicode specification (as of Unicode 13.0). In Zig, a Unicode code point literal corresponds to the Unicode definition of a code point. </p> <figure><figcaption class=zig-cap><cite class=file>string_literals.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line><span class=tok-kw>const</span> mem = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).mem; <span class=tok-comment>// will be used to compare bytes</span></span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> bytes = <span class=tok-str>"hello"</span>;</span>
<span class=line>    print(<span class=tok-str>"{s}\n"</span>, .{<span class=tok-builtin>@typeName</span>(<span class=tok-builtin>@TypeOf</span>(bytes))});       <span class=tok-comment>// *const [5:0]u8</span></span>
<span class=line>    print(<span class=tok-str>"{d}\n"</span>, .{bytes.len});                       <span class=tok-comment>// 5</span></span>
<span class=line>    print(<span class=tok-str>"{c}\n"</span>, .{bytes[<span class=tok-number>1</span>]});                        <span class=tok-comment>// 'e'</span></span>
<span class=line>    print(<span class=tok-str>"{d}\n"</span>, .{bytes[<span class=tok-number>5</span>]});                        <span class=tok-comment>// 0</span></span>
<span class=line>    print(<span class=tok-str>"{}\n"</span>, .{<span class=tok-str>'e'</span> == <span class=tok-str>'\x65'</span>});                    <span class=tok-comment>// true</span></span>
<span class=line>    print(<span class=tok-str>"{d}\n"</span>, .{<span class=tok-str>'\u{1f4a9}'</span>});                     <span class=tok-comment>// 128169</span></span>
<span class=line>    print(<span class=tok-str>"{d}\n"</span>, .{<span class=tok-str>'💯'</span>});                            <span class=tok-comment>// 128175</span></span>
<span class=line>    print(<span class=tok-str>"{}\n"</span>, .{mem.eql(<span class=tok-type>u8</span>, <span class=tok-str>"hello"</span>, <span class=tok-str>"h\x65llo"</span>)}); <span class=tok-comment>// true</span></span>
<span class=line>    print(<span class=tok-str>"0x{x}\n"</span>, .{<span class=tok-str>"\xff"</span>[<span class=tok-number>0</span>]}); <span class=tok-comment>// non-UTF-8 strings are possible with \xNN notation.</span></span>
<span class=line>    print(<span class=tok-str>"{u}\n"</span>, .{<span class=tok-str>'⚡'</span>});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe string_literals.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./string_literals</kbd></span>
<span class=line>*const [5:0]u8</span>
<span class=line>5</span>
<span class=line>e</span>
<span class=line>0</span>
<span class=line>true</span>
<span class=line>128169</span>
<span class=line>128175</span>
<span class=line>true</span>
<span class=line>0xff</span>
<span class=line>⚡</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Arrays>Arrays</a></li> <li><a href=#Source-Encoding>Source Encoding</a></li> </ul> <a name=//apple_ref/cpp/Guide/Escape%20Sequences class=dashAnchor></a><h4 id=Escape-Sequences>Escape Sequences</h4> <div class=table-wrapper> <table> <caption>Escape Sequences</caption> <thead> <tr> <th scope=col>Escape Sequence</th> <th scope=col>Name</th> </tr> </thead> <tbody> <tr> <th scope=row><code>\n</code></th> <td>Newline</td> </tr> <tr> <th scope=row><code>\r</code></th> <td>Carriage Return</td> </tr> <tr> <th scope=row><code>\t</code></th> <td>Tab</td> </tr> <tr> <th scope=row><code>\\</code></th> <td>Backslash</td> </tr> <tr> <th scope=row><code>\'</code></th> <td>Single Quote</td> </tr> <tr> <th scope=row><code>\"</code></th> <td>Double Quote</td> </tr> <tr> <th scope=row><code>\xNN</code></th> <td>hexadecimal 8-bit byte value (2 digits)</td> </tr> <tr> <th scope=row><code>\u{NNNNNN}</code></th> <td>hexadecimal Unicode code point UTF-8 encoded (1 or more digits)</td> </tr> </tbody> </table> </div> <p>Note that the maximum valid Unicode point is <code><span class=line><span class=tok-number>0x10ffff</span></span></code>.</p> <a name=//apple_ref/cpp/Guide/Multiline%20String%20Literals class=dashAnchor></a><h4 id=Multiline-String-Literals>Multiline String Literals</h4> <p> Multiline string literals have no escapes and can span across multiple lines. To start a multiline string literal, use the <code><span class=line><span class=tok-str>\\</span></span></code> token. Just like a comment, the string literal goes until the end of the line. The end of the line is not included in the string literal. However, if the next line begins with <code><span class=line><span class=tok-str>\\</span></span></code> then a newline is appended and the string literal continues. </p> <figure><figcaption class=zig-cap><cite class=file>multiline_string_literals.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> hello_world_in_c =</span>
<span class=line>    <span class=tok-str>\\#include &lt;stdio.h&gt;</span></span>
<span class=line>    <span class=tok-str>\\</span></span>
<span class=line>    <span class=tok-str>\\int main(int argc, char **argv) {</span></span>
<span class=line>    <span class=tok-str>\\    printf("hello world\n");</span></span>
<span class=line>    <span class=tok-str>\\    return 0;</span></span>
<span class=line>    <span class=tok-str>\\}</span></span>
<span class=line>;</span></code></pre></figure> <p>See also:</p><ul> <li><a href=#embedFile>@embedFile</a></li> </ul> <a name=//apple_ref/cpp/Guide/Assignment class=dashAnchor></a><h3 id=Assignment>Assignment</h3> <p>Use the <code><span class=line><span class=tok-kw>const</span></span></code> keyword to assign a value to an identifier:</p> <figure><figcaption class=zig-cap><cite class=file>constant_identifier_cannot_change.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> x = <span class=tok-number>1234</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-comment>// It works at file scope as well as inside functions.</span></span>
<span class=line>    <span class=tok-kw>const</span> y = <span class=tok-number>5678</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Once assigned, an identifier cannot be changed.</span></span>
<span class=line>    y += <span class=tok-number>1</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    foo();</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe constant_identifier_cannot_change.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/constant_identifier_cannot_change.zig:8:7: </span><span class=t31_1>error: </span><span class=t1_0>cannot assign to constant</span>
<span class=line></span>    y += 1;</span>
<span class=line>    <span class=t32_1>~~^~~~</span>
<span class=line></span><span class=t2_0>referenced by:</span>
<span class=line>    main: docgen_tmp/constant_identifier_cannot_change.zig:12:5</span>
<span class=line>    callMain: /home/andy/tmp/zig/lib/std/start.zig:596:17</span>
<span class=line>    remaining reference traces hidden; use '-freference-trace' to see all reference traces</span>
<span class=line></span>
<span class=line></span></span>
</samp></pre></figure> <p><code><span class=line><span class=tok-kw>const</span></span></code> applies to all of the bytes that the identifier immediately addresses. <a href=#Pointers>Pointers</a> have their own const-ness.</p> <p>If you need a variable that you can modify, use the <code><span class=line><span class=tok-kw>var</span></span></code> keyword:</p> <figure><figcaption class=zig-cap><cite class=file>mutable_var.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> y: <span class=tok-type>i32</span> = <span class=tok-number>5678</span>;</span>
<span class=line></span>
<span class=line>    y += <span class=tok-number>1</span>;</span>
<span class=line></span>
<span class=line>    print(<span class=tok-str>"{d}"</span>, .{y});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe mutable_var.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./mutable_var</kbd></span>
<span class=line>5679</span>
</samp></pre></figure> <p>Variables must be initialized:</p> <figure><figcaption class=zig-cap><cite class=file>var_must_be_initialized.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>i32</span>;</span>
<span class=line></span>
<span class=line>    x = <span class=tok-number>1</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe var_must_be_initialized.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/var_must_be_initialized.zig:2:5: </span><span class=t31_1>error: </span><span class=t1_0>variables must be initialized</span>
<span class=line></span>    var x: i32;</span>
<span class=line>    <span class=t32_1>^~~~~~~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <a name="//apple_ref/cpp/Keyword/undefined" class=dashAnchor></a><h4 id="undefined">undefined</h4> <p>Use <code><span class=line><span class=tok-null>undefined</span></span></code> to leave variables uninitialized:</p> <figure><figcaption class=zig-cap><cite class=file>assign_undefined.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-null>undefined</span>;</span>
<span class=line>    x = <span class=tok-number>1</span>;</span>
<span class=line>    print(<span class=tok-str>"{d}"</span>, .{x});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe assign_undefined.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./assign_undefined</kbd></span>
<span class=line>1</span>
</samp></pre></figure> <p> <code><span class=line><span class=tok-null>undefined</span></span></code> can be <a href=#Type-Coercion>coerced</a> to any type. Once this happens, it is no longer possible to detect that the value is <code><span class=line><span class=tok-null>undefined</span></span></code>. <code><span class=line><span class=tok-null>undefined</span></span></code> means the value could be anything, even something that is nonsense according to the type. Translated into English, <code><span class=line><span class=tok-null>undefined</span></span></code> means "Not a meaningful value. Using this value would be a bug. The value will be unused, or overwritten before being used." </p> <p> In <a href=#Debug>Debug</a> mode, Zig writes <code><span class=line><span class=tok-number>0xaa</span></span></code> bytes to undefined memory. This is to catch bugs early, and to help detect use of undefined memory in a debugger. However, this behavior is only an implementation feature, not a language semantic, so it is not guaranteed to be observable to code. </p> <a name=//apple_ref/cpp/Guide/Zig%20Test class=dashAnchor></a><h2 id=Zig-Test>Zig Test</h2> <p> Code written within one or more <code><span class=line><span class=tok-kw>test</span></span></code> declarations can be used to ensure behavior meets expectations: </p> <figure><figcaption class=zig-cap><cite class=file>introducing_zig_test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"expect addOne adds one to 41"</span> {</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// The Standard Library contains useful functions to help create tests.</span></span>
<span class=line>    <span class=tok-comment>// `expect` is a function that verifies its argument is true.</span></span>
<span class=line>    <span class=tok-comment>// It will return an error if its argument is false to indicate a failure.</span></span>
<span class=line>    <span class=tok-comment>// `try` is used to return an error to the test runner to notify it that the test failed.</span></span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expect(addOne(<span class=tok-number>41</span>) == <span class=tok-number>42</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>/// The function `addOne` adds one to the number given as its argument.</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>addOne</span>(number: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> number + <span class=tok-number>1</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test introducing_zig_test.zig</kbd></span>
<span class=line>1/1 test.expect addOne adds one to 41... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> The <code class=file>introducing_zig_test.zig</code> code sample tests the <a href=#Functions>function</a> <code><span class=line>addOne</span></code> to ensure that it returns <code><span class=line><span class=tok-number>42</span></span></code> given the input <code><span class=line><span class=tok-number>41</span></span></code>. From this test's perspective, the <code><span class=line>addOne</span></code> function is said to be <em>code under test</em>. </p> <p> <kbd>zig test</kbd> is a tool that creates and runs a test build. By default, it builds and runs an executable program using the <em>default test runner</em> provided by the <a href=#Zig-Standard-Library>Zig Standard Library</a> as its main entry point. During the build, <code><span class=line><span class=tok-kw>test</span></span></code> declarations found while <a href=#Root-Source-File>resolving</a> the given Zig source file are included for the default test runner to run and report on. </p> <aside> This documentation discusses the features of the default test runner as provided by the Zig Standard Library. Its source code is located in <code class=file>lib/test_runner.zig</code>. </aside> <p> The shell output shown above displays two lines after the <kbd>zig test</kbd> command. These lines are printed to standard error by the default test runner: </p> <dl> <dt><samp>Test [1/1] test "expect addOne adds one to 41"...</samp></dt> <dd>Lines like this indicate which test, out of the total number of tests, is being run. In this case, <samp>[1/1]</samp> indicates that the first test, out of a total of one test, is being run. Note that, when the test runner program's standard error is output to the terminal, these lines are cleared when a test succeeds. </dd> <dt><samp>All 1 tests passed.</samp></dt> <dd>This line indicates the total number of tests that have passed.</dd> </dl> <a name=//apple_ref/cpp/Guide/Test%20Declarations class=dashAnchor></a><h3 id=Test-Declarations>Test Declarations</h3> <p> Test declarations contain the <a href=#Keyword-Reference>keyword</a> <code><span class=line><span class=tok-kw>test</span></span></code>, followed by an optional name written as a <a href=#String-Literals-and-Unicode-Code-Point-Literals>string literal</a>, followed by a <a href=#Blocks>block</a> containing any valid Zig code that is allowed in a <a href=#Functions>function</a>. </p> <aside> By convention, non-named tests should only be used to <a href=#Nested-Container-Tests>make other tests run</a>. Non-named tests cannot be <a href=#Skip-Tests>filtered</a>. </aside> <p> Test declarations are similar to <a href=#Functions>Functions</a>: they have a return type and a block of code. The implicit return type of <code><span class=line><span class=tok-kw>test</span></span></code> is the <a href=#Error-Union-Type>Error Union Type</a> <code><span class=line><span class=tok-type>anyerror</span>!<span class=tok-type>void</span></span></code>, and it cannot be changed. When a Zig source file is not built using the <kbd>zig test</kbd> tool, the test declarations are omitted from the build. </p> <p> Test declarations can be written in the same file, where code under test is written, or in a separate Zig source file. Since test declarations are top-level declarations, they are order-independent and can be written before or after the code under test. </p> <p>See also:</p><ul> <li><a href=#The-Global-Error-Set>The Global Error Set</a></li> <li><a href=#Grammar>Grammar</a></li> </ul> <a name=//apple_ref/cpp/Guide/Nested%20Container%20Tests class=dashAnchor></a><h3 id=Nested-Container-Tests>Nested Container Tests</h3> <p> When the <kbd>zig test</kbd> tool is building a test runner, only resolved <code><span class=line><span class=tok-kw>test</span></span></code> declarations are included in the build. Initially, only the given Zig source file's top-level declarations are resolved. Unless nested containers are referenced from a top-level test declaration, nested container tests will not be resolved. </p> <p> The code sample below uses the <code><span class=line>std.testing.refAllDecls(<span class=tok-builtin>@This</span>())</span></code> function call to reference all of the containers that are in the file including the imported Zig source file. The code sample also shows an alternative way to reference containers using the <code><span class=line>_ = C;</span></code> syntax. This syntax tells the compiler to ignore the result of the expression on the right side of the assignment operator. </p> <figure><figcaption class=zig-cap><cite class=file>testdecl_container_top_level.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Imported source file tests will run when referenced from a top-level test declaration.</span></span>
<span class=line><span class=tok-comment>// The next line alone does not cause "introducing_zig_test.zig" tests to run.</span></span>
<span class=line><span class=tok-kw>const</span> imported_file = <span class=tok-builtin>@import</span>(<span class=tok-str>"introducing_zig_test.zig"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> {</span>
<span class=line>    <span class=tok-comment>// To run nested container tests, either, call `refAllDecls` which will</span></span>
<span class=line>    <span class=tok-comment>// reference all declarations located in the given argument.</span></span>
<span class=line>    <span class=tok-comment>// `@This()` is a builtin function that returns the innermost container it is called from.</span></span>
<span class=line>    <span class=tok-comment>// In this example, the innermost container is this file (implicitly a struct).</span></span>
<span class=line>    std.testing.refAllDecls(<span class=tok-builtin>@This</span>());</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// or, reference each container individually from a top-level test declaration.</span></span>
<span class=line>    <span class=tok-comment>// The `_ = C;` syntax is a no-op reference to the identifier `C`.</span></span>
<span class=line>    _ = S;</span>
<span class=line>    _ = U;</span>
<span class=line>    _ = <span class=tok-builtin>@import</span>(<span class=tok-str>"introducing_zig_test.zig"</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> S = <span class=tok-kw>struct</span> {</span>
<span class=line>    <span class=tok-kw>test</span> <span class=tok-str>"S demo test"</span> {</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-null>true</span>);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> SE = <span class=tok-kw>enum</span> {</span>
<span class=line>        V,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// This test won't run because its container (SE) is not referenced.</span></span>
<span class=line>        <span class=tok-kw>test</span> <span class=tok-str>"This Test Won't Run"</span> {</span>
<span class=line>            <span class=tok-kw>try</span> expect(<span class=tok-null>false</span>);</span>
<span class=line>        }</span>
<span class=line>    };</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> U = <span class=tok-kw>union</span> { <span class=tok-comment>// U is referenced by the file's top-level test declaration</span></span>
<span class=line>    s: US,        <span class=tok-comment>// and US is referenced here; therefore, "U.Us demo test" will run</span></span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> US = <span class=tok-kw>struct</span> {</span>
<span class=line>        <span class=tok-kw>test</span> <span class=tok-str>"U.US demo test"</span> {</span>
<span class=line>            <span class=tok-comment>// This test is a top-level test declaration for the struct.</span></span>
<span class=line>            <span class=tok-comment>// The struct is nested (declared) inside of a union.</span></span>
<span class=line>            <span class=tok-kw>try</span> expect(<span class=tok-null>true</span>);</span>
<span class=line>        }</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>test</span> <span class=tok-str>"U demo test"</span> {</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-null>true</span>);</span>
<span class=line>    }</span>
<span class=line>};</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test testdecl_container_top_level.zig</kbd></span>
<span class=line>1/4 test_0... OK</span>
<span class=line>2/4 test.S demo test... OK</span>
<span class=line>3/4 test.U demo test... OK</span>
<span class=line>4/4 test.expect addOne adds one to 41... OK</span>
<span class=line>All 4 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Test%20Failure class=dashAnchor></a><h3 id=Test-Failure>Test Failure</h3> <p> The default test runner checks for an <a href=#Errors>error</a> returned from a test. When a test returns an error, the test is considered a failure and its <a href=#Error-Return-Traces>error return trace</a> is output to standard error. The total number of failures will be reported after all tests have run. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"expect this to fail"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expect(<span class=tok-null>false</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"expect this to succeed"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expect(<span class=tok-null>true</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/2 test.expect this to fail... FAIL (TestUnexpectedResult)</span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/testing.zig:347:14</span>: <span class=t2_0>0x21158f in expect (test)</span></span>
<span class=line>    if (!ok) return error.TestUnexpectedResult;</span>
<span class=line>             <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:4:5</span>: <span class=t2_0>0x2116a5 in test.expect this to fail (test)</span></span>
<span class=line>    try std.testing.expect(false);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>2/2 test.expect this to succeed... OK</span>
<span class=line>1 passed; 0 skipped; 1 failed.</span>
<span class=line>error: the following test command failed with exit code 1:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Skip%20Tests class=dashAnchor></a><h3 id=Skip-Tests>Skip Tests</h3> <p> One way to skip tests is to filter them out by using the <kbd>zig test</kbd> command line parameter <kbd>--test-filter [text]</kbd>. This makes the test build only include tests whose name contains the supplied filter text. Note that non-named tests are run even when using the <kbd>--test-filter [text]</kbd> command line parameter. </p> <p> To programmatically skip a test, make a <code><span class=line><span class=tok-kw>test</span></span></code> return the error <code><span class=line><span class=tok-kw>error</span>.SkipZigTest</span></code> and the default test runner will consider the test as being skipped. The total number of skipped tests will be reported after all tests have run. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"this will be skipped"</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>error</span>.SkipZigTest;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.this will be skipped... SKIP</span>
<span class=line>0 passed; 1 skipped; 0 failed.</span>
</samp></pre></figure> <p> The default test runner skips tests containing a <a href=#Async-Functions>suspend point</a> while the test is running using the default, blocking IO mode. (The evented IO mode is enabled using the <kbd>--test-evented-io</kbd> command line parameter.) </p> <figure><figcaption class=zig-cap><cite class=file>async_skip.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"async skip test"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> frame = <span class=tok-kw>async</span> func();</span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>await</span> frame;</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expect(result == <span class=tok-number>1</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>func</span>() <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>suspend</span> {</span>
<span class=line>        <span class=tok-kw>resume</span> <span class=tok-builtin>@frame</span>();</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-number>1</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test async_skip.zig -fstage1</kbd></span>
<span class=line>1/1 test "async skip test"... SKIP (async test)</span>
<span class=line>0 passed; 1 skipped; 0 failed.</span>
</samp></pre></figure> <p> In the code sample above, the test would not be skipped in blocking IO mode if the <code><span class=line><span class=tok-kw>nosuspend</span></span></code> keyword was used (see <a href=#Async-and-Await>Async and Await</a>). </p> <a name=//apple_ref/cpp/Guide/Report%20Memory%20Leaks class=dashAnchor></a><h3 id=Report-Memory-Leaks>Report Memory Leaks</h3> <p> When code allocates <a href=#Memory>Memory</a> using the <a href=#Zig-Standard-Library>Zig Standard Library</a>'s testing allocator, <code><span class=line>std.testing.allocator</span></code>, the default test runner will report any leaks that are found from using the testing allocator: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"detect leak"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> list = std.ArrayList(<span class=tok-type>u21</span>).init(std.testing.allocator);</span>
<span class=line>    <span class=tok-comment>// missing `defer list.deinit();`</span></span>
<span class=line>    <span class=tok-kw>try</span> list.append(<span class=tok-str>'☔'</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expect(list.items.len == <span class=tok-number>1</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.detect leak... OK</span>
<span class=line>[gpa] (err): memory address 0x7fb56058c000 leaked:</span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/array_list.zig:353:89</span>: <span class=t2_0>0x225487 in ensureTotalCapacityPrecise (test)</span></span>
<span class=line>                const new_memory = try self.allocator.reallocAtLeast(self.allocatedSlice(), new_capacity);</span>
<span class=line>                                                                                        <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/array_list.zig:338:55</span>: <span class=t2_0>0x21b6d6 in ensureTotalCapacity (test)</span></span>
<span class=line>                return self.ensureTotalCapacityPrecise(better_capacity);</span>
<span class=line>                                                      <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/array_list.zig:377:41</span>: <span class=t2_0>0x218f5c in addOne (test)</span></span>
<span class=line>            try self.ensureTotalCapacity(newlen);</span>
<span class=line>                                        <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/array_list.zig:167:49</span>: <span class=t2_0>0x213685 in append (test)</span></span>
<span class=line>            const new_item_ptr = try self.addOne();</span>
<span class=line>                                                <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:6:20</span>: <span class=t2_0>0x2135c2 in test.detect leak (test)</span></span>
<span class=line>    try list.append('☔');</span>
<span class=line>                   <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x219ce8 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x213fab in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x213a71 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line></span>
<span class=line></span>
<span class=line>All 1 tests passed.</span>
<span class=line>1 errors were logged.</span>
<span class=line>1 tests leaked memory.</span>
<span class=line>error: the following test command failed with exit code 1:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#defer>defer</a></li> <li><a href=#Memory>Memory</a></li> </ul> <a name=//apple_ref/cpp/Guide/Detecting%20Test%20Build class=dashAnchor></a><h3 id=Detecting-Test-Build>Detecting Test Build</h3> <p> Use the <a href=#Compile-Variables>compile variable</a> <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>).is_test</span></code> to detect a test build: </p> <figure><figcaption class=zig-cap><cite class=file>detect_test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> builtin = <span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"builtin.is_test"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(isATest());</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>isATest</span>() <span class=tok-type>bool</span> {</span>
<span class=line>    <span class=tok-kw>return</span> builtin.is_test;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test detect_test.zig</kbd></span>
<span class=line>1/1 test.builtin.is_test... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Test%20Output%20and%20Logging class=dashAnchor></a><h3 id=Test-Output-and-Logging>Test Output and Logging</h3> <p> The default test runner and the Zig Standard Library's testing namespace output messages to standard error. </p> <a name=//apple_ref/cpp/Guide/The%20Testing%20Namespace class=dashAnchor></a><h3 id=The-Testing-Namespace>The Testing Namespace</h3> <p> The Zig Standard Library's <code>testing</code> namespace contains useful functions to help you create tests. In addition to the <code>expect</code> function, this document uses a couple of more functions as exemplified here: </p> <figure><figcaption class=zig-cap><cite class=file>testing_functions.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"expectEqual demo"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> expected: <span class=tok-type>i32</span> = <span class=tok-number>42</span>;</span>
<span class=line>    <span class=tok-kw>const</span> actual = <span class=tok-number>42</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// The first argument to `expectEqual` is the known, expected, result.</span></span>
<span class=line>    <span class=tok-comment>// The second argument is the result of some expression.</span></span>
<span class=line>    <span class=tok-comment>// The actual's type is casted to the type of expected.</span></span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expectEqual(expected, actual);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"expectError demo"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> expected_error = <span class=tok-kw>error</span>.DemoError;</span>
<span class=line>    <span class=tok-kw>const</span> actual_error_union: <span class=tok-type>anyerror</span>!<span class=tok-type>void</span> = <span class=tok-kw>error</span>.DemoError;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// `expectError` will fail when the actual error is different than</span></span>
<span class=line>    <span class=tok-comment>// the expected error.</span></span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expectError(expected_error, actual_error_union);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test testing_functions.zig</kbd></span>
<span class=line>1/2 test.expectEqual demo... OK</span>
<span class=line>2/2 test.expectError demo... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <p>The Zig Standard Library also contains functions to compare <a href=#Slices>Slices</a>, strings, and more. See the rest of the <code><span class=line>std.testing</span></code> namespace in the <a href=#Zig-Standard-Library>Zig Standard Library</a> for more available functions.</p> <a name=//apple_ref/cpp/Guide/Test%20Tool%20Documentation class=dashAnchor></a><h3 id=Test-Tool-Documentation>Test Tool Documentation</h3> <p> <kbd>zig test</kbd> has a few command line parameters which affect the compilation. See <kbd>zig test --help</kbd> for a full list. </p> <a name=//apple_ref/cpp/Guide/Variables class=dashAnchor></a><h2 id=Variables>Variables</h2> <p> A variable is a unit of <a href=#Memory>Memory</a> storage. </p> <p> It is generally preferable to use <code><span class=line><span class=tok-kw>const</span></span></code> rather than <code><span class=line><span class=tok-kw>var</span></span></code> when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities. </p> <a name=//apple_ref/cpp/Guide/Identifiers class=dashAnchor></a><h3 id=Identifiers>Identifiers</h3> <p> Variable identifiers are never allowed to shadow identifiers from an outer scope. </p> <p> Identifiers must start with an alphabetic character or underscore and may be followed by any number of alphanumeric characters or underscores. They must not overlap with any keywords. See <a href=#Keyword-Reference>Keyword Reference</a>. </p> <p> If a name that does not fit these requirements is needed, such as for linking with external libraries, the <code><span class=line>@""</span></code> syntax may be used. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> @"identifier with spaces in it" = <span class=tok-number>0xff</span>;</span>
<span class=line><span class=tok-kw>const</span> @"1SmallStep4Man" = <span class=tok-number>112358</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> c = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).c;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>extern</span> <span class=tok-str>"c"</span> <span class=tok-kw>fn</span> <span class=tok-fn>@"error"</span>() <span class=tok-type>void</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>extern</span> <span class=tok-str>"c"</span> <span class=tok-kw>fn</span> <span class=tok-fn>@"fstat$INODE64"</span>(fd: c.fd_t, buf: *c.Stat) <span class=tok-type>c_int</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Color = <span class=tok-kw>enum</span> {</span>
<span class=line>  red,</span>
<span class=line>  @"really red",</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> color: Color = .@"really red";</span></code></pre></figure> <a name=//apple_ref/cpp/Guide/Container%20Level%20Variables class=dashAnchor></a><h3 id=Container-Level-Variables>Container Level Variables</h3> <p> Container level variables have static lifetime and are order-independent and lazily analyzed. The initialization value of container level variables is implicitly <a href=#comptime>comptime</a>. If a container level variable is <code><span class=line><span class=tok-kw>const</span></span></code> then its value is <code><span class=line><span class=tok-kw>comptime</span></span></code>-known, otherwise it is runtime-known. </p> <figure><figcaption class=zig-cap><cite class=file>container_level_variables.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>var</span> y: <span class=tok-type>i32</span> = add(<span class=tok-number>10</span>, x);</span>
<span class=line><span class=tok-kw>const</span> x: <span class=tok-type>i32</span> = add(<span class=tok-number>12</span>, <span class=tok-number>34</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"container level variables"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(x == <span class=tok-number>46</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(y == <span class=tok-number>56</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>add</span>(a: <span class=tok-type>i32</span>, b: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> a + b;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test container_level_variables.zig</kbd></span>
<span class=line>1/1 test.container level variables... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Container level variables may be declared inside a <a href=#struct>struct</a>, <a href=#union>union</a>, or <a href=#enum>enum</a>: </p> <figure><figcaption class=zig-cap><cite class=file>namespaced_container_level_variable.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"namespaced container level variable"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(foo() == <span class=tok-number>1235</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(foo() == <span class=tok-number>1236</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> S = <span class=tok-kw>struct</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>() <span class=tok-type>i32</span> {</span>
<span class=line>    S.x += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>return</span> S.x;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test namespaced_container_level_variable.zig</kbd></span>
<span class=line>1/1 test.namespaced container level variable... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Static%20Local%20Variables class=dashAnchor></a><h3 id=Static-Local-Variables>Static Local Variables</h3> <p> It is also possible to have local variables with static lifetime by using containers inside functions. </p> <figure><figcaption class=zig-cap><cite class=file>static_local_variable.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"static local variable"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(foo() == <span class=tok-number>1235</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(foo() == <span class=tok-number>1236</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>() <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>const</span> S = <span class=tok-kw>struct</span> {</span>
<span class=line>        <span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line>    };</span>
<span class=line>    S.x += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>return</span> S.x;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test static_local_variable.zig</kbd></span>
<span class=line>1/1 test.static local variable... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> The <code><span class=line><span class=tok-kw>extern</span></span></code> keyword or <a href=#extern>@extern</a> builtin function can be used to link against a variable that is exported from another object. The <code><span class=line><span class=tok-kw>export</span></span></code> keyword or <a href=#export>@export</a> builtin function can be used to make a variable available to other objects at link time. In both cases, the type of the variable must be C ABI compatible. </p> <p>See also:</p><ul> <li><a href=#Exporting-a-C-Library>Exporting a C Library</a></li> </ul> <a name=//apple_ref/cpp/Guide/Thread%20Local%20Variables class=dashAnchor></a><h3 id=Thread-Local-Variables>Thread Local Variables</h3> <p>A variable may be specified to be a thread-local variable using the <code><span class=line><span class=tok-kw>threadlocal</span></span></code> keyword:</p> <figure><figcaption class=zig-cap><cite class=file>tls.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> assert = std.debug.assert;</span>
<span class=line></span>
<span class=line><span class=tok-kw>threadlocal</span> <span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"thread local storage"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> thread1 = <span class=tok-kw>try</span> std.Thread.spawn(.{}, testTls, .{});</span>
<span class=line>    <span class=tok-kw>const</span> thread2 = <span class=tok-kw>try</span> std.Thread.spawn(.{}, testTls, .{});</span>
<span class=line>    testTls();</span>
<span class=line>    thread1.join();</span>
<span class=line>    thread2.join();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>testTls</span>() <span class=tok-type>void</span> {</span>
<span class=line>    assert(x == <span class=tok-number>1234</span>);</span>
<span class=line>    x += <span class=tok-number>1</span>;</span>
<span class=line>    assert(x == <span class=tok-number>1235</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test tls.zig</kbd></span>
<span class=line>1/1 test.thread local storage... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> For <a href=#Single-Threaded-Builds>Single Threaded Builds</a>, all thread local variables are treated as regular <a href=#Container-Level-Variables>Container Level Variables</a>. </p> <p> Thread local variables may not be <code><span class=line><span class=tok-kw>const</span></span></code>. </p> <a name=//apple_ref/cpp/Guide/Local%20Variables class=dashAnchor></a><h3 id=Local-Variables>Local Variables</h3> <p> Local variables occur inside <a href=#Functions>Functions</a>, <a href=#comptime>comptime</a> blocks, and <a href=#cImport>@cImport</a> blocks. </p> <p> When a local variable is <code><span class=line><span class=tok-kw>const</span></span></code>, it means that after initialization, the variable's value will not change. If the initialization value of a <code><span class=line><span class=tok-kw>const</span></span></code> variable is <a href=#comptime>comptime</a>-known, then the variable is also <code><span class=line><span class=tok-kw>comptime</span></span></code>-known. </p> <p> A local variable may be qualified with the <code><span class=line><span class=tok-kw>comptime</span></span></code> keyword. This causes the variable's value to be <code><span class=line><span class=tok-kw>comptime</span></span></code>-known, and all loads and stores of the variable to happen during semantic analysis of the program, rather than at runtime. All variables declared in a <code><span class=line><span class=tok-kw>comptime</span></span></code> expression are implicitly <code><span class=line><span class=tok-kw>comptime</span></span></code> variables. </p> <figure><figcaption class=zig-cap><cite class=file>comptime_vars.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"comptime vars"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>var</span> y: <span class=tok-type>i32</span> = <span class=tok-number>1</span>;</span>
<span class=line></span>
<span class=line>    x += <span class=tok-number>1</span>;</span>
<span class=line>    y += <span class=tok-number>1</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(x == <span class=tok-number>2</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(y == <span class=tok-number>2</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>if</span> (y != <span class=tok-number>2</span>) {</span>
<span class=line>        <span class=tok-comment>// This compile error never triggers because y is a comptime variable,</span></span>
<span class=line>        <span class=tok-comment>// and so `y != 2` is a comptime value, and this if is statically evaluated.</span></span>
<span class=line>        <span class=tok-builtin>@compileError</span>(<span class=tok-str>"wrong y value"</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test comptime_vars.zig</kbd></span>
<span class=line>1/1 test.comptime vars... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Integers class=dashAnchor></a><h2 id=Integers>Integers</h2> <a name=//apple_ref/cpp/Guide/Integer%20Literals class=dashAnchor></a><h3 id=Integer-Literals>Integer Literals</h3> <figure><figcaption class=zig-cap><cite class=file>integer_literals.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> decimal_int = <span class=tok-number>98222</span>;</span>
<span class=line><span class=tok-kw>const</span> hex_int = <span class=tok-number>0xff</span>;</span>
<span class=line><span class=tok-kw>const</span> another_hex_int = <span class=tok-number>0xFF</span>;</span>
<span class=line><span class=tok-kw>const</span> octal_int = <span class=tok-number>0o755</span>;</span>
<span class=line><span class=tok-kw>const</span> binary_int = <span class=tok-number>0b11110000</span>;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// underscores may be placed between two digits as a visual separator</span></span>
<span class=line><span class=tok-kw>const</span> one_billion = <span class=tok-number>1_000_000_000</span>;</span>
<span class=line><span class=tok-kw>const</span> binary_mask = <span class=tok-number>0b1_1111_1111</span>;</span>
<span class=line><span class=tok-kw>const</span> permissions = <span class=tok-number>0o7_5_5</span>;</span>
<span class=line><span class=tok-kw>const</span> big_address = <span class=tok-number>0xFF80_0000_0000_0000</span>;</span></code></pre></figure> <a name=//apple_ref/cpp/Guide/Runtime%20Integer%20Values class=dashAnchor></a><h3 id=Runtime-Integer-Values>Runtime Integer Values</h3> <p> Integer literals have no size limitation, and if any undefined behavior occurs, the compiler catches it. </p> <p> However, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to undefined behavior. </p> <figure><figcaption class=zig-cap><cite class=file>runtime_vs_comptime.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>divide</span>(a: <span class=tok-type>i32</span>, b: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> a / b;</span>
<span class=line>}</span></code></pre></figure> <p> In this function, values <code><span class=line>a</span></code> and <code><span class=line>b</span></code> are known only at runtime, and thus this division operation is vulnerable to both <a href=#Integer-Overflow>Integer Overflow</a> and <a href=#Division-by-Zero>Division by Zero</a>. </p> <p> Operators such as <code><span class=line>+</span></code> and <code><span class=line>-</span></code> cause undefined behavior on integer overflow. Alternative operators are provided for wrapping and saturating arithmetic on all targets. <code><span class=line>+%</span></code> and <code><span class=line>-%</span></code> perform wrapping arithmetic while <code><span class=line>+|</span></code> and <code><span class=line>-|</span></code> perform saturating arithmetic. </p> <p> Zig supports arbitrary bit-width integers, referenced by using an identifier of <code>i</code> or <code>u</code> followed by digits. For example, the identifier <code><span class=line><span class=tok-type>i7</span></span></code> refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is <code><span class=line><span class=tok-number>65535</span></span></code>. For signed integer types, Zig uses a <a href="https://en.wikipedia.org/wiki/Two's_complement">two's complement</a> representation. </p> <p>See also:</p><ul> <li><a href=#Wrapping-Operations>Wrapping Operations</a></li> </ul> <a name=//apple_ref/cpp/Guide/Floats class=dashAnchor></a><h2 id=Floats>Floats</h2> <p>Zig has the following floating point types:</p> <ul> <li><code><span class=line><span class=tok-type>f16</span></span></code> - IEEE-754-2008 binary16</li> <li><code><span class=line><span class=tok-type>f32</span></span></code> - IEEE-754-2008 binary32</li> <li><code><span class=line><span class=tok-type>f64</span></span></code> - IEEE-754-2008 binary64</li> <li><code><span class=line><span class=tok-type>f80</span></span></code> - IEEE-754-2008 80-bit extended precision</li> <li><code><span class=line><span class=tok-type>f128</span></span></code> - IEEE-754-2008 binary128</li> <li><code><span class=line><span class=tok-type>c_longdouble</span></span></code> - matches <code class=c>long double</code> for the target C ABI</li> </ul> <a name=//apple_ref/cpp/Guide/Float%20Literals class=dashAnchor></a><h3 id=Float-Literals>Float Literals</h3> <p> Float literals have type <code><span class=line><span class=tok-type>comptime_float</span></span></code> which is guaranteed to have the same precision and operations of the largest other floating point type, which is <code><span class=line><span class=tok-type>f128</span></span></code>. </p> <p> Float literals <a href=#Type-Coercion>coerce</a> to any floating point type, and to any <a href=#Integers>integer</a> type when there is no fractional component. </p> <figure><figcaption class=zig-cap><cite class=file>float_literals.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> floating_point = <span class=tok-number>123.0E+77</span>;</span>
<span class=line><span class=tok-kw>const</span> another_float = <span class=tok-number>123.0</span>;</span>
<span class=line><span class=tok-kw>const</span> yet_another = <span class=tok-number>123.0e+77</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> hex_floating_point = <span class=tok-number>0x103.70p-5</span>;</span>
<span class=line><span class=tok-kw>const</span> another_hex_float = <span class=tok-number>0x103.70</span>;</span>
<span class=line><span class=tok-kw>const</span> yet_another_hex_float = <span class=tok-number>0x103.70P-5</span>;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// underscores may be placed between two digits as a visual separator</span></span>
<span class=line><span class=tok-kw>const</span> lightspeed = <span class=tok-number>299_792_458.000_000</span>;</span>
<span class=line><span class=tok-kw>const</span> nanosecond = <span class=tok-number>0.000_000_001</span>;</span>
<span class=line><span class=tok-kw>const</span> more_hex = <span class=tok-number>0x1234_5678.9ABC_CDEFp-10</span>;</span></code></pre></figure> <p> There is no syntax for NaN, infinity, or negative infinity. For these special values, one must use the standard library: </p> <figure><figcaption class=zig-cap><cite class=file>float_special_values.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> inf = std.math.inf(<span class=tok-type>f32</span>);</span>
<span class=line><span class=tok-kw>const</span> negative_inf = -std.math.inf(<span class=tok-type>f64</span>);</span>
<span class=line><span class=tok-kw>const</span> nan = std.math.nan(<span class=tok-type>f128</span>);</span></code></pre></figure> <a name=//apple_ref/cpp/Guide/Floating%20Point%20Operations class=dashAnchor></a><h3 id=Floating-Point-Operations>Floating Point Operations</h3> <p>By default floating point operations use <code><span class=line>Strict</span></code> mode, but you can switch to <code><span class=line>Optimized</span></code> mode on a per-block basis:</p> <figure><figcaption class=zig-cap><cite class=file>foo.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> big = <span class=tok-builtin>@as</span>(<span class=tok-type>f64</span>, <span class=tok-number>1</span> &lt;&lt; <span class=tok-number>40</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>foo_strict</span>(x: <span class=tok-type>f64</span>) <span class=tok-type>f64</span> {</span>
<span class=line>    <span class=tok-kw>return</span> x + big - big;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>foo_optimized</span>(x: <span class=tok-type>f64</span>) <span class=tok-type>f64</span> {</span>
<span class=line>    <span class=tok-builtin>@setFloatMode</span>(.Optimized);</span>
<span class=line>    <span class=tok-kw>return</span> x + big - big;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-obj foo.zig -O ReleaseFast</kbd></span>
</samp></pre></figure> <p>For this test we have to separate code into two object files - otherwise the optimizer figures out all the values at compile-time, which operates in strict mode.</p> <figure><figcaption class=zig-cap><cite class=file>float_mode.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>extern</span> <span class=tok-kw>fn</span> <span class=tok-fn>foo_strict</span>(x: <span class=tok-type>f64</span>) <span class=tok-type>f64</span>;</span>
<span class=line><span class=tok-kw>extern</span> <span class=tok-kw>fn</span> <span class=tok-fn>foo_optimized</span>(x: <span class=tok-type>f64</span>) <span class=tok-type>f64</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x = <span class=tok-number>0.001</span>;</span>
<span class=line>    print(<span class=tok-str>"optimized = {}\n"</span>, .{foo_optimized(x)});</span>
<span class=line>    print(<span class=tok-str>"strict = {}\n"</span>, .{foo_strict(x)});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe float_mode.zig foo.o</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./float_mode</kbd></span>
<span class=line>optimized = 1.0e-03</span>
<span class=line>strict = 9.765625e-04</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#setFloatMode>@setFloatMode</a></li> <li><a href=#Division-by-Zero>Division by Zero</a></li> </ul> <a name=//apple_ref/cpp/Guide/Operators class=dashAnchor></a><h2 id=Operators>Operators</h2> <p> There is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else. </p> <a name=//apple_ref/cpp/Guide/Table%20of%20Operators class=dashAnchor></a><h3 id=Table-of-Operators>Table of Operators</h3> <div class=table-wrapper> <table> <caption>Table of Operators</caption> <thead> <tr> <th scope=col>Syntax</th> <th scope=col>Relevant Types</th> <th scope=col>Description</th> <th scope=col>Example</th> </tr> </thead> <tbody> <tr> <th scope=row><pre><code><span class=line>a + b</span>
<span class=line>a += b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> </ul> </td> <td>Addition. <ul> <li>Can cause <a href=#Default-Operations>overflow</a> for integers.</li> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> <li>See also <a href=#addWithOverflow>@addWithOverflow</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-number>2</span> + <span class=tok-number>5</span> == <span class=tok-number>7</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a +% b</span>
<span class=line>a +%= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Wrapping Addition. <ul> <li>Guaranteed to have twos-complement wrapping behavior.</li> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> <li>See also <a href=#addWithOverflow>@addWithOverflow</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>u32</span>, std.math.maxInt(<span class=tok-type>u32</span>)) +% <span class=tok-number>1</span> == <span class=tok-number>0</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a +| b</span>
<span class=line>a +|= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Saturating Addition. <ul> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>u32</span>, std.math.maxInt(<span class=tok-type>u32</span>)) +| <span class=tok-number>1</span> == <span class=tok-builtin>@as</span>(<span class=tok-type>u32</span>, std.math.maxInt(<span class=tok-type>u32</span>))</span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a - b</span>
<span class=line>a -= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> </ul> </td> <td>Subtraction. <ul> <li>Can cause <a href=#Default-Operations>overflow</a> for integers.</li> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> <li>See also <a href=#subWithOverflow>@subWithOverflow</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-number>2</span> - <span class=tok-number>5</span> == -<span class=tok-number>3</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a -% b</span>
<span class=line>a -%= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Wrapping Subtraction. <ul> <li>Guaranteed to have twos-complement wrapping behavior.</li> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> <li>See also <a href=#subWithOverflow>@subWithOverflow</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>u32</span>, <span class=tok-number>0</span>) -% <span class=tok-number>1</span> == std.math.maxInt(<span class=tok-type>u32</span>)</span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a -| b</span>
<span class=line>a -|= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Saturating Subtraction. <ul> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>u32</span>, <span class=tok-number>0</span>) -| <span class=tok-number>1</span> == <span class=tok-number>0</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>-a</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> </ul> </td> <td> Negation. <ul> <li>Can cause <a href=#Default-Operations>overflow</a> for integers.</li> </ul> </td> <td> <pre><code><span class=line>-<span class=tok-number>1</span> == <span class=tok-number>0</span> - <span class=tok-number>1</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>-%a</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td> Wrapping Negation. <ul> <li>Guaranteed to have twos-complement wrapping behavior.</li> </ul> </td> <td> <pre><code><span class=line>-%<span class=tok-builtin>@as</span>(<span class=tok-type>i32</span>, std.math.minInt(<span class=tok-type>i32</span>)) == std.math.minInt(<span class=tok-type>i32</span>)</span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a * b</span>
<span class=line>a *= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> </ul> </td> <td>Multiplication. <ul> <li>Can cause <a href=#Default-Operations>overflow</a> for integers.</li> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> <li>See also <a href=#mulWithOverflow>@mulWithOverflow</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-number>2</span> * <span class=tok-number>5</span> == <span class=tok-number>10</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a *% b</span>
<span class=line>a *%= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Wrapping Multiplication. <ul> <li>Guaranteed to have twos-complement wrapping behavior.</li> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> <li>See also <a href=#mulWithOverflow>@mulWithOverflow</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>u8</span>, <span class=tok-number>200</span>) *% <span class=tok-number>2</span> == <span class=tok-number>144</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a *| b</span>
<span class=line>a *|= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Saturating Multiplication. <ul> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>u8</span>, <span class=tok-number>200</span>) *| <span class=tok-number>2</span> == <span class=tok-number>255</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a / b</span>
<span class=line>a /= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> </ul> </td> <td>Division. <ul> <li>Can cause <a href=#Default-Operations>overflow</a> for integers.</li> <li>Can cause <a href=#Division-by-Zero>Division by Zero</a> for integers.</li> <li>Can cause <a href=#Division-by-Zero>Division by Zero</a> for floats in <a href=#Floating-Point-Operations>FloatMode.Optimized Mode</a>.</li> <li>Signed integer operands must be comptime-known and positive. In other cases, use <a href=#divTrunc>@divTrunc</a>, <a href=#divFloor>@divFloor</a>, or <a href=#divExact>@divExact</a> instead. </li> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-number>10</span> / <span class=tok-number>5</span> == <span class=tok-number>2</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a % b</span>
<span class=line>a %= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> </ul> </td> <td>Remainder Division. <ul> <li>Can cause <a href=#Division-by-Zero>Division by Zero</a> for integers.</li> <li>Can cause <a href=#Division-by-Zero>Division by Zero</a> for floats in <a href=#Floating-Point-Operations>FloatMode.Optimized Mode</a>.</li> <li>Signed or floating-point operands must be comptime-known and positive. In other cases, use <a href=#rem>@rem</a> or <a href=#mod>@mod</a> instead. </li> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-number>10</span> % <span class=tok-number>3</span> == <span class=tok-number>1</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a &lt;&lt; b</span>
<span class=line>a &lt;&lt;= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Bit Shift Left. <ul> <li><code><span class=line>b</span></code> must be <a href=#comptime>comptime-known</a> or have a type with log2 number of bits as <code><span class=line>a</span></code>.</li> <li>See also <a href=#shlExact>@shlExact</a>.</li> <li>See also <a href=#shlWithOverflow>@shlWithOverflow</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-number>1</span> &lt;&lt; <span class=tok-number>8</span> == <span class=tok-number>256</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a &lt;&lt;| b</span>
<span class=line>a &lt;&lt;|= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Saturating Bit Shift Left. <ul> <li>See also <a href=#shlExact>@shlExact</a>.</li> <li>See also <a href=#shlWithOverflow>@shlWithOverflow</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>u8</span>, <span class=tok-number>1</span>) &lt;&lt;| <span class=tok-number>8</span> == <span class=tok-number>255</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a &gt;&gt; b</span>
<span class=line>a &gt;&gt;= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Bit Shift Right. <ul> <li><code><span class=line>b</span></code> must be <a href=#comptime>comptime-known</a> or have a type with log2 number of bits as <code><span class=line>a</span></code>.</li> <li>See also <a href=#shrExact>@shrExact</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-number>10</span> &gt;&gt; <span class=tok-number>1</span> == <span class=tok-number>5</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a &amp; b</span>
<span class=line>a &amp;= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Bitwise AND. <ul> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-number>0b011</span> &amp; <span class=tok-number>0b101</span> == <span class=tok-number>0b001</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a | b</span>
<span class=line>a |= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Bitwise OR. <ul> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-number>0b010</span> | <span class=tok-number>0b100</span> == <span class=tok-number>0b110</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a ^ b</span>
<span class=line>a ^= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td>Bitwise XOR. <ul> <li>Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-number>0b011</span> ^ <span class=tok-number>0b101</span> == <span class=tok-number>0b110</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>~a</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> </ul> </td> <td> Bitwise NOT. </td> <td> <pre><code><span class=line>~<span class=tok-builtin>@as</span>(<span class=tok-type>u8</span>, <span class=tok-number>0b10101111</span>) == <span class=tok-number>0b01010000</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a <span class=tok-kw>orelse</span> b</span></code></pre></th> <td> <ul> <li><a href=#Optionals>Optionals</a></li> </ul> </td> <td>If <code><span class=line>a</span></code> is <code><span class=line><span class=tok-null>null</span></span></code>, returns <code><span class=line>b</span></code> ("default value"), otherwise returns the unwrapped value of <code><span class=line>a</span></code>. Note that <code><span class=line>b</span></code> may be a value of type <a href=#noreturn>noreturn</a>. </td> <td> <pre><code><span class=line><span class=tok-kw>const</span> value: ?<span class=tok-type>u32</span> = <span class=tok-null>null</span>;</span>
<span class=line><span class=tok-kw>const</span> unwrapped = value <span class=tok-kw>orelse</span> <span class=tok-number>1234</span>;</span>
<span class=line>unwrapped == <span class=tok-number>1234</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a.?</span></code></pre></th> <td> <ul> <li><a href=#Optionals>Optionals</a></li> </ul> </td> <td> Equivalent to: <pre><code><span class=line>a <span class=tok-kw>orelse</span> <span class=tok-kw>unreachable</span></span></code></pre> </td> <td> <pre><code><span class=line><span class=tok-kw>const</span> value: ?<span class=tok-type>u32</span> = <span class=tok-number>5678</span>;</span>
<span class=line>value.? == <span class=tok-number>5678</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a <span class=tok-kw>catch</span> b</span>
<span class=line>a <span class=tok-kw>catch</span> |err| b</span></code></pre></th> <td> <ul> <li><a href=#Errors>Error Unions</a></li> </ul> </td> <td>If <code><span class=line>a</span></code> is an <code><span class=line><span class=tok-kw>error</span></span></code>, returns <code><span class=line>b</span></code> ("default value"), otherwise returns the unwrapped value of <code><span class=line>a</span></code>. Note that <code><span class=line>b</span></code> may be a value of type <a href=#noreturn>noreturn</a>. <code><span class=line>err</span></code> is the <code><span class=line><span class=tok-kw>error</span></span></code> and is in scope of the expression <code><span class=line>b</span></code>. </td> <td> <pre><code><span class=line><span class=tok-kw>const</span> value: <span class=tok-type>anyerror</span>!<span class=tok-type>u32</span> = <span class=tok-kw>error</span>.Broken;</span>
<span class=line><span class=tok-kw>const</span> unwrapped = value <span class=tok-kw>catch</span> <span class=tok-number>1234</span>;</span>
<span class=line>unwrapped == <span class=tok-number>1234</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a <span class=tok-kw>and</span> b</span></code></pre></th> <td> <ul> <li><a href=#Primitive-Types>bool</a></li> </ul> </td> <td> If <code><span class=line>a</span></code> is <code><span class=line><span class=tok-null>false</span></span></code>, returns <code><span class=line><span class=tok-null>false</span></span></code> without evaluating <code><span class=line>b</span></code>. Otherwise, returns <code><span class=line>b</span></code>. </td> <td> <pre><code><span class=line>(<span class=tok-null>false</span> <span class=tok-kw>and</span> <span class=tok-null>true</span>) == <span class=tok-null>false</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a <span class=tok-kw>or</span> b</span></code></pre></th> <td> <ul> <li><a href=#Primitive-Types>bool</a></li> </ul> </td> <td> If <code><span class=line>a</span></code> is <code><span class=line><span class=tok-null>true</span></span></code>, returns <code><span class=line><span class=tok-null>true</span></span></code> without evaluating <code><span class=line>b</span></code>. Otherwise, returns <code><span class=line>b</span></code>. </td> <td> <pre><code><span class=line>(<span class=tok-null>false</span> <span class=tok-kw>or</span> <span class=tok-null>true</span>) == <span class=tok-null>true</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>!a</span></code></pre></th> <td> <ul> <li><a href=#Primitive-Types>bool</a></li> </ul> </td> <td> Boolean NOT. </td> <td> <pre><code><span class=line>!<span class=tok-null>false</span> == <span class=tok-null>true</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a == b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> <li><a href=#Primitive-Types>bool</a></li> <li><a href=#Primitive-Types>type</a></li> </ul> </td> <td> Returns <code><span class=line><span class=tok-null>true</span></span></code> if a and b are equal, otherwise returns <code><span class=line><span class=tok-null>false</span></span></code>. Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands. </td> <td> <pre><code><span class=line>(<span class=tok-number>1</span> == <span class=tok-number>1</span>) == <span class=tok-null>true</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a == <span class=tok-null>null</span></span></code></pre></th> <td> <ul> <li><a href=#Optionals>Optionals</a></li> </ul> </td> <td> Returns <code><span class=line><span class=tok-null>true</span></span></code> if a is <code><span class=line><span class=tok-null>null</span></span></code>, otherwise returns <code><span class=line><span class=tok-null>false</span></span></code>. </td> <td> <pre><code><span class=line><span class=tok-kw>const</span> value: ?<span class=tok-type>u32</span> = <span class=tok-null>null</span>;</span>
<span class=line>value == <span class=tok-null>null</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a != b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> <li><a href=#Primitive-Types>bool</a></li> <li><a href=#Primitive-Types>type</a></li> </ul> </td> <td> Returns <code><span class=line><span class=tok-null>false</span></span></code> if a and b are equal, otherwise returns <code><span class=line><span class=tok-null>true</span></span></code>. Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands. </td> <td> <pre><code><span class=line>(<span class=tok-number>1</span> != <span class=tok-number>1</span>) == <span class=tok-null>false</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a &gt; b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> </ul> </td> <td> Returns <code><span class=line><span class=tok-null>true</span></span></code> if a is greater than b, otherwise returns <code><span class=line><span class=tok-null>false</span></span></code>. Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands. </td> <td> <pre><code><span class=line>(<span class=tok-number>2</span> &gt; <span class=tok-number>1</span>) == <span class=tok-null>true</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a &gt;= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> </ul> </td> <td> Returns <code><span class=line><span class=tok-null>true</span></span></code> if a is greater than or equal to b, otherwise returns <code><span class=line><span class=tok-null>false</span></span></code>. Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands. </td> <td> <pre><code><span class=line>(<span class=tok-number>2</span> &gt;= <span class=tok-number>1</span>) == <span class=tok-null>true</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a &lt; b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> </ul> </td> <td> Returns <code><span class=line><span class=tok-null>true</span></span></code> if a is less than b, otherwise returns <code><span class=line><span class=tok-null>false</span></span></code>. Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands. </td> <td> <pre><code><span class=line>(<span class=tok-number>1</span> &lt; <span class=tok-number>2</span>) == <span class=tok-null>true</span></span></code>&gt;</pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a &lt;= b</span></code></pre></th> <td> <ul> <li><a href=#Integers>Integers</a></li> <li><a href=#Floats>Floats</a></li> </ul> </td> <td> Returns <code><span class=line><span class=tok-null>true</span></span></code> if a is less than or equal to b, otherwise returns <code><span class=line><span class=tok-null>false</span></span></code>. Invokes <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the operands. </td> <td> <pre><code><span class=line>(<span class=tok-number>1</span> &lt;= <span class=tok-number>2</span>) == <span class=tok-null>true</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a ++ b</span></code></pre></th> <td> <ul> <li><a href=#Arrays>Arrays</a></li> </ul> </td> <td> Array concatenation. <ul> <li>Only available when <code><span class=line>a</span></code> and <code><span class=line>b</span></code> are <a href=#comptime>compile-time known</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-kw>const</span> mem = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).mem;</span>
<span class=line><span class=tok-kw>const</span> array1 = [_]<span class=tok-type>u32</span>{<span class=tok-number>1</span>,<span class=tok-number>2</span>};</span>
<span class=line><span class=tok-kw>const</span> array2 = [_]<span class=tok-type>u32</span>{<span class=tok-number>3</span>,<span class=tok-number>4</span>};</span>
<span class=line><span class=tok-kw>const</span> together = array1 ++ array2;</span>
<span class=line>mem.eql(<span class=tok-type>u32</span>, &amp;together, &amp;[_]<span class=tok-type>u32</span>{<span class=tok-number>1</span>,<span class=tok-number>2</span>,<span class=tok-number>3</span>,<span class=tok-number>4</span>})</span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a ** b</span></code></pre></th> <td> <ul> <li><a href=#Arrays>Arrays</a></li> </ul> </td> <td> Array multiplication. <ul> <li>Only available when <code><span class=line>a</span></code> and <code><span class=line>b</span></code> are <a href=#comptime>compile-time known</a>.</li> </ul> </td> <td> <pre><code><span class=line><span class=tok-kw>const</span> mem = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).mem;</span>
<span class=line><span class=tok-kw>const</span> pattern = <span class=tok-str>"ab"</span> ** <span class=tok-number>3</span>;</span>
<span class=line>mem.eql(<span class=tok-type>u8</span>, pattern, <span class=tok-str>"ababab"</span>)</span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a.*</span></code></pre></th> <td> <ul> <li><a href=#Pointers>Pointers</a></li> </ul> </td> <td> Pointer dereference. </td> <td> <pre><code><span class=line><span class=tok-kw>const</span> x: <span class=tok-type>u32</span> = <span class=tok-number>1234</span>;</span>
<span class=line><span class=tok-kw>const</span> ptr = &amp;x;</span>
<span class=line>ptr.* == <span class=tok-number>1234</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>&amp;a</span></code></pre></th> <td> All types </td> <td> Address of. </td> <td> <pre><code><span class=line><span class=tok-kw>const</span> x: <span class=tok-type>u32</span> = <span class=tok-number>1234</span>;</span>
<span class=line><span class=tok-kw>const</span> ptr = &amp;x;</span>
<span class=line>ptr.* == <span class=tok-number>1234</span></span></code></pre> </td> </tr> <tr> <th scope=row><pre><code><span class=line>a || b</span></code></pre></th> <td> <ul> <li><a href=#Error-Set-Type>Error Set Type</a></li> </ul> </td> <td> <a href=#Merging-Error-Sets>Merging Error Sets</a> </td> <td> <pre><code><span class=line><span class=tok-kw>const</span> A = <span class=tok-kw>error</span>{One};</span>
<span class=line><span class=tok-kw>const</span> B = <span class=tok-kw>error</span>{Two};</span>
<span class=line>(A || B) == <span class=tok-kw>error</span>{One, Two}</span></code></pre> </td> </tr> </tbody> </table> </div> <a name=//apple_ref/cpp/Guide/Precedence class=dashAnchor></a><h3 id=Precedence>Precedence</h3> <pre><code><span class=line>x() x[] x.y x.* x.?</span>
<span class=line>a!b</span>
<span class=line>x{}</span>
<span class=line>!x -x -%x ~x &amp;x ?x</span>
<span class=line>* / % ** *% *| ||</span>
<span class=line>+ - ++ +% -% +| -|</span>
<span class=line>&lt;&lt; &gt;&gt; &lt;&lt;|</span>
<span class=line>&amp; ^ | <span class=tok-kw>orelse</span> <span class=tok-kw>catch</span></span>
<span class=line>== != &lt; &gt; &lt;= &gt;=</span>
<span class=line><span class=tok-kw>and</span></span>
<span class=line><span class=tok-kw>or</span></span>
<span class=line>= *= *%= *|= /= %= += +%= +|= -= -%= -|= &lt;&lt;= &lt;&lt;|= &gt;&gt;= &amp;= ^= |=</span></code></pre> <a name=//apple_ref/cpp/Guide/Arrays class=dashAnchor></a><h2 id=Arrays>Arrays</h2> <figure><figcaption class=zig-cap><cite class=file>arrays.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line><span class=tok-kw>const</span> assert = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.assert;</span>
<span class=line><span class=tok-kw>const</span> mem = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).mem;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// array literal</span></span>
<span class=line><span class=tok-kw>const</span> message = [_]<span class=tok-type>u8</span>{ <span class=tok-str>'h'</span>, <span class=tok-str>'e'</span>, <span class=tok-str>'l'</span>, <span class=tok-str>'l'</span>, <span class=tok-str>'o'</span> };</span>
<span class=line></span>
<span class=line><span class=tok-comment>// get the size of an array</span></span>
<span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    assert(message.len == <span class=tok-number>5</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// A string literal is a single-item pointer to an array literal.</span></span>
<span class=line><span class=tok-kw>const</span> same_message = <span class=tok-str>"hello"</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    assert(mem.eql(<span class=tok-type>u8</span>, &amp;message, same_message));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"iterate over an array"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> sum: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>for</span> (message) |byte| {</span>
<span class=line>        sum += byte;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(sum == <span class=tok-str>'h'</span> + <span class=tok-str>'e'</span> + <span class=tok-str>'l'</span> * <span class=tok-number>2</span> + <span class=tok-str>'o'</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// modifiable array</span></span>
<span class=line><span class=tok-kw>var</span> some_integers: [<span class=tok-number>100</span>]<span class=tok-type>i32</span> = <span class=tok-null>undefined</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"modify an array"</span> {</span>
<span class=line>    <span class=tok-kw>for</span> (some_integers) |*item, i| {</span>
<span class=line>        item.* = <span class=tok-builtin>@intCast</span>(<span class=tok-type>i32</span>, i);</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(some_integers[<span class=tok-number>10</span>] == <span class=tok-number>10</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(some_integers[<span class=tok-number>99</span>] == <span class=tok-number>99</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// array concatenation works if the values are known</span></span>
<span class=line><span class=tok-comment>// at compile time</span></span>
<span class=line><span class=tok-kw>const</span> part_one = [_]<span class=tok-type>i32</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span> };</span>
<span class=line><span class=tok-kw>const</span> part_two = [_]<span class=tok-type>i32</span>{ <span class=tok-number>5</span>, <span class=tok-number>6</span>, <span class=tok-number>7</span>, <span class=tok-number>8</span> };</span>
<span class=line><span class=tok-kw>const</span> all_of_it = part_one ++ part_two;</span>
<span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    assert(mem.eql(<span class=tok-type>i32</span>, &amp;all_of_it, &amp;[_]<span class=tok-type>i32</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span>, <span class=tok-number>5</span>, <span class=tok-number>6</span>, <span class=tok-number>7</span>, <span class=tok-number>8</span> }));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// remember that string literals are arrays</span></span>
<span class=line><span class=tok-kw>const</span> hello = <span class=tok-str>"hello"</span>;</span>
<span class=line><span class=tok-kw>const</span> world = <span class=tok-str>"world"</span>;</span>
<span class=line><span class=tok-kw>const</span> hello_world = hello ++ <span class=tok-str>" "</span> ++ world;</span>
<span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    assert(mem.eql(<span class=tok-type>u8</span>, hello_world, <span class=tok-str>"hello world"</span>));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// ** does repeating patterns</span></span>
<span class=line><span class=tok-kw>const</span> pattern = <span class=tok-str>"ab"</span> ** <span class=tok-number>3</span>;</span>
<span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    assert(mem.eql(<span class=tok-type>u8</span>, pattern, <span class=tok-str>"ababab"</span>));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// initialize an array to zero</span></span>
<span class=line><span class=tok-kw>const</span> all_zero = [_]<span class=tok-type>u16</span>{<span class=tok-number>0</span>} ** <span class=tok-number>10</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    assert(all_zero.len == <span class=tok-number>10</span>);</span>
<span class=line>    assert(all_zero[<span class=tok-number>5</span>] == <span class=tok-number>0</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// use compile-time code to initialize an array</span></span>
<span class=line><span class=tok-kw>var</span> fancy_array = init: {</span>
<span class=line>    <span class=tok-kw>var</span> initial_value: [<span class=tok-number>10</span>]Point = <span class=tok-null>undefined</span>;</span>
<span class=line>    <span class=tok-kw>for</span> (initial_value) |*pt, i| {</span>
<span class=line>        pt.* = Point{</span>
<span class=line>            .x = <span class=tok-builtin>@intCast</span>(<span class=tok-type>i32</span>, i),</span>
<span class=line>            .y = <span class=tok-builtin>@intCast</span>(<span class=tok-type>i32</span>, i) * <span class=tok-number>2</span>,</span>
<span class=line>        };</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>break</span> :init initial_value;</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> Point = <span class=tok-kw>struct</span> {</span>
<span class=line>    x: <span class=tok-type>i32</span>,</span>
<span class=line>    y: <span class=tok-type>i32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"compile-time array initialization"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(fancy_array[<span class=tok-number>4</span>].x == <span class=tok-number>4</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(fancy_array[<span class=tok-number>4</span>].y == <span class=tok-number>8</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// call a function to initialize an array</span></span>
<span class=line><span class=tok-kw>var</span> more_points = [_]Point{makePoint(<span class=tok-number>3</span>)} ** <span class=tok-number>10</span>;</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>makePoint</span>(x: <span class=tok-type>i32</span>) Point {</span>
<span class=line>    <span class=tok-kw>return</span> Point{</span>
<span class=line>        .x = x,</span>
<span class=line>        .y = x * <span class=tok-number>2</span>,</span>
<span class=line>    };</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"array initialization with function calls"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(more_points[<span class=tok-number>4</span>].x == <span class=tok-number>3</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(more_points[<span class=tok-number>4</span>].y == <span class=tok-number>6</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(more_points.len == <span class=tok-number>10</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test arrays.zig</kbd></span>
<span class=line>1/4 test.iterate over an array... OK</span>
<span class=line>2/4 test.modify an array... OK</span>
<span class=line>3/4 test.compile-time array initialization... OK</span>
<span class=line>4/4 test.array initialization with function calls... OK</span>
<span class=line>All 4 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#for>for</a></li> <li><a href=#Slices>Slices</a></li> </ul> <a name=//apple_ref/cpp/Guide/Anonymous%20List%20Literals class=dashAnchor></a><h3 id=Anonymous-List-Literals>Anonymous List Literals</h3> <p>Similar to <a href=#Enum-Literals>Enum Literals</a> and <a href=#Anonymous-Struct-Literals>Anonymous Struct Literals</a> the type can be omitted from array literals:</p> <figure><figcaption class=zig-cap><cite class=file>anon_list.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"anonymous list literal syntax"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> array: [<span class=tok-number>4</span>]<span class=tok-type>u8</span> = .{<span class=tok-number>11</span>, <span class=tok-number>22</span>, <span class=tok-number>33</span>, <span class=tok-number>44</span>};</span>
<span class=line>    <span class=tok-kw>try</span> expect(array[<span class=tok-number>0</span>] == <span class=tok-number>11</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(array[<span class=tok-number>1</span>] == <span class=tok-number>22</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(array[<span class=tok-number>2</span>] == <span class=tok-number>33</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(array[<span class=tok-number>3</span>] == <span class=tok-number>44</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test anon_list.zig</kbd></span>
<span class=line>1/1 test.anonymous list literal syntax... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> If there is no type in the result location then an anonymous list literal actually turns into a <a href=#struct>struct</a> with numbered field names: </p> <figure><figcaption class=zig-cap><cite class=file>infer_list_literal.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"fully anonymous list literal"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> dump(.{ <span class=tok-builtin>@as</span>(<span class=tok-type>u32</span>, <span class=tok-number>1234</span>), <span class=tok-builtin>@as</span>(<span class=tok-type>f64</span>, <span class=tok-number>12.34</span>), <span class=tok-null>true</span>, <span class=tok-str>"hi"</span>});</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>dump</span>(args: <span class=tok-kw>anytype</span>) !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(args.@"0" == <span class=tok-number>1234</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(args.@"1" == <span class=tok-number>12.34</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(args.@"2");</span>
<span class=line>    <span class=tok-kw>try</span> expect(args.@"3"[<span class=tok-number>0</span>] == <span class=tok-str>'h'</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(args.@"3"[<span class=tok-number>1</span>] == <span class=tok-str>'i'</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test infer_list_literal.zig</kbd></span>
<span class=line>1/1 test.fully anonymous list literal... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Multidimensional%20Arrays class=dashAnchor></a><h3 id=Multidimensional-Arrays>Multidimensional Arrays</h3> <p> Multidimensional arrays can be created by nesting arrays: </p> <figure><figcaption class=zig-cap><cite class=file>multidimensional.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> mat4x4 = [<span class=tok-number>4</span>][<span class=tok-number>4</span>]<span class=tok-type>f32</span>{</span>
<span class=line>    [_]<span class=tok-type>f32</span>{ <span class=tok-number>1.0</span>, <span class=tok-number>0.0</span>, <span class=tok-number>0.0</span>, <span class=tok-number>0.0</span> },</span>
<span class=line>    [_]<span class=tok-type>f32</span>{ <span class=tok-number>0.0</span>, <span class=tok-number>1.0</span>, <span class=tok-number>0.0</span>, <span class=tok-number>1.0</span> },</span>
<span class=line>    [_]<span class=tok-type>f32</span>{ <span class=tok-number>0.0</span>, <span class=tok-number>0.0</span>, <span class=tok-number>1.0</span>, <span class=tok-number>0.0</span> },</span>
<span class=line>    [_]<span class=tok-type>f32</span>{ <span class=tok-number>0.0</span>, <span class=tok-number>0.0</span>, <span class=tok-number>0.0</span>, <span class=tok-number>1.0</span> },</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"multidimensional arrays"</span> {</span>
<span class=line>    <span class=tok-comment>// Access the 2D array by indexing the outer array, and then the inner array.</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(mat4x4[<span class=tok-number>1</span>][<span class=tok-number>1</span>] == <span class=tok-number>1.0</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Here we iterate with for loops.</span></span>
<span class=line>    <span class=tok-kw>for</span> (mat4x4) |row, row_index| {</span>
<span class=line>        <span class=tok-kw>for</span> (row) |cell, column_index| {</span>
<span class=line>            <span class=tok-kw>if</span> (row_index == column_index) {</span>
<span class=line>                <span class=tok-kw>try</span> expect(cell == <span class=tok-number>1.0</span>);</span>
<span class=line>            }</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test multidimensional.zig</kbd></span>
<span class=line>1/1 test.multidimensional arrays... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Sentinel-Terminated%20Arrays class=dashAnchor></a><h3 id=Sentinel-Terminated-Arrays>Sentinel-Terminated Arrays</h3> <p> The syntax <code><span class=line>[N:x]T</span></code> describes an array which has a sentinel element of value <code><span class=line>x</span></code> at the index corresponding to <code><span class=line>len</span></code>. </p> <figure><figcaption class=zig-cap><cite class=file>null_terminated_array.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"null terminated array"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> array = [_:<span class=tok-number>0</span>]<span class=tok-type>u8</span> {<span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span>};</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(array) == [<span class=tok-number>4</span>:<span class=tok-number>0</span>]<span class=tok-type>u8</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(array.len == <span class=tok-number>4</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(array[<span class=tok-number>4</span>] == <span class=tok-number>0</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test null_terminated_array.zig</kbd></span>
<span class=line>1/1 test.null terminated array... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Sentinel-Terminated-Pointers>Sentinel-Terminated Pointers</a></li> <li><a href=#Sentinel-Terminated-Slices>Sentinel-Terminated Slices</a></li> </ul> <a name=//apple_ref/cpp/Guide/Vectors class=dashAnchor></a><h2 id=Vectors>Vectors</h2> <p> A vector is a group of booleans, <a href=#Integers>Integers</a>, <a href=#Floats>Floats</a>, or <a href=#Pointers>Pointers</a> which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function <a href=#Vector>@Vector</a>. </p> <p> Vectors support the same builtin operators as their underlying base types. These operations are performed element-wise, and return a vector of the same length as the input vectors. This includes: </p> <ul> <li>Arithmetic (<code><span class=line>+</span></code>, <code><span class=line>-</span></code>, <code><span class=line>/</span></code>, <code><span class=line>*</span></code>, <code><span class=line><span class=tok-builtin>@divFloor</span></span></code>, <code><span class=line><span class=tok-builtin>@sqrt</span></span></code>, <code><span class=line><span class=tok-builtin>@ceil</span></span></code>, <code><span class=line><span class=tok-builtin>@log</span></span></code>, etc.)</li> <li>Bitwise operators (<code><span class=line>&gt;&gt;</span></code>, <code><span class=line>&lt;&lt;</span></code>, <code><span class=line>&amp;</span></code>, <code><span class=line>|</span></code>, <code><span class=line>~</span></code>, etc.)</li> <li>Comparison operators (<code><span class=line>&lt;</span></code>, <code><span class=line>&gt;</span></code>, <code><span class=line>==</span></code>, etc.)</li> </ul> <p> It is prohibited to use a math operator on a mixture of scalars (individual numbers) and vectors. Zig provides the <a href=#splat>@splat</a> builtin to easily convert from scalars to vectors, and it supports <a href=#reduce>@reduce</a> and array indexing syntax to convert from vectors to scalars. Vectors also support assignment to and from fixed-length arrays with comptime known length. </p> <p> For rearranging elements within and between vectors, Zig provides the <a href=#shuffle>@shuffle</a> and <a href=#select>@select</a> functions. </p> <p> Operations on vectors shorter than the target machine's native SIMD size will typically compile to single SIMD instructions, while vectors longer than the target machine's native SIMD size will compile to multiple SIMD instructions. If a given operation doesn't have SIMD support on the target architecture, the compiler will default to operating on each vector element one at a time. Zig supports any comptime-known vector length up to 2^32-1, although small powers of two (2-64) are most typical. Note that excessively long vector lengths (e.g. 2^20) may result in compiler crashes on current versions of Zig. </p> <figure><figcaption class=zig-cap><cite class=file>vector_example.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expectEqual = std.testing.expectEqual;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"Basic vector usage"</span> {</span>
<span class=line>    <span class=tok-comment>// Vectors have a compile-time known length and base type.</span></span>
<span class=line>    <span class=tok-kw>const</span> a = <span class=tok-builtin>@Vector</span>(<span class=tok-number>4</span>, <span class=tok-type>i32</span>){ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span> };</span>
<span class=line>    <span class=tok-kw>const</span> b = <span class=tok-builtin>@Vector</span>(<span class=tok-number>4</span>, <span class=tok-type>i32</span>){ <span class=tok-number>5</span>, <span class=tok-number>6</span>, <span class=tok-number>7</span>, <span class=tok-number>8</span> };</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Math operations take place element-wise.</span></span>
<span class=line>    <span class=tok-kw>const</span> c = a + b;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Individual vector elements can be accessed using array indexing syntax.</span></span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(<span class=tok-number>6</span>, c[<span class=tok-number>0</span>]);</span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(<span class=tok-number>8</span>, c[<span class=tok-number>1</span>]);</span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(<span class=tok-number>10</span>, c[<span class=tok-number>2</span>]);</span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(<span class=tok-number>12</span>, c[<span class=tok-number>3</span>]);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"Conversion between vectors, arrays, and slices"</span> {</span>
<span class=line>    <span class=tok-comment>// Vectors and fixed-length arrays can be automatically assigned back and forth</span></span>
<span class=line>    <span class=tok-kw>var</span> arr1: [<span class=tok-number>4</span>]<span class=tok-type>f32</span> = [_]<span class=tok-type>f32</span>{ <span class=tok-number>1.1</span>, <span class=tok-number>3.2</span>, <span class=tok-number>4.5</span>, <span class=tok-number>5.6</span> };</span>
<span class=line>    <span class=tok-kw>var</span> vec: <span class=tok-builtin>@Vector</span>(<span class=tok-number>4</span>, <span class=tok-type>f32</span>) = arr1;</span>
<span class=line>    <span class=tok-kw>var</span> arr2: [<span class=tok-number>4</span>]<span class=tok-type>f32</span> = vec;</span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(arr1, arr2);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// You can also assign from a slice with comptime-known length to a vector using .*</span></span>
<span class=line>    <span class=tok-kw>const</span> vec2: <span class=tok-builtin>@Vector</span>(<span class=tok-number>2</span>, <span class=tok-type>f32</span>) = arr1[<span class=tok-number>1</span>..<span class=tok-number>3</span>].*;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> slice: []<span class=tok-kw>const</span> <span class=tok-type>f32</span> = &amp;arr1;</span>
<span class=line>    <span class=tok-kw>var</span> offset: <span class=tok-type>u32</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-comment>// To extract a comptime-known length from a runtime-known offset,</span></span>
<span class=line>    <span class=tok-comment>// first extract a new slice from the starting offset, then an array of</span></span>
<span class=line>    <span class=tok-comment>// comptime known length</span></span>
<span class=line>    <span class=tok-kw>const</span> vec3: <span class=tok-builtin>@Vector</span>(<span class=tok-number>2</span>, <span class=tok-type>f32</span>) = slice[offset..][<span class=tok-number>0</span>..<span class=tok-number>2</span>].*;</span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(slice[offset], vec2[<span class=tok-number>0</span>]);</span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(slice[offset + <span class=tok-number>1</span>], vec2[<span class=tok-number>1</span>]);</span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(vec2, vec3);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test vector_example.zig</kbd></span>
<span class=line>1/2 test.Basic vector usage... OK</span>
<span class=line>2/2 test.Conversion between vectors, arrays, and slices... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <p> TODO talk about C ABI interop<br> TODO consider suggesting std.MultiArrayList </p> <p>See also:</p><ul> <li><a href=#splat>@splat</a></li> <li><a href=#shuffle>@shuffle</a></li> <li><a href=#select>@select</a></li> <li><a href=#reduce>@reduce</a></li> </ul> <a name=//apple_ref/cpp/Guide/Pointers class=dashAnchor></a><h2 id=Pointers>Pointers</h2> <p> Zig has two kinds of pointers: single-item and many-item. </p> <ul> <li><code><span class=line>*T</span></code> - single-item pointer to exactly one item. <ul> <li>Supports deref syntax: <code><span class=line>ptr.*</span></code></li> </ul> </li> <li><code><span class=line>[*]T</span></code> - many-item pointer to unknown number of items. <ul> <li>Supports index syntax: <code><span class=line>ptr[i]</span></code></li> <li>Supports slice syntax: <code><span class=line>ptr[start..end]</span></code></li> <li>Supports pointer arithmetic: <code><span class=line>ptr + x</span></code>, <code><span class=line>ptr - x</span></code></li> <li><code><span class=line>T</span></code> must have a known size, which means that it cannot be <code><span class=line><span class=tok-type>anyopaque</span></span></code> or any other <a href=#opaque>opaque type</a>.</li> </ul> </li> </ul> <p>These types are closely related to <a href=#Arrays>Arrays</a> and <a href=#Slices>Slices</a>:</p> <ul> <li><code><span class=line>*[N]T</span></code> - pointer to N items, same as single-item pointer to an array. <ul> <li>Supports index syntax: <code><span class=line>array_ptr[i]</span></code></li> <li>Supports slice syntax: <code><span class=line>array_ptr[start..end]</span></code></li> <li>Supports len property: <code><span class=line>array_ptr.len</span></code></li> </ul> </li> </ul> <ul> <li><code><span class=line>[]T</span></code> - is a slice (a fat pointer, which contains a pointer of type <code><span class=line>[*]T</span></code> and a length). <ul> <li>Supports index syntax: <code><span class=line>slice[i]</span></code></li> <li>Supports slice syntax: <code><span class=line>slice[start..end]</span></code></li> <li>Supports len property: <code><span class=line>slice.len</span></code></li> </ul> </li> </ul> <p>Use <code><span class=line>&amp;x</span></code> to obtain a single-item pointer:</p> <figure><figcaption class=zig-cap><cite class=file>single_item_pointer_test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"address of syntax"</span> {</span>
<span class=line>    <span class=tok-comment>// Get the address of a variable:</span></span>
<span class=line>    <span class=tok-kw>const</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line>    <span class=tok-kw>const</span> x_ptr = &amp;x;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Dereference a pointer:</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(x_ptr.* == <span class=tok-number>1234</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// When you get the address of a const variable, you get a const single-item pointer.</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(x_ptr) == *<span class=tok-kw>const</span> <span class=tok-type>i32</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// If you want to mutate the value, you'd need an address of a mutable variable:</span></span>
<span class=line>    <span class=tok-kw>var</span> y: <span class=tok-type>i32</span> = <span class=tok-number>5678</span>;</span>
<span class=line>    <span class=tok-kw>const</span> y_ptr = &amp;y;</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(y_ptr) == *<span class=tok-type>i32</span>);</span>
<span class=line>    y_ptr.* += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(y_ptr.* == <span class=tok-number>5679</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointer array access"</span> {</span>
<span class=line>    <span class=tok-comment>// Taking an address of an individual element gives a</span></span>
<span class=line>    <span class=tok-comment>// single-item pointer. This kind of pointer</span></span>
<span class=line>    <span class=tok-comment>// does not support pointer arithmetic.</span></span>
<span class=line>    <span class=tok-kw>var</span> array = [_]<span class=tok-type>u8</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span>, <span class=tok-number>5</span>, <span class=tok-number>6</span>, <span class=tok-number>7</span>, <span class=tok-number>8</span>, <span class=tok-number>9</span>, <span class=tok-number>10</span> };</span>
<span class=line>    <span class=tok-kw>const</span> ptr = &amp;array[<span class=tok-number>2</span>];</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(ptr) == *<span class=tok-type>u8</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(array[<span class=tok-number>2</span>] == <span class=tok-number>3</span>);</span>
<span class=line>    ptr.* += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(array[<span class=tok-number>2</span>] == <span class=tok-number>4</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test single_item_pointer_test.zig</kbd></span>
<span class=line>1/2 test.address of syntax... OK</span>
<span class=line>2/2 test.pointer array access... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <p> Zig supports pointer arithmetic. It's better to assign the pointer to <code><span class=line>[*]T</span></code> and increment that variable. For example, directly incrementing the pointer from a slice will corrupt it. </p> <figure><figcaption class=zig-cap><cite class=file>pointer_arthemtic.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointer arithmetic with many-item pointer"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> array = [_]<span class=tok-type>i32</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span> };</span>
<span class=line>    <span class=tok-kw>var</span> ptr: [*]<span class=tok-kw>const</span> <span class=tok-type>i32</span> = &amp;array;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(ptr[<span class=tok-number>0</span>] == <span class=tok-number>1</span>);</span>
<span class=line>    ptr += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(ptr[<span class=tok-number>0</span>] == <span class=tok-number>2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointer arithmetic with slices"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> array = [_]<span class=tok-type>i32</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span> };</span>
<span class=line>    <span class=tok-kw>var</span> length: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>var</span> slice = array[length..array.len];</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(slice[<span class=tok-number>0</span>] == <span class=tok-number>1</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(slice.len == <span class=tok-number>4</span>);</span>
<span class=line></span>
<span class=line>    slice.ptr += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-comment>// now the slice is in an bad state since len has not been updated</span></span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(slice[<span class=tok-number>0</span>] == <span class=tok-number>2</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(slice.len == <span class=tok-number>4</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test pointer_arthemtic.zig</kbd></span>
<span class=line>1/2 test.pointer arithmetic with many-item pointer... OK</span>
<span class=line>2/2 test.pointer arithmetic with slices... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <p> In Zig, we generally prefer <a href=#Slices>Slices</a> rather than <a href=#Sentinel-Terminated-Pointers>Sentinel-Terminated Pointers</a>. You can turn an array or pointer into a slice using slice syntax. </p> <p> Slices have bounds checking and are therefore protected against this kind of undefined behavior. This is one reason we prefer slices to pointers. </p> <figure><figcaption class=zig-cap><cite class=file>slice_bounds.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointer slicing"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> array = [_]<span class=tok-type>u8</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span>, <span class=tok-number>5</span>, <span class=tok-number>6</span>, <span class=tok-number>7</span>, <span class=tok-number>8</span>, <span class=tok-number>9</span>, <span class=tok-number>10</span> };</span>
<span class=line>    <span class=tok-kw>const</span> slice = array[<span class=tok-number>2</span>..<span class=tok-number>4</span>];</span>
<span class=line>    <span class=tok-kw>try</span> expect(slice.len == <span class=tok-number>2</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(array[<span class=tok-number>3</span>] == <span class=tok-number>4</span>);</span>
<span class=line>    slice[<span class=tok-number>1</span>] += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(array[<span class=tok-number>3</span>] == <span class=tok-number>5</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test slice_bounds.zig</kbd></span>
<span class=line>1/1 test.pointer slicing... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>Pointers work at compile-time too, as long as the code does not depend on an undefined memory layout:</p> <figure><figcaption class=zig-cap><cite class=file>comptime_pointers.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"comptime pointers"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1</span>;</span>
<span class=line>        <span class=tok-kw>const</span> ptr = &amp;x;</span>
<span class=line>        ptr.* += <span class=tok-number>1</span>;</span>
<span class=line>        x += <span class=tok-number>1</span>;</span>
<span class=line>        <span class=tok-kw>try</span> expect(ptr.* == <span class=tok-number>3</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test comptime_pointers.zig</kbd></span>
<span class=line>1/1 test.comptime pointers... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>To convert an integer address into a pointer, use <code><span class=line><span class=tok-builtin>@intToPtr</span></span></code>. To convert a pointer to an integer, use <code><span class=line><span class=tok-builtin>@ptrToInt</span></span></code>:</p> <figure><figcaption class=zig-cap><cite class=file>integer_pointer_conversion.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"@ptrToInt and @intToPtr"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> ptr = <span class=tok-builtin>@intToPtr</span>(*<span class=tok-type>i32</span>, <span class=tok-number>0xdeadbee0</span>);</span>
<span class=line>    <span class=tok-kw>const</span> addr = <span class=tok-builtin>@ptrToInt</span>(ptr);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(addr) == <span class=tok-type>usize</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(addr == <span class=tok-number>0xdeadbee0</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test integer_pointer_conversion.zig</kbd></span>
<span class=line>1/1 test.@ptrToInt and @intToPtr... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>Zig is able to preserve memory addresses in comptime code, as long as the pointer is never dereferenced:</p> <figure><figcaption class=zig-cap><cite class=file>comptime_pointer_conversion.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"comptime @intToPtr"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-comment>// Zig is able to do this at compile-time, as long as</span></span>
<span class=line>        <span class=tok-comment>// ptr is never dereferenced.</span></span>
<span class=line>        <span class=tok-kw>const</span> ptr = <span class=tok-builtin>@intToPtr</span>(*<span class=tok-type>i32</span>, <span class=tok-number>0xdeadbee0</span>);</span>
<span class=line>        <span class=tok-kw>const</span> addr = <span class=tok-builtin>@ptrToInt</span>(ptr);</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(addr) == <span class=tok-type>usize</span>);</span>
<span class=line>        <span class=tok-kw>try</span> expect(addr == <span class=tok-number>0xdeadbee0</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test comptime_pointer_conversion.zig</kbd></span>
<span class=line>1/1 test.comptime @intToPtr... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Optional-Pointers>Optional Pointers</a></li> <li><a href=#intToPtr>@intToPtr</a></li> <li><a href=#ptrToInt>@ptrToInt</a></li> <li><a href=#C-Pointers>C Pointers</a></li> </ul> <a name=//apple_ref/cpp/Keyword/volatile class=dashAnchor></a><h3 id=volatile>volatile</h3> <p>Loads and stores are assumed to not have side effects. If a given load or store should have side effects, such as Memory Mapped Input/Output (MMIO), use <code><span class=line><span class=tok-kw>volatile</span></span></code>. In the following code, loads and stores with <code><span class=line>mmio_ptr</span></code> are guaranteed to all happen and in the same order as in source code:</p> <figure><figcaption class=zig-cap><cite class=file>volatile.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"volatile"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> mmio_ptr = <span class=tok-builtin>@intToPtr</span>(*<span class=tok-kw>volatile</span> <span class=tok-type>u8</span>, <span class=tok-number>0x12345678</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(mmio_ptr) == *<span class=tok-kw>volatile</span> <span class=tok-type>u8</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test volatile.zig</kbd></span>
<span class=line>1/1 test.volatile... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Note that <code><span class=line><span class=tok-kw>volatile</span></span></code> is unrelated to concurrency and <a href=#Atomics>Atomics</a>. If you see code that is using <code><span class=line><span class=tok-kw>volatile</span></span></code> for something other than Memory Mapped Input/Output, it is probably a bug. </p> <p> To convert one pointer type to another, use <a href=#ptrCast>@ptrCast</a>. This is an unsafe operation that Zig cannot protect you against. Use <code><span class=line><span class=tok-builtin>@ptrCast</span></span></code> only when other conversions are not possible. </p> <figure><figcaption class=zig-cap><cite class=file>pointer_casting.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointer casting"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> bytes <span class=tok-kw>align</span>(<span class=tok-builtin>@alignOf</span>(<span class=tok-type>u32</span>)) = [_]<span class=tok-type>u8</span>{ <span class=tok-number>0x12</span>, <span class=tok-number>0x12</span>, <span class=tok-number>0x12</span>, <span class=tok-number>0x12</span> };</span>
<span class=line>    <span class=tok-kw>const</span> u32_ptr = <span class=tok-builtin>@ptrCast</span>(*<span class=tok-kw>const</span> <span class=tok-type>u32</span>, &amp;bytes);</span>
<span class=line>    <span class=tok-kw>try</span> expect(u32_ptr.* == <span class=tok-number>0x12121212</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Even this example is contrived - there are better ways to do the above than</span></span>
<span class=line>    <span class=tok-comment>// pointer casting. For example, using a slice narrowing cast:</span></span>
<span class=line>    <span class=tok-kw>const</span> u32_value = std.mem.bytesAsSlice(<span class=tok-type>u32</span>, bytes[<span class=tok-number>0</span>..])[<span class=tok-number>0</span>];</span>
<span class=line>    <span class=tok-kw>try</span> expect(u32_value == <span class=tok-number>0x12121212</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// And even another way, the most straightforward way to do it:</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@bitCast</span>(<span class=tok-type>u32</span>, bytes) == <span class=tok-number>0x12121212</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointer child type"</span> {</span>
<span class=line>    <span class=tok-comment>// pointer types have a `child` field which tells you the type they point to.</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@typeInfo</span>(*<span class=tok-type>u32</span>).Pointer.child == <span class=tok-type>u32</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test pointer_casting.zig</kbd></span>
<span class=line>1/2 test.pointer casting... OK</span>
<span class=line>2/2 test.pointer child type... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Alignment class=dashAnchor></a><h3 id=Alignment>Alignment</h3> <p> Each type has an <strong>alignment</strong> - a number of bytes such that, when a value of the type is loaded from or stored to memory, the memory address must be evenly divisible by this number. You can use <a href=#alignOf>@alignOf</a> to find out this value for any type. </p> <p> Alignment depends on the CPU architecture, but is always a power of two, and less than <code><span class=line><span class=tok-number>1</span> &lt;&lt; <span class=tok-number>29</span></span></code>. </p> <p> In Zig, a pointer type has an alignment value. If the value is equal to the alignment of the underlying type, it can be omitted from the type: </p> <figure><figcaption class=zig-cap><cite class=file>variable_alignment.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> builtin = <span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"variable alignment"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line>    <span class=tok-kw>const</span> align_of_i32 = <span class=tok-builtin>@alignOf</span>(<span class=tok-builtin>@TypeOf</span>(x));</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(&amp;x) == *<span class=tok-type>i32</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(*<span class=tok-type>i32</span> == *<span class=tok-kw>align</span>(align_of_i32) <span class=tok-type>i32</span>);</span>
<span class=line>    <span class=tok-kw>if</span> (builtin.target.cpu.arch == .x86_64) {</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-builtin>@typeInfo</span>(*<span class=tok-type>i32</span>).Pointer.alignment == <span class=tok-number>4</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test variable_alignment.zig</kbd></span>
<span class=line>1/1 test.variable alignment... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>In the same way that a <code><span class=line>*<span class=tok-type>i32</span></span></code> can be <a href=#Type-Coercion>coerced</a> to a <code><span class=line>*<span class=tok-kw>const</span> <span class=tok-type>i32</span></span></code>, a pointer with a larger alignment can be implicitly cast to a pointer with a smaller alignment, but not vice versa. </p> <p> You can specify alignment on variables and functions. If you do this, then pointers to them get the specified alignment: </p> <figure><figcaption class=zig-cap><cite class=file>variable_func_alignment.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> foo: <span class=tok-type>u8</span> <span class=tok-kw>align</span>(<span class=tok-number>4</span>) = <span class=tok-number>100</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"global variable alignment"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@typeInfo</span>(<span class=tok-builtin>@TypeOf</span>(&amp;foo)).Pointer.alignment == <span class=tok-number>4</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(&amp;foo) == *<span class=tok-kw>align</span>(<span class=tok-number>4</span>) <span class=tok-type>u8</span>);</span>
<span class=line>    <span class=tok-kw>const</span> as_pointer_to_array: *<span class=tok-kw>align</span>(<span class=tok-number>4</span>) [<span class=tok-number>1</span>]<span class=tok-type>u8</span> = &amp;foo;</span>
<span class=line>    <span class=tok-kw>const</span> as_slice: []<span class=tok-kw>align</span>(<span class=tok-number>4</span>) <span class=tok-type>u8</span> = as_pointer_to_array;</span>
<span class=line>    <span class=tok-kw>const</span> as_unaligned_slice: []<span class=tok-type>u8</span> = as_slice;</span>
<span class=line>    <span class=tok-kw>try</span> expect(as_unaligned_slice[<span class=tok-number>0</span>] == <span class=tok-number>100</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>derp</span>() <span class=tok-kw>align</span>(<span class=tok-builtin>@sizeOf</span>(<span class=tok-type>usize</span>) * <span class=tok-number>2</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-number>1234</span>;</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>noop1</span>() <span class=tok-kw>align</span>(<span class=tok-number>1</span>) <span class=tok-type>void</span> {}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>noop4</span>() <span class=tok-kw>align</span>(<span class=tok-number>4</span>) <span class=tok-type>void</span> {}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"function alignment"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(derp() == <span class=tok-number>1234</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(noop1) == <span class=tok-kw>fn</span> () <span class=tok-kw>align</span>(<span class=tok-number>1</span>) <span class=tok-type>void</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(noop4) == <span class=tok-kw>fn</span> () <span class=tok-kw>align</span>(<span class=tok-number>4</span>) <span class=tok-type>void</span>);</span>
<span class=line>    noop1();</span>
<span class=line>    noop4();</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test variable_func_alignment.zig</kbd></span>
<span class=line>1/2 test.global variable alignment... OK</span>
<span class=line>2/2 test.function alignment... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <p> If you have a pointer or a slice that has a small alignment, but you know that it actually has a bigger alignment, use <a href=#alignCast>@alignCast</a> to change the pointer into a more aligned pointer. This is a no-op at runtime, but inserts a <a href=#Incorrect-Pointer-Alignment>safety check</a>: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointer alignment safety"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> array <span class=tok-kw>align</span>(<span class=tok-number>4</span>) = [_]<span class=tok-type>u32</span>{ <span class=tok-number>0x11111111</span>, <span class=tok-number>0x11111111</span> };</span>
<span class=line>    <span class=tok-kw>const</span> bytes = std.mem.sliceAsBytes(array[<span class=tok-number>0</span>..]);</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expect(foo(bytes) == <span class=tok-number>0x11111111</span>);</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(bytes: []<span class=tok-type>u8</span>) <span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>const</span> slice4 = bytes[<span class=tok-number>1</span>..<span class=tok-number>5</span>];</span>
<span class=line>    <span class=tok-kw>const</span> int_slice = std.mem.bytesAsSlice(<span class=tok-type>u32</span>, <span class=tok-builtin>@alignCast</span>(<span class=tok-number>4</span>, slice4));</span>
<span class=line>    <span class=tok-kw>return</span> int_slice[<span class=tok-number>0</span>];</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.pointer alignment safety... thread 1634285 panic: incorrect alignment</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:10:43</span>: <span class=t2_0>0x21178f in foo (test)</span></span>
<span class=line>    const int_slice = std.mem.bytesAsSlice(u32, @alignCast(4, slice4));</span>
<span class=line>                                          <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:6:31</span>: <span class=t2_0>0x2116b7 in test.pointer alignment safety (test)</span></span>
<span class=line>    try std.testing.expect(foo(bytes) == 0x11111111);</span>
<span class=line>                              <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x212de8 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x2120ab in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x211b71 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>error: the following test command crashed:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Keyword/allowzero class=dashAnchor></a><h3 id=allowzero>allowzero</h3> <p> This pointer attribute allows a pointer to have address zero. This is only ever needed on the freestanding OS target, where the address zero is mappable. If you want to represent null pointers, use <a href=#Optional-Pointers>Optional Pointers</a> instead. <a href=#Optional-Pointers>Optional Pointers</a> with <code><span class=line><span class=tok-kw>allowzero</span></span></code> are not the same size as pointers. In this code example, if the pointer did not have the <code><span class=line><span class=tok-kw>allowzero</span></span></code> attribute, this would be a <a href=#Pointer-Cast-Invalid-Null>Pointer Cast Invalid Null</a> panic: </p> <figure><figcaption class=zig-cap><cite class=file>allowzero.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"allowzero"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> zero: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>var</span> ptr = <span class=tok-builtin>@intToPtr</span>(*<span class=tok-kw>allowzero</span> <span class=tok-type>i32</span>, zero);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@ptrToInt</span>(ptr) == <span class=tok-number>0</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test allowzero.zig</kbd></span>
<span class=line>1/1 test.allowzero... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Sentinel-Terminated%20Pointers class=dashAnchor></a><h3 id=Sentinel-Terminated-Pointers>Sentinel-Terminated Pointers</h3> <p> The syntax <code><span class=line>[*:x]T</span></code> describes a pointer that has a length determined by a sentinel value. This provides protection against buffer overflow and overreads. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-comment>// This is also available as `std.c.printf`.</span></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>extern</span> <span class=tok-str>"c"</span> <span class=tok-kw>fn</span> <span class=tok-fn>printf</span>(format: [*:<span class=tok-number>0</span>]<span class=tok-kw>const</span> <span class=tok-type>u8</span>, ...) <span class=tok-type>c_int</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>anyerror</span>!<span class=tok-type>void</span> {</span>
<span class=line>    _ = printf(<span class=tok-str>"Hello, world!\n"</span>); <span class=tok-comment>// OK</span></span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> msg = <span class=tok-str>"Hello, world!\n"</span>;</span>
<span class=line>    <span class=tok-kw>const</span> non_null_terminated_msg: [msg.len]<span class=tok-type>u8</span> = msg.*;</span>
<span class=line>    _ = printf(&amp;non_null_terminated_msg);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig -lc</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:11:16: </span><span class=t31_1>error: </span><span class=t1_0>expected type '[*:0]const u8', found '*const [14]u8'</span>
<span class=line></span>    _ = printf(&amp;non_null_terminated_msg);</span>
<span class=line>               <span class=t32_1>^~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:11:16: </span><span class=t36_1>note: </span><span class=t1_0>destination pointer requires '0' sentinel</span>
<span class=line></span><span class=t2_0>referenced by:</span>
<span class=line>    comptime_0: /home/andy/tmp/zig/lib/std/start.zig:59:50</span>
<span class=line>    remaining reference traces hidden; use '-freference-trace' to see all reference traces</span>
<span class=line></span>
<span class=line></span></span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Sentinel-Terminated-Slices>Sentinel-Terminated Slices</a></li> <li><a href=#Sentinel-Terminated-Arrays>Sentinel-Terminated Arrays</a></li> </ul> <a name=//apple_ref/cpp/Guide/Slices class=dashAnchor></a><h2 id=Slices>Slices</h2> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"basic slices"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> array = [_]<span class=tok-type>i32</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span> };</span>
<span class=line>    <span class=tok-comment>// A slice is a pointer and a length. The difference between an array and</span></span>
<span class=line>    <span class=tok-comment>// a slice is that the array's length is part of the type and known at</span></span>
<span class=line>    <span class=tok-comment>// compile-time, whereas the slice's length is known at runtime.</span></span>
<span class=line>    <span class=tok-comment>// Both can be accessed with the `len` field.</span></span>
<span class=line>    <span class=tok-kw>var</span> known_at_runtime_zero: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>const</span> slice = array[known_at_runtime_zero..array.len];</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(slice) == []<span class=tok-type>i32</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(&amp;slice[<span class=tok-number>0</span>] == &amp;array[<span class=tok-number>0</span>]);</span>
<span class=line>    <span class=tok-kw>try</span> expect(slice.len == array.len);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// If you slice with comptime-known start and end positions, the result is</span></span>
<span class=line>    <span class=tok-comment>// a pointer to an array, rather than a slice.</span></span>
<span class=line>    <span class=tok-kw>const</span> array_ptr = array[<span class=tok-number>0</span>..array.len];</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(array_ptr) == *[array.len]<span class=tok-type>i32</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Using the address-of operator on a slice gives a single-item pointer,</span></span>
<span class=line>    <span class=tok-comment>// while using the `ptr` field gives a many-item pointer.</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(slice.ptr) == [*]<span class=tok-type>i32</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(&amp;slice[<span class=tok-number>0</span>]) == *<span class=tok-type>i32</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@ptrToInt</span>(slice.ptr) == <span class=tok-builtin>@ptrToInt</span>(&amp;slice[<span class=tok-number>0</span>]));</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Slices have array bounds checking. If you try to access something out</span></span>
<span class=line>    <span class=tok-comment>// of bounds, you'll get a safety check failure:</span></span>
<span class=line>    slice[<span class=tok-number>10</span>] += <span class=tok-number>1</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Note that `slice.ptr` does not invoke safety checking, while `&amp;slice[0]`</span></span>
<span class=line>    <span class=tok-comment>// asserts that the slice has len &gt;= 1.</span></span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.basic slices... thread 1634402 panic: index out of bounds: index 10, len 4</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:28:5</span>: <span class=t2_0>0x21196e in test.basic slices (test)</span></span>
<span class=line>    slice[10] += 1;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x212fd8 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x2122bb in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x211d81 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>error: the following test command crashed:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <p>This is one reason we prefer slices to pointers.</p> <figure><figcaption class=zig-cap><cite class=file>slices.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line><span class=tok-kw>const</span> mem = std.mem;</span>
<span class=line><span class=tok-kw>const</span> fmt = std.fmt;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"using slices for strings"</span> {</span>
<span class=line>    <span class=tok-comment>// Zig has no concept of strings. String literals are const pointers</span></span>
<span class=line>    <span class=tok-comment>// to null-terminated arrays of u8, and by convention parameters</span></span>
<span class=line>    <span class=tok-comment>// that are "strings" are expected to be UTF-8 encoded slices of u8.</span></span>
<span class=line>    <span class=tok-comment>// Here we coerce *const [5:0]u8 and *const [6:0]u8 to []const u8</span></span>
<span class=line>    <span class=tok-kw>const</span> hello: []<span class=tok-kw>const</span> <span class=tok-type>u8</span> = <span class=tok-str>"hello"</span>;</span>
<span class=line>    <span class=tok-kw>const</span> world: []<span class=tok-kw>const</span> <span class=tok-type>u8</span> = <span class=tok-str>"世界"</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> all_together: [<span class=tok-number>100</span>]<span class=tok-type>u8</span> = <span class=tok-null>undefined</span>;</span>
<span class=line>    <span class=tok-comment>// You can use slice syntax on an array to convert an array into a slice.</span></span>
<span class=line>    <span class=tok-kw>const</span> all_together_slice = all_together[<span class=tok-number>0</span>..];</span>
<span class=line>    <span class=tok-comment>// String concatenation example.</span></span>
<span class=line>    <span class=tok-kw>const</span> hello_world = <span class=tok-kw>try</span> fmt.bufPrint(all_together_slice, <span class=tok-str>"{s} {s}"</span>, .{ hello, world });</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Generally, you can use UTF-8 and not worry about whether something is a</span></span>
<span class=line>    <span class=tok-comment>// string. If you don't need to deal with individual characters, no need</span></span>
<span class=line>    <span class=tok-comment>// to decode.</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, hello_world, <span class=tok-str>"hello 世界"</span>));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"slice pointer"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: []<span class=tok-type>u8</span> = <span class=tok-null>undefined</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(a) == []<span class=tok-type>u8</span>);</span>
<span class=line>    <span class=tok-kw>var</span> array: [<span class=tok-number>10</span>]<span class=tok-type>u8</span> = <span class=tok-null>undefined</span>;</span>
<span class=line>    <span class=tok-kw>const</span> ptr = &amp;array;</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(ptr) == *[<span class=tok-number>10</span>]<span class=tok-type>u8</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// A pointer to an array can be sliced just like an array:</span></span>
<span class=line>    <span class=tok-kw>var</span> start: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>var</span> end: <span class=tok-type>usize</span> = <span class=tok-number>5</span>;</span>
<span class=line>    <span class=tok-kw>const</span> slice = ptr[start..end];</span>
<span class=line>    slice[<span class=tok-number>2</span>] = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(slice[<span class=tok-number>2</span>] == <span class=tok-number>3</span>);</span>
<span class=line>    <span class=tok-comment>// The slice is mutable because we sliced a mutable pointer.</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(slice) == []<span class=tok-type>u8</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Again, slicing with constant indexes will produce another pointer to an array:</span></span>
<span class=line>    <span class=tok-kw>const</span> ptr2 = slice[<span class=tok-number>2</span>..<span class=tok-number>3</span>];</span>
<span class=line>    <span class=tok-kw>try</span> expect(ptr2.len == <span class=tok-number>1</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(ptr2[<span class=tok-number>0</span>] == <span class=tok-number>3</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(ptr2) == *[<span class=tok-number>1</span>]<span class=tok-type>u8</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test slices.zig</kbd></span>
<span class=line>1/2 test.using slices for strings... OK</span>
<span class=line>2/2 test.slice pointer... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Pointers>Pointers</a></li> <li><a href=#for>for</a></li> <li><a href=#Arrays>Arrays</a></li> </ul> <a name=//apple_ref/cpp/Guide/Sentinel-Terminated%20Slices class=dashAnchor></a><h3 id=Sentinel-Terminated-Slices>Sentinel-Terminated Slices</h3> <p> The syntax <code><span class=line>[:x]T</span></code> is a slice which has a runtime known length and also guarantees a sentinel value at the element indexed by the length. The type does not guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element access to the <code><span class=line>len</span></code> index. </p> <figure><figcaption class=zig-cap><cite class=file>null_terminated_slice.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"null terminated slice"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> slice: [:<span class=tok-number>0</span>]<span class=tok-kw>const</span> <span class=tok-type>u8</span> = <span class=tok-str>"hello"</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(slice.len == <span class=tok-number>5</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(slice[<span class=tok-number>5</span>] == <span class=tok-number>0</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test null_terminated_slice.zig</kbd></span>
<span class=line>1/1 test.null terminated slice... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Sentinel-terminated slices can also be created using a variation of the slice syntax <code><span class=line>data[start..end :x]</span></code>, where <code><span class=line>data</span></code> is a many-item pointer, array or slice and <code><span class=line>x</span></code> is the sentinel value. </p> <figure><figcaption class=zig-cap><cite class=file>null_terminated_slicing.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"null terminated slicing"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> array = [_]<span class=tok-type>u8</span>{ <span class=tok-number>3</span>, <span class=tok-number>2</span>, <span class=tok-number>1</span>, <span class=tok-number>0</span>, <span class=tok-number>3</span>, <span class=tok-number>2</span>, <span class=tok-number>1</span>, <span class=tok-number>0</span> };</span>
<span class=line>    <span class=tok-kw>var</span> runtime_length: <span class=tok-type>usize</span> = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>const</span> slice = array[<span class=tok-number>0</span>..runtime_length :<span class=tok-number>0</span>];</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(slice) == [:<span class=tok-number>0</span>]<span class=tok-type>u8</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(slice.len == <span class=tok-number>3</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test null_terminated_slicing.zig</kbd></span>
<span class=line>1/1 test.null terminated slicing... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Sentinel-terminated slicing asserts that the element in the sentinel position of the backing data is actually the sentinel value. If this is not the case, safety-protected <a href=#Undefined-Behavior>Undefined Behavior</a> results. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"sentinel mismatch"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> array = [_]<span class=tok-type>u8</span>{ <span class=tok-number>3</span>, <span class=tok-number>2</span>, <span class=tok-number>1</span>, <span class=tok-number>0</span> };</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Creating a sentinel-terminated slice from the array with a length of 2</span></span>
<span class=line>    <span class=tok-comment>// will result in the value `1` occupying the sentinel element position.</span></span>
<span class=line>    <span class=tok-comment>// This does not match the indicated sentinel value of `0` and will lead</span></span>
<span class=line>    <span class=tok-comment>// to a runtime panic.</span></span>
<span class=line>    <span class=tok-kw>var</span> runtime_length: <span class=tok-type>usize</span> = <span class=tok-number>2</span>;</span>
<span class=line>    <span class=tok-kw>const</span> slice = array[<span class=tok-number>0</span>..runtime_length :<span class=tok-number>0</span>];</span>
<span class=line></span>
<span class=line>    _ = slice;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.sentinel mismatch... thread 1634554 panic: sentinel mismatch: expected 0, found 1</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:12:5</span>: <span class=t2_0>0x2115f9 in test.sentinel mismatch (test)</span></span>
<span class=line>    const slice = array[0..runtime_length :0];</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x212e08 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x211f2b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x2119f1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>error: the following test command crashed:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Sentinel-Terminated-Pointers>Sentinel-Terminated Pointers</a></li> <li><a href=#Sentinel-Terminated-Arrays>Sentinel-Terminated Arrays</a></li> </ul> <a name=//apple_ref/cpp/Keyword/struct class=dashAnchor></a><h2 id=struct>struct</h2> <figure><figcaption class=zig-cap><cite class=file>structs.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>// Declare a struct.</span></span>
<span class=line><span class=tok-comment>// Zig gives no guarantees about the order of fields and the size of</span></span>
<span class=line><span class=tok-comment>// the struct but the fields are guaranteed to be ABI-aligned.</span></span>
<span class=line><span class=tok-kw>const</span> Point = <span class=tok-kw>struct</span> {</span>
<span class=line>    x: <span class=tok-type>f32</span>,</span>
<span class=line>    y: <span class=tok-type>f32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Maybe we want to pass it to OpenGL so we want to be particular about</span></span>
<span class=line><span class=tok-comment>// how the bytes are arranged.</span></span>
<span class=line><span class=tok-kw>const</span> Point2 = <span class=tok-kw>packed</span> <span class=tok-kw>struct</span> {</span>
<span class=line>    x: <span class=tok-type>f32</span>,</span>
<span class=line>    y: <span class=tok-type>f32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line></span>
<span class=line><span class=tok-comment>// Declare an instance of a struct.</span></span>
<span class=line><span class=tok-kw>const</span> p = Point {</span>
<span class=line>    .x = <span class=tok-number>0.12</span>,</span>
<span class=line>    .y = <span class=tok-number>0.34</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Maybe we're not ready to fill out some of the fields.</span></span>
<span class=line><span class=tok-kw>var</span> p2 = Point {</span>
<span class=line>    .x = <span class=tok-number>0.12</span>,</span>
<span class=line>    .y = <span class=tok-null>undefined</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Structs can have methods</span></span>
<span class=line><span class=tok-comment>// Struct methods are not special, they are only namespaced</span></span>
<span class=line><span class=tok-comment>// functions that you can call with dot syntax.</span></span>
<span class=line><span class=tok-kw>const</span> Vec3 = <span class=tok-kw>struct</span> {</span>
<span class=line>    x: <span class=tok-type>f32</span>,</span>
<span class=line>    y: <span class=tok-type>f32</span>,</span>
<span class=line>    z: <span class=tok-type>f32</span>,</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>init</span>(x: <span class=tok-type>f32</span>, y: <span class=tok-type>f32</span>, z: <span class=tok-type>f32</span>) Vec3 {</span>
<span class=line>        <span class=tok-kw>return</span> Vec3 {</span>
<span class=line>            .x = x,</span>
<span class=line>            .y = y,</span>
<span class=line>            .z = z,</span>
<span class=line>        };</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>dot</span>(self: Vec3, other: Vec3) <span class=tok-type>f32</span> {</span>
<span class=line>        <span class=tok-kw>return</span> self.x * other.x + self.y * other.y + self.z * other.z;</span>
<span class=line>    }</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"dot product"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> v1 = Vec3.init(<span class=tok-number>1.0</span>, <span class=tok-number>0.0</span>, <span class=tok-number>0.0</span>);</span>
<span class=line>    <span class=tok-kw>const</span> v2 = Vec3.init(<span class=tok-number>0.0</span>, <span class=tok-number>1.0</span>, <span class=tok-number>0.0</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(v1.dot(v2) == <span class=tok-number>0.0</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Other than being available to call with dot syntax, struct methods are</span></span>
<span class=line>    <span class=tok-comment>// not special. You can reference them as any other declaration inside</span></span>
<span class=line>    <span class=tok-comment>// the struct:</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(Vec3.dot(v1, v2) == <span class=tok-number>0.0</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Structs can have declarations.</span></span>
<span class=line><span class=tok-comment>// Structs can have 0 fields.</span></span>
<span class=line><span class=tok-kw>const</span> Empty = <span class=tok-kw>struct</span> {</span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>const</span> PI = <span class=tok-number>3.14</span>;</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"struct namespaced variable"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(Empty.PI == <span class=tok-number>3.14</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@sizeOf</span>(Empty) == <span class=tok-number>0</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// you can still instantiate an empty struct</span></span>
<span class=line>    <span class=tok-kw>const</span> does_nothing = Empty {};</span>
<span class=line></span>
<span class=line>    _ = does_nothing;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// struct field order is determined by the compiler for optimal performance.</span></span>
<span class=line><span class=tok-comment>// however, you can still calculate a struct base pointer given a field pointer:</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>setYBasedOnX</span>(x: *<span class=tok-type>f32</span>, y: <span class=tok-type>f32</span>) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> point = <span class=tok-builtin>@fieldParentPtr</span>(Point, <span class=tok-str>"x"</span>, x);</span>
<span class=line>    point.y = y;</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"field parent pointer"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> point = Point {</span>
<span class=line>        .x = <span class=tok-number>0.1234</span>,</span>
<span class=line>        .y = <span class=tok-number>0.5678</span>,</span>
<span class=line>    };</span>
<span class=line>    setYBasedOnX(&amp;point.x, <span class=tok-number>0.9</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(point.y == <span class=tok-number>0.9</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// You can return a struct from a function. This is how we do generics</span></span>
<span class=line><span class=tok-comment>// in Zig:</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>LinkedList</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>) <span class=tok-type>type</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>struct</span> {</span>
<span class=line>        <span class=tok-kw>pub</span> <span class=tok-kw>const</span> Node = <span class=tok-kw>struct</span> {</span>
<span class=line>            prev: ?*Node,</span>
<span class=line>            next: ?*Node,</span>
<span class=line>            data: T,</span>
<span class=line>        };</span>
<span class=line></span>
<span class=line>        first: ?*Node,</span>
<span class=line>        last:  ?*Node,</span>
<span class=line>        len:   <span class=tok-type>usize</span>,</span>
<span class=line>    };</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"linked list"</span> {</span>
<span class=line>    <span class=tok-comment>// Functions called at compile-time are memoized. This means you can</span></span>
<span class=line>    <span class=tok-comment>// do this:</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(LinkedList(<span class=tok-type>i32</span>) == LinkedList(<span class=tok-type>i32</span>));</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> list = LinkedList(<span class=tok-type>i32</span>) {</span>
<span class=line>        .first = <span class=tok-null>null</span>,</span>
<span class=line>        .last = <span class=tok-null>null</span>,</span>
<span class=line>        .len = <span class=tok-number>0</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>try</span> expect(list.len == <span class=tok-number>0</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Since types are first class values you can instantiate the type</span></span>
<span class=line>    <span class=tok-comment>// by assigning it to a variable:</span></span>
<span class=line>    <span class=tok-kw>const</span> ListOfInts = LinkedList(<span class=tok-type>i32</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(ListOfInts == LinkedList(<span class=tok-type>i32</span>));</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> node = ListOfInts.Node {</span>
<span class=line>        .prev = <span class=tok-null>null</span>,</span>
<span class=line>        .next = <span class=tok-null>null</span>,</span>
<span class=line>        .data = <span class=tok-number>1234</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>var</span> list2 = LinkedList(<span class=tok-type>i32</span>) {</span>
<span class=line>        .first = &amp;node,</span>
<span class=line>        .last = &amp;node,</span>
<span class=line>        .len = <span class=tok-number>1</span>,</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// When using a pointer to a struct, fields can be accessed directly,</span></span>
<span class=line>    <span class=tok-comment>// without explicitly dereferencing the pointer.</span></span>
<span class=line>    <span class=tok-comment>// So you can do</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(list2.first.?.data == <span class=tok-number>1234</span>);</span>
<span class=line>    <span class=tok-comment>// instead of try expect(list2.first.?.*.data == 1234);</span></span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test structs.zig</kbd></span>
<span class=line>1/4 test.dot product... OK</span>
<span class=line>2/4 test.struct namespaced variable... OK</span>
<span class=line>3/4 test.field parent pointer... OK</span>
<span class=line>4/4 test.linked list... OK</span>
<span class=line>All 4 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Default%20Field%20Values class=dashAnchor></a><h3 id=Default-Field-Values>Default Field Values</h3> <p> Each struct field may have an expression indicating the default field value. Such expressions are executed at <a href=#comptime>comptime</a>, and allow the field to be omitted in a struct literal expression: </p> <figure><figcaption class=zig-cap><cite class=file>default_field_values.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>struct</span> {</span>
<span class=line>    a: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>,</span>
<span class=line>    b: <span class=tok-type>i32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"default struct initialization fields"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x = Foo{</span>
<span class=line>        .b = <span class=tok-number>5</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>if</span> (x.a + x.b != <span class=tok-number>1239</span>) {</span>
<span class=line>        <span class=tok-builtin>@compileError</span>(<span class=tok-str>"it's even comptime known!"</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test default_field_values.zig</kbd></span>
<span class=line>1/1 test.default struct initialization fields... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Keyword/extern%20struct class=dashAnchor></a><h3 id=extern-struct>extern struct</h3> <p>An <code><span class=line><span class=tok-kw>extern</span> <span class=tok-kw>struct</span></span></code> has in-memory layout guaranteed to match the C ABI for the target.</p> <p>This kind of struct should only be used for compatibility with the C ABI. Every other use case should be solved with <a href=#packed-struct>packed struct</a> or normal <a href=#struct>struct</a>.</p> <p>See also:</p><ul> <li><a href=#extern-union>extern union</a></li> <li><a href=#extern-enum>extern enum</a></li> </ul> <a name=//apple_ref/cpp/Keyword/packed%20struct class=dashAnchor></a><h3 id=packed-struct>packed struct</h3> <p> Unlike normal structs, <code><span class=line><span class=tok-kw>packed</span></span></code> structs have guaranteed in-memory layout: </p> <ul> <li>Fields remain in the order declared.</li> <li>There is no padding between fields.</li> <li>Zig supports arbitrary width <a href=#Integers>Integers</a> and although normally, integers with fewer than 8 bits will still use 1 byte of memory, in packed structs, they use exactly their bit width. </li> <li><code><span class=line><span class=tok-type>bool</span></span></code> fields use exactly 1 bit.</li> <li>An <a href=#enum>enum</a> field uses exactly the bit width of its integer tag type.</li> <li>A <a href=#packed-union>packed union</a> field uses exactly the bit width of the union field with the largest bit width.</li> <li>Non-ABI-aligned fields are packed into the smallest possible ABI-aligned integers in accordance with the target endianness. </li> </ul> <p> This means that a <code><span class=line><span class=tok-kw>packed</span> <span class=tok-kw>struct</span></span></code> can participate in a <a href=#bitCast>@bitCast</a> or a <a href=#ptrCast>@ptrCast</a> to reinterpret memory. This even works at <a href=#comptime>comptime</a>: </p> <figure><figcaption class=zig-cap><cite class=file>packed_structs.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> native_endian = <span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>).target.cpu.arch.endian();</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Full = <span class=tok-kw>packed</span> <span class=tok-kw>struct</span> {</span>
<span class=line>    number: <span class=tok-type>u16</span>,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> Divided = <span class=tok-kw>packed</span> <span class=tok-kw>struct</span> {</span>
<span class=line>    half1: <span class=tok-type>u8</span>,</span>
<span class=line>    quarter3: <span class=tok-type>u4</span>,</span>
<span class=line>    quarter4: <span class=tok-type>u4</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"@bitCast between packed structs"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> doTheTest();</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> doTheTest();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>doTheTest</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@sizeOf</span>(Full) == <span class=tok-number>2</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@sizeOf</span>(Divided) == <span class=tok-number>2</span>);</span>
<span class=line>    <span class=tok-kw>var</span> full = Full{ .number = <span class=tok-number>0x1234</span> };</span>
<span class=line>    <span class=tok-kw>var</span> divided = <span class=tok-builtin>@bitCast</span>(Divided, full);</span>
<span class=line>    <span class=tok-kw>switch</span> (native_endian) {</span>
<span class=line>        .Big =&gt; {</span>
<span class=line>            <span class=tok-kw>try</span> expect(divided.half1 == <span class=tok-number>0x12</span>);</span>
<span class=line>            <span class=tok-kw>try</span> expect(divided.quarter3 == <span class=tok-number>0x3</span>);</span>
<span class=line>            <span class=tok-kw>try</span> expect(divided.quarter4 == <span class=tok-number>0x4</span>);</span>
<span class=line>        },</span>
<span class=line>        .Little =&gt; {</span>
<span class=line>            <span class=tok-kw>try</span> expect(divided.half1 == <span class=tok-number>0x34</span>);</span>
<span class=line>            <span class=tok-kw>try</span> expect(divided.quarter3 == <span class=tok-number>0x2</span>);</span>
<span class=line>            <span class=tok-kw>try</span> expect(divided.quarter4 == <span class=tok-number>0x1</span>);</span>
<span class=line>        },</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test packed_structs.zig</kbd></span>
<span class=line>1/1 test.@bitCast between packed structs... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Zig allows the address to be taken of a non-byte-aligned field: </p> <figure><figcaption class=zig-cap><cite class=file>pointer_to_non-byte_aligned_field.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> BitField = <span class=tok-kw>packed</span> <span class=tok-kw>struct</span> {</span>
<span class=line>    a: <span class=tok-type>u3</span>,</span>
<span class=line>    b: <span class=tok-type>u3</span>,</span>
<span class=line>    c: <span class=tok-type>u2</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> foo = BitField{</span>
<span class=line>    .a = <span class=tok-number>1</span>,</span>
<span class=line>    .b = <span class=tok-number>2</span>,</span>
<span class=line>    .c = <span class=tok-number>3</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointer to non-byte-aligned field"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> ptr = &amp;foo.b;</span>
<span class=line>    <span class=tok-kw>try</span> expect(ptr.* == <span class=tok-number>2</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test pointer_to_non-byte_aligned_field.zig</kbd></span>
<span class=line>1/1 test.pointer to non-byte-aligned field... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> However, the pointer to a non-byte-aligned field has special properties and cannot be passed when a normal pointer is expected: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> BitField = <span class=tok-kw>packed</span> <span class=tok-kw>struct</span> {</span>
<span class=line>    a: <span class=tok-type>u3</span>,</span>
<span class=line>    b: <span class=tok-type>u3</span>,</span>
<span class=line>    c: <span class=tok-type>u2</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> bit_field = BitField{</span>
<span class=line>    .a = <span class=tok-number>1</span>,</span>
<span class=line>    .b = <span class=tok-number>2</span>,</span>
<span class=line>    .c = <span class=tok-number>3</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointer to non-bit-aligned field"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(bar(&amp;bit_field.b) == <span class=tok-number>2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bar</span>(x: *<span class=tok-kw>const</span> <span class=tok-type>u3</span>) <span class=tok-type>u3</span> {</span>
<span class=line>    <span class=tok-kw>return</span> x.*;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:17:20: </span><span class=t31_1>error: </span><span class=t1_0>expected type '*const u3', found '*align(0:3:1) u3'</span>
<span class=line></span>    try expect(bar(&amp;bit_field.b) == 2);</span>
<span class=line>                   <span class=t32_1>^~~~~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:17:20: </span><span class=t36_1>note: </span><span class=t1_0>pointer host size '1' cannot cast into pointer host size '0'</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:17:20: </span><span class=t36_1>note: </span><span class=t1_0>pointer bit offset '3' cannot cast into pointer bit offset '0'</span>
<span class=line></span></span>
</samp></pre></figure> <p> In this case, the function <code><span class=line>bar</span></code> cannot be called because the pointer to the non-ABI-aligned field mentions the bit offset, but the function expects an ABI-aligned pointer. </p> <p> Pointers to non-ABI-aligned fields share the same address as the other fields within their host integer: </p> <figure><figcaption class=zig-cap><cite class=file>packed_struct_field_addrs.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> BitField = <span class=tok-kw>packed</span> <span class=tok-kw>struct</span> {</span>
<span class=line>    a: <span class=tok-type>u3</span>,</span>
<span class=line>    b: <span class=tok-type>u3</span>,</span>
<span class=line>    c: <span class=tok-type>u2</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> bit_field = BitField{</span>
<span class=line>    .a = <span class=tok-number>1</span>,</span>
<span class=line>    .b = <span class=tok-number>2</span>,</span>
<span class=line>    .c = <span class=tok-number>3</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointers of sub-byte-aligned fields share addresses"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@ptrToInt</span>(&amp;bit_field.a) == <span class=tok-builtin>@ptrToInt</span>(&amp;bit_field.b));</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@ptrToInt</span>(&amp;bit_field.a) == <span class=tok-builtin>@ptrToInt</span>(&amp;bit_field.c));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test packed_struct_field_addrs.zig</kbd></span>
<span class=line>1/1 test.pointers of sub-byte-aligned fields share addresses... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> This can be observed with <a href=#bitOffsetOf>@bitOffsetOf</a> and <a href=#offsetOf>offsetOf</a>: </p> <figure><figcaption class=zig-cap><cite class=file>test_bitOffsetOf_offsetOf.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> BitField = <span class=tok-kw>packed</span> <span class=tok-kw>struct</span> {</span>
<span class=line>    a: <span class=tok-type>u3</span>,</span>
<span class=line>    b: <span class=tok-type>u3</span>,</span>
<span class=line>    c: <span class=tok-type>u2</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pointer to non-bit-aligned field"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-builtin>@bitOffsetOf</span>(BitField, <span class=tok-str>"a"</span>) == <span class=tok-number>0</span>);</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-builtin>@bitOffsetOf</span>(BitField, <span class=tok-str>"b"</span>) == <span class=tok-number>3</span>);</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-builtin>@bitOffsetOf</span>(BitField, <span class=tok-str>"c"</span>) == <span class=tok-number>6</span>);</span>
<span class=line></span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-builtin>@offsetOf</span>(BitField, <span class=tok-str>"a"</span>) == <span class=tok-number>0</span>);</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-builtin>@offsetOf</span>(BitField, <span class=tok-str>"b"</span>) == <span class=tok-number>0</span>);</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-builtin>@offsetOf</span>(BitField, <span class=tok-str>"c"</span>) == <span class=tok-number>0</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_bitOffsetOf_offsetOf.zig</kbd></span>
<span class=line>1/1 test.pointer to non-bit-aligned field... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Packed structs have the same alignment as their backing integer, however, overaligned pointers to packed structs can override this: </p> <figure><figcaption class=zig-cap><cite class=file>overaligned_packed_struct.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> S = <span class=tok-kw>packed</span> <span class=tok-kw>struct</span> {</span>
<span class=line>    a: <span class=tok-type>u32</span>,</span>
<span class=line>    b: <span class=tok-type>u32</span>,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"overaligned pointer to packed struct"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> foo: S <span class=tok-kw>align</span>(<span class=tok-number>4</span>) = .{ .a = <span class=tok-number>1</span>, .b = <span class=tok-number>2</span> };</span>
<span class=line>    <span class=tok-kw>const</span> ptr: *<span class=tok-kw>align</span>(<span class=tok-number>4</span>) S = &amp;foo;</span>
<span class=line>    <span class=tok-kw>const</span> ptr_to_b: *<span class=tok-type>u32</span> = &amp;ptr.b;</span>
<span class=line>    <span class=tok-kw>try</span> expect(ptr_to_b.* == <span class=tok-number>2</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test overaligned_packed_struct.zig</kbd></span>
<span class=line>1/1 test.overaligned pointer to packed struct... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> It's also possible to set alignment of struct fields: </p> <figure><figcaption class=zig-cap><cite class=file>test_aligned_struct_fields.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expectEqual = std.testing.expectEqual;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"aligned struct fields"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> S = <span class=tok-kw>struct</span> {</span>
<span class=line>        a: <span class=tok-type>u32</span> <span class=tok-kw>align</span>(<span class=tok-number>2</span>),</span>
<span class=line>        b: <span class=tok-type>u32</span> <span class=tok-kw>align</span>(<span class=tok-number>64</span>),</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>var</span> foo = S{ .a = <span class=tok-number>1</span>, .b = <span class=tok-number>2</span> };</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(<span class=tok-number>64</span>, <span class=tok-builtin>@alignOf</span>(S));</span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(*<span class=tok-kw>align</span>(<span class=tok-number>2</span>) <span class=tok-type>u32</span>, <span class=tok-builtin>@TypeOf</span>(&amp;foo.a));</span>
<span class=line>    <span class=tok-kw>try</span> expectEqual(*<span class=tok-kw>align</span>(<span class=tok-number>64</span>) <span class=tok-type>u32</span>, <span class=tok-builtin>@TypeOf</span>(&amp;foo.b));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_aligned_struct_fields.zig</kbd></span>
<span class=line>1/1 test.aligned struct fields... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Using packed structs with <a href=#volatile>volatile</a> is problematic, and may be a compile error in the future. For details on this subscribe to <a href=https://github.com/ziglang/zig/issues/1761>this issue</a>. TODO update these docs with a recommendation on how to use packed structs with MMIO (the use case for volatile packed structs) once this issue is resolved. Don't worry, there will be a good solution for this use case in zig. </p> <a name=//apple_ref/cpp/Guide/Struct%20Naming class=dashAnchor></a><h3 id=Struct-Naming>Struct Naming</h3> <p>Since all structs are anonymous, Zig infers the type name based on a few rules.</p> <ul> <li>If the struct is in the initialization expression of a variable, it gets named after that variable.</li> <li>If the struct is in the <code><span class=line><span class=tok-kw>return</span></span></code> expression, it gets named after the function it is returning from, with the parameter values serialized.</li> <li>Otherwise, the struct gets a name such as <code>(anonymous struct at file.zig:7:38)</code>.</li> <li>If the struct is declared inside another struct, it gets named after both the parent struct and the name inferred by the previous rules, separated by a dot.</li> </ul> <figure><figcaption class=zig-cap><cite class=file>struct_name.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> Foo = <span class=tok-kw>struct</span> {};</span>
<span class=line>    std.debug.print(<span class=tok-str>"variable: {s}\n"</span>, .{<span class=tok-builtin>@typeName</span>(Foo)});</span>
<span class=line>    std.debug.print(<span class=tok-str>"anonymous: {s}\n"</span>, .{<span class=tok-builtin>@typeName</span>(<span class=tok-kw>struct</span> {})});</span>
<span class=line>    std.debug.print(<span class=tok-str>"function: {s}\n"</span>, .{<span class=tok-builtin>@typeName</span>(List(<span class=tok-type>i32</span>))});</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>List</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>) <span class=tok-type>type</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>struct</span> {</span>
<span class=line>        x: T,</span>
<span class=line>    };</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe struct_name.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./struct_name</kbd></span>
<span class=line>variable: struct_name.main.Foo</span>
<span class=line>anonymous: struct_name.main__struct_3881</span>
<span class=line>function: struct_name.List(i32)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Anonymous%20Struct%20Literals class=dashAnchor></a><h3 id=Anonymous-Struct-Literals>Anonymous Struct Literals</h3> <p> Zig allows omitting the struct type of a literal. When the result is <a href=#Type-Coercion>coerced</a>, the struct literal will directly instantiate the result location, with no copy: </p> <figure><figcaption class=zig-cap><cite class=file>struct_result.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Point = <span class=tok-kw>struct</span> {x: <span class=tok-type>i32</span>, y: <span class=tok-type>i32</span>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"anonymous struct literal"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> pt: Point = .{</span>
<span class=line>        .x = <span class=tok-number>13</span>,</span>
<span class=line>        .y = <span class=tok-number>67</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>try</span> expect(pt.x == <span class=tok-number>13</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(pt.y == <span class=tok-number>67</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test struct_result.zig</kbd></span>
<span class=line>1/1 test.anonymous struct literal... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> The struct type can be inferred. Here the result location does not include a type, and so Zig infers the type: </p> <figure><figcaption class=zig-cap><cite class=file>struct_anon.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"fully anonymous struct"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> dump(.{</span>
<span class=line>        .int = <span class=tok-builtin>@as</span>(<span class=tok-type>u32</span>, <span class=tok-number>1234</span>),</span>
<span class=line>        .float = <span class=tok-builtin>@as</span>(<span class=tok-type>f64</span>, <span class=tok-number>12.34</span>),</span>
<span class=line>        .b = <span class=tok-null>true</span>,</span>
<span class=line>        .s = <span class=tok-str>"hi"</span>,</span>
<span class=line>    });</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>dump</span>(args: <span class=tok-kw>anytype</span>) !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(args.int == <span class=tok-number>1234</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(args.float == <span class=tok-number>12.34</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(args.b);</span>
<span class=line>    <span class=tok-kw>try</span> expect(args.s[<span class=tok-number>0</span>] == <span class=tok-str>'h'</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(args.s[<span class=tok-number>1</span>] == <span class=tok-str>'i'</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test struct_anon.zig</kbd></span>
<span class=line>1/1 test.fully anonymous struct... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Anonymous structs can be created without specifying field names, and are referred to as "tuples". </p> <p> The fields are implicitly named using numbers starting from 0. Because their names are integers, the <code><span class=line>@"0"</span></code> syntax must be used to access them. Names inside <code><span class=line>@""</span></code> are always recognised as <a href=#Identifiers>identifiers</a>. </p> <p> Like arrays, tuples have a .len field, can be indexed and work with the ++ and ** operators. They can also be iterated over with <a href=#inline-for>inline for</a>. </p> <figure><figcaption class=zig-cap><cite class=file>tuple.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"tuple"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> values = .{</span>
<span class=line>        <span class=tok-builtin>@as</span>(<span class=tok-type>u32</span>, <span class=tok-number>1234</span>),</span>
<span class=line>        <span class=tok-builtin>@as</span>(<span class=tok-type>f64</span>, <span class=tok-number>12.34</span>),</span>
<span class=line>        <span class=tok-null>true</span>,</span>
<span class=line>        <span class=tok-str>"hi"</span>,</span>
<span class=line>    } ++ .{<span class=tok-null>false</span>} ** <span class=tok-number>2</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(values[<span class=tok-number>0</span>] == <span class=tok-number>1234</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(values[<span class=tok-number>4</span>] == <span class=tok-null>false</span>);</span>
<span class=line>    <span class=tok-kw>inline</span> <span class=tok-kw>for</span> (values) |v, i| {</span>
<span class=line>        <span class=tok-kw>if</span> (i != <span class=tok-number>2</span>) <span class=tok-kw>continue</span>;</span>
<span class=line>        <span class=tok-kw>try</span> expect(v);</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(values.len == <span class=tok-number>6</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(values.@"3"[<span class=tok-number>0</span>] == <span class=tok-str>'h'</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test tuple.zig</kbd></span>
<span class=line>1/1 test.tuple... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#comptime>comptime</a></li> <li><a href=#fieldParentPtr>@fieldParentPtr</a></li> </ul> <a name=//apple_ref/cpp/Keyword/enum class=dashAnchor></a><h2 id=enum>enum</h2> <figure><figcaption class=zig-cap><cite class=file>enums.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line><span class=tok-kw>const</span> mem = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).mem;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Declare an enum.</span></span>
<span class=line><span class=tok-kw>const</span> Type = <span class=tok-kw>enum</span> {</span>
<span class=line>    ok,</span>
<span class=line>    not_ok,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Declare a specific instance of the enum variant.</span></span>
<span class=line><span class=tok-kw>const</span> c = Type.ok;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// If you want access to the ordinal value of an enum, you</span></span>
<span class=line><span class=tok-comment>// can specify the tag type.</span></span>
<span class=line><span class=tok-kw>const</span> Value = <span class=tok-kw>enum</span>(<span class=tok-type>u2</span>) {</span>
<span class=line>    zero,</span>
<span class=line>    one,</span>
<span class=line>    two,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Now you can cast between u2 and Value.</span></span>
<span class=line><span class=tok-comment>// The ordinal value starts from 0, counting up for each member.</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"enum ordinal value"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@enumToInt</span>(Value.zero) == <span class=tok-number>0</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@enumToInt</span>(Value.one) == <span class=tok-number>1</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@enumToInt</span>(Value.two) == <span class=tok-number>2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// You can override the ordinal value for an enum.</span></span>
<span class=line><span class=tok-kw>const</span> Value2 = <span class=tok-kw>enum</span>(<span class=tok-type>u32</span>) {</span>
<span class=line>    hundred = <span class=tok-number>100</span>,</span>
<span class=line>    thousand = <span class=tok-number>1000</span>,</span>
<span class=line>    million = <span class=tok-number>1000000</span>,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"set enum ordinal value"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@enumToInt</span>(Value2.hundred) == <span class=tok-number>100</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@enumToInt</span>(Value2.thousand) == <span class=tok-number>1000</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@enumToInt</span>(Value2.million) == <span class=tok-number>1000000</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Enums can have methods, the same as structs and unions.</span></span>
<span class=line><span class=tok-comment>// Enum methods are not special, they are only namespaced</span></span>
<span class=line><span class=tok-comment>// functions that you can call with dot syntax.</span></span>
<span class=line><span class=tok-kw>const</span> Suit = <span class=tok-kw>enum</span> {</span>
<span class=line>    clubs,</span>
<span class=line>    spades,</span>
<span class=line>    diamonds,</span>
<span class=line>    hearts,</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>isClubs</span>(self: Suit) <span class=tok-type>bool</span> {</span>
<span class=line>        <span class=tok-kw>return</span> self == Suit.clubs;</span>
<span class=line>    }</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"enum method"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> p = Suit.spades;</span>
<span class=line>    <span class=tok-kw>try</span> expect(!p.isClubs());</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// An enum variant of different types can be switched upon.</span></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>enum</span> {</span>
<span class=line>    string,</span>
<span class=line>    number,</span>
<span class=line>    none,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"enum variant switch"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> p = Foo.number;</span>
<span class=line>    <span class=tok-kw>const</span> what_is_it = <span class=tok-kw>switch</span> (p) {</span>
<span class=line>        Foo.string =&gt; <span class=tok-str>"this is a string"</span>,</span>
<span class=line>        Foo.number =&gt; <span class=tok-str>"this is a number"</span>,</span>
<span class=line>        Foo.none =&gt; <span class=tok-str>"this is a none"</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, what_is_it, <span class=tok-str>"this is a number"</span>));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// @typeInfo can be used to access the integer tag type of an enum.</span></span>
<span class=line><span class=tok-kw>const</span> Small = <span class=tok-kw>enum</span> {</span>
<span class=line>    one,</span>
<span class=line>    two,</span>
<span class=line>    three,</span>
<span class=line>    four,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"std.meta.Tag"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@typeInfo</span>(Small).Enum.tag_type == <span class=tok-type>u2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// @typeInfo tells us the field count and the fields names:</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"@typeInfo"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@typeInfo</span>(Small).Enum.fields.len == <span class=tok-number>4</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, <span class=tok-builtin>@typeInfo</span>(Small).Enum.fields[<span class=tok-number>1</span>].name, <span class=tok-str>"two"</span>));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// @tagName gives a [:0]const u8 representation of an enum value:</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"@tagName"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, <span class=tok-builtin>@tagName</span>(Small.three), <span class=tok-str>"three"</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test enums.zig</kbd></span>
<span class=line>1/7 test.enum ordinal value... OK</span>
<span class=line>2/7 test.set enum ordinal value... OK</span>
<span class=line>3/7 test.enum method... OK</span>
<span class=line>4/7 test.enum variant switch... OK</span>
<span class=line>5/7 test.std.meta.Tag... OK</span>
<span class=line>6/7 test.@typeInfo... OK</span>
<span class=line>7/7 test.@tagName... OK</span>
<span class=line>All 7 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#typeInfo>@typeInfo</a></li> <li><a href=#tagName>@tagName</a></li> <li><a href=#sizeOf>@sizeOf</a></li> </ul> <a name=//apple_ref/cpp/Keyword/extern%20enum class=dashAnchor></a><h3 id=extern-enum>extern enum</h3> <p> By default, enums are not guaranteed to be compatible with the C ABI: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>enum</span> { a, b, c };</span>
<span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>entry</span>(foo: Foo) <span class=tok-type>void</span> { _ = foo; }</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-obj test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:2:17: </span><span class=t31_1>error: </span><span class=t1_0>parameter of type 'test.Foo' not allowed in function with calling convention 'C'</span>
<span class=line></span>export fn entry(foo: Foo) void { _ = foo; }</span>
<span class=line>                <span class=t32_1>^~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:2:17: </span><span class=t36_1>note: </span><span class=t1_0>enum tag type 'u2' is not extern compatible</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:2:17: </span><span class=t36_1>note: </span><span class=t1_0>only integers with power of two bits are extern compatible</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:1:13: </span><span class=t36_1>note: </span><span class=t1_0>enum declared here</span>
<span class=line></span>const Foo = enum { a, b, c };</span>
<span class=line>            <span class=t32_1>^~~~~~~~~~~~~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p> For a C-ABI-compatible enum, provide an explicit tag type to the enum: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>enum</span>(<span class=tok-type>c_int</span>) { a, b, c };</span>
<span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>entry</span>(foo: Foo) <span class=tok-type>void</span> { _ = foo; }</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-obj test.zig</kbd></span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Enum%20Literals class=dashAnchor></a><h3 id=Enum-Literals>Enum Literals</h3> <p> Enum literals allow specifying the name of an enum field without specifying the enum type: </p> <figure><figcaption class=zig-cap><cite class=file>test_enum_literals.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Color = <span class=tok-kw>enum</span> {</span>
<span class=line>    auto,</span>
<span class=line>    off,</span>
<span class=line>    on,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"enum literals"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> color1: Color = .auto;</span>
<span class=line>    <span class=tok-kw>const</span> color2 = Color.auto;</span>
<span class=line>    <span class=tok-kw>try</span> expect(color1 == color2);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"switch using enum literals"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> color = Color.on;</span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>switch</span> (color) {</span>
<span class=line>        .auto =&gt; <span class=tok-null>false</span>,</span>
<span class=line>        .on =&gt; <span class=tok-null>true</span>,</span>
<span class=line>        .off =&gt; <span class=tok-null>false</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>try</span> expect(result);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_enum_literals.zig</kbd></span>
<span class=line>1/2 test.enum literals... OK</span>
<span class=line>2/2 test.switch using enum literals... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Non-exhaustive%20enum class=dashAnchor></a><h3 id=Non-exhaustive-enum>Non-exhaustive enum</h3> <p> A Non-exhaustive enum can be created by adding a trailing '_' field. It must specify a tag type and cannot consume every enumeration value. </p> <p> <a href=#intToEnum>@intToEnum</a> on a non-exhaustive enum involves the safety semantics of <a href=#intCast>@intCast</a> to the integer tag type, but beyond that always results in a well-defined enum value. </p> <p> A switch on a non-exhaustive enum can include a '_' prong as an alternative to an <code><span class=line><span class=tok-kw>else</span></span></code> prong with the difference being that it makes it a compile error if all the known tag names are not handled by the switch. </p> <figure><figcaption class=zig-cap><cite class=file>test_switch_non-exhaustive.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Number = <span class=tok-kw>enum</span>(<span class=tok-type>u8</span>) {</span>
<span class=line>    one,</span>
<span class=line>    two,</span>
<span class=line>    three,</span>
<span class=line>    _,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"switch on non-exhaustive enum"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> number = Number.one;</span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>switch</span> (number) {</span>
<span class=line>        .one =&gt; <span class=tok-null>true</span>,</span>
<span class=line>        .two,</span>
<span class=line>        .three =&gt; <span class=tok-null>false</span>,</span>
<span class=line>        _ =&gt; <span class=tok-null>false</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>try</span> expect(result);</span>
<span class=line>    <span class=tok-kw>const</span> is_one = <span class=tok-kw>switch</span> (number) {</span>
<span class=line>        .one =&gt; <span class=tok-null>true</span>,</span>
<span class=line>        <span class=tok-kw>else</span> =&gt; <span class=tok-null>false</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>try</span> expect(is_one);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_switch_non-exhaustive.zig</kbd></span>
<span class=line>1/1 test.switch on non-exhaustive enum... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Keyword/union class=dashAnchor></a><h2 id=union>union</h2> <p> A bare <code><span class=line><span class=tok-kw>union</span></span></code> defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use <a href=#ptrCast>@ptrCast</a>, or use an <a href=#extern-union>extern union</a> or a <a href=#packed-union>packed union</a> which have guaranteed in-memory layout. <a href=#Wrong-Union-Field-Access>Accessing the non-active field</a> is safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a>: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Payload = <span class=tok-kw>union</span> {</span>
<span class=line>    int: <span class=tok-type>i64</span>,</span>
<span class=line>    float: <span class=tok-type>f64</span>,</span>
<span class=line>    boolean: <span class=tok-type>bool</span>,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"simple union"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> payload = Payload{ .int = <span class=tok-number>1234</span> };</span>
<span class=line>    payload.float = <span class=tok-number>12.34</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.simple union... thread 1635198 panic: access of inactive union field</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:8:5</span>: <span class=t2_0>0x2115a1 in test.simple union (test)</span></span>
<span class=line>    payload.float = 12.34;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x212bb8 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x211e9b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x211961 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>error: the following test command crashed:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <p>You can activate another field by assigning the entire union:</p> <figure><figcaption class=zig-cap><cite class=file>test_simple_union.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Payload = <span class=tok-kw>union</span> {</span>
<span class=line>    int: <span class=tok-type>i64</span>,</span>
<span class=line>    float: <span class=tok-type>f64</span>,</span>
<span class=line>    boolean: <span class=tok-type>bool</span>,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"simple union"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> payload = Payload{ .int = <span class=tok-number>1234</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(payload.int == <span class=tok-number>1234</span>);</span>
<span class=line>    payload = Payload{ .float = <span class=tok-number>12.34</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(payload.float == <span class=tok-number>12.34</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_simple_union.zig</kbd></span>
<span class=line>1/1 test.simple union... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> In order to use <a href=#switch>switch</a> with a union, it must be a <a href=#Tagged-union>Tagged union</a>. </p> <p> To initialize a union when the tag is a <a href=#comptime>comptime</a>-known name, see <a href=#unionInit>@unionInit</a>. </p> <a name=//apple_ref/cpp/Guide/Tagged%20union class=dashAnchor></a><h3 id=Tagged-union>Tagged union</h3> <p>Unions can be declared with an enum tag type. This turns the union into a <em>tagged</em> union, which makes it eligible to use with <a href=#switch>switch</a> expressions. Tagged unions coerce to their tag type: <a href=#Type-Coercion-unions-and-enums>Type Coercion: unions and enums</a>. </p> <figure><figcaption class=zig-cap><cite class=file>test_switch_tagged_union.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> ComplexTypeTag = <span class=tok-kw>enum</span> {</span>
<span class=line>    ok,</span>
<span class=line>    not_ok,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> ComplexType = <span class=tok-kw>union</span>(ComplexTypeTag) {</span>
<span class=line>    ok: <span class=tok-type>u8</span>,</span>
<span class=line>    not_ok: <span class=tok-type>void</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"switch on tagged union"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> c = ComplexType{ .ok = <span class=tok-number>42</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@as</span>(ComplexTypeTag, c) == ComplexTypeTag.ok);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>switch</span> (c) {</span>
<span class=line>        ComplexTypeTag.ok =&gt; |value| <span class=tok-kw>try</span> expect(value == <span class=tok-number>42</span>),</span>
<span class=line>        ComplexTypeTag.not_ok =&gt; <span class=tok-kw>unreachable</span>,</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"get tag type"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.meta.Tag(ComplexType) == ComplexTypeTag);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"coerce to enum"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> c1 = ComplexType{ .ok = <span class=tok-number>42</span> };</span>
<span class=line>    <span class=tok-kw>const</span> c2 = ComplexType.not_ok;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(c1 == .ok);</span>
<span class=line>    <span class=tok-kw>try</span> expect(c2 == .not_ok);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_switch_tagged_union.zig</kbd></span>
<span class=line>1/3 test.switch on tagged union... OK</span>
<span class=line>2/3 test.get tag type... OK</span>
<span class=line>3/3 test.coerce to enum... OK</span>
<span class=line>All 3 tests passed.</span>
</samp></pre></figure> <p>In order to modify the payload of a tagged union in a switch expression, place a <code><span class=line>*</span></code> before the variable name to make it a pointer: </p> <figure><figcaption class=zig-cap><cite class=file>test_switch_modify_tagged_union.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> ComplexTypeTag = <span class=tok-kw>enum</span> {</span>
<span class=line>    ok,</span>
<span class=line>    not_ok,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> ComplexType = <span class=tok-kw>union</span>(ComplexTypeTag) {</span>
<span class=line>    ok: <span class=tok-type>u8</span>,</span>
<span class=line>    not_ok: <span class=tok-type>void</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"modify tagged union in switch"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> c = ComplexType{ .ok = <span class=tok-number>42</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@as</span>(ComplexTypeTag, c) == ComplexTypeTag.ok);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>switch</span> (c) {</span>
<span class=line>        ComplexTypeTag.ok =&gt; |*value| value.* += <span class=tok-number>1</span>,</span>
<span class=line>        ComplexTypeTag.not_ok =&gt; <span class=tok-kw>unreachable</span>,</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(c.ok == <span class=tok-number>43</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_switch_modify_tagged_union.zig</kbd></span>
<span class=line>1/1 test.modify tagged union in switch... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Unions can be made to infer the enum tag type. Further, unions can have methods just like structs and enums. </p> <figure><figcaption class=zig-cap><cite class=file>test_union_method.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Variant = <span class=tok-kw>union</span>(<span class=tok-kw>enum</span>) {</span>
<span class=line>    int: <span class=tok-type>i32</span>,</span>
<span class=line>    boolean: <span class=tok-type>bool</span>,</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// void can be omitted when inferring enum tag type.</span></span>
<span class=line>    none,</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>fn</span> <span class=tok-fn>truthy</span>(self: Variant) <span class=tok-type>bool</span> {</span>
<span class=line>        <span class=tok-kw>return</span> <span class=tok-kw>switch</span> (self) {</span>
<span class=line>            Variant.int =&gt; |x_int| x_int != <span class=tok-number>0</span>,</span>
<span class=line>            Variant.boolean =&gt; |x_bool| x_bool,</span>
<span class=line>            Variant.none =&gt; <span class=tok-null>false</span>,</span>
<span class=line>        };</span>
<span class=line>    }</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"union method"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> v1 = Variant{ .int = <span class=tok-number>1</span> };</span>
<span class=line>    <span class=tok-kw>var</span> v2 = Variant{ .boolean = <span class=tok-null>false</span> };</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(v1.truthy());</span>
<span class=line>    <span class=tok-kw>try</span> expect(!v2.truthy());</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_union_method.zig</kbd></span>
<span class=line>1/1 test.union method... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> <a href=#tagName>@tagName</a> can be used to return a <a href=#comptime>comptime</a> <code><span class=line>[:<span class=tok-number>0</span>]<span class=tok-kw>const</span> <span class=tok-type>u8</span></span></code> value representing the field name: </p> <figure><figcaption class=zig-cap><cite class=file>test_tagName.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Small2 = <span class=tok-kw>union</span>(<span class=tok-kw>enum</span>) {</span>
<span class=line>    a: <span class=tok-type>i32</span>,</span>
<span class=line>    b: <span class=tok-type>bool</span>,</span>
<span class=line>    c: <span class=tok-type>u8</span>,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"@tagName"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>u8</span>, <span class=tok-builtin>@tagName</span>(Small2.a), <span class=tok-str>"a"</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_tagName.zig</kbd></span>
<span class=line>1/1 test.@tagName... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Keyword/extern%20union class=dashAnchor></a><h3 id=extern-union>extern union</h3> <p> An <code><span class=line><span class=tok-kw>extern</span> <span class=tok-kw>union</span></span></code> has memory layout guaranteed to be compatible with the target C ABI. </p> <p>See also:</p><ul> <li><a href=#extern-struct>extern struct</a></li> </ul> <a name=//apple_ref/cpp/Keyword/packed%20union class=dashAnchor></a><h3 id=packed-union>packed union</h3> <p>A <code><span class=line><span class=tok-kw>packed</span> <span class=tok-kw>union</span></span></code> has well-defined in-memory layout and is eligible to be in a <a href=#packed-struct>packed struct</a>.</p> <a name=//apple_ref/cpp/Guide/Anonymous%20Union%20Literals class=dashAnchor></a><h3 id=Anonymous-Union-Literals>Anonymous Union Literals</h3> <p><a href=#Anonymous-Struct-Literals>Anonymous Struct Literals</a> syntax can be used to initialize unions without specifying the type:</p> <figure><figcaption class=zig-cap><cite class=file>anon_union.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Number = <span class=tok-kw>union</span> {</span>
<span class=line>    int: <span class=tok-type>i32</span>,</span>
<span class=line>    float: <span class=tok-type>f64</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"anonymous union literal syntax"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> i: Number = .{.int = <span class=tok-number>42</span>};</span>
<span class=line>    <span class=tok-kw>var</span> f = makeNumber();</span>
<span class=line>    <span class=tok-kw>try</span> expect(i.int == <span class=tok-number>42</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(f.float == <span class=tok-number>12.34</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>makeNumber</span>() Number {</span>
<span class=line>    <span class=tok-kw>return</span> .{.float = <span class=tok-number>12.34</span>};</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test anon_union.zig</kbd></span>
<span class=line>1/1 test.anonymous union literal syntax... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Keyword/opaque class=dashAnchor></a><h2 id=opaque>opaque</h2> <p> <code><span class=line><span class=tok-kw>opaque</span> {}</span></code> declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as <a href=#struct>structs</a>, <a href=#union>unions</a>, and <a href=#enum>enums</a>. </p> <p> This is typically used for type safety when interacting with C code that does not expose struct details. Example: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Derp = <span class=tok-kw>opaque</span> {};</span>
<span class=line><span class=tok-kw>const</span> Wat = <span class=tok-kw>opaque</span> {};</span>
<span class=line></span>
<span class=line><span class=tok-kw>extern</span> <span class=tok-kw>fn</span> <span class=tok-fn>bar</span>(d: *Derp) <span class=tok-type>void</span>;</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(w: *Wat) <span class=tok-kw>callconv</span>(.C) <span class=tok-type>void</span> {</span>
<span class=line>    bar(w);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"call foo"</span> {</span>
<span class=line>    foo(<span class=tok-null>undefined</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:6:9: </span><span class=t31_1>error: </span><span class=t1_0>expected type '*test.Derp', found '*test.Wat'</span>
<span class=line></span>    bar(w);</span>
<span class=line>        <span class=t32_1>^</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:6:9: </span><span class=t36_1>note: </span><span class=t1_0>pointer type child 'test.Wat' cannot cast into pointer type child 'test.Derp'</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:2:13: </span><span class=t36_1>note: </span><span class=t1_0>opaque declared here</span>
<span class=line></span>const Wat = opaque {};</span>
<span class=line>            <span class=t32_1>^~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:1:14: </span><span class=t36_1>note: </span><span class=t1_0>opaque declared here</span>
<span class=line></span>const Derp = opaque {};</span>
<span class=line>             <span class=t32_1>^~~~~~~~~</span>
<span class=line></span><span class=t2_0>referenced by:</span>
<span class=line>    test.call foo: docgen_tmp/test.zig:10:5</span>
<span class=line>    remaining reference traces hidden; use '-freference-trace' to see all reference traces</span>
<span class=line></span>
<span class=line></span></span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Blocks class=dashAnchor></a><h2 id=Blocks>Blocks</h2> <p> Blocks are used to limit the scope of variable declarations: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"access variable after block scope"</span> {</span>
<span class=line>    {</span>
<span class=line>        <span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1</span>;</span>
<span class=line>        _ = x;</span>
<span class=line>    }</span>
<span class=line>    x += <span class=tok-number>1</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:6:5: </span><span class=t31_1>error: </span><span class=t1_0>use of undeclared identifier 'x'</span>
<span class=line></span>    x += 1;</span>
<span class=line>    <span class=t32_1>^</span>
<span class=line></span></span>
</samp></pre></figure> <p>Blocks are expressions. When labeled, <code><span class=line><span class=tok-kw>break</span></span></code> can be used to return a value from the block: </p> <figure><figcaption class=zig-cap><cite class=file>test_labeled_break.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"labeled break from labeled block expression"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> y: <span class=tok-type>i32</span> = <span class=tok-number>123</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> x = blk: {</span>
<span class=line>        y += <span class=tok-number>1</span>;</span>
<span class=line>        <span class=tok-kw>break</span> :blk y;</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>try</span> expect(x == <span class=tok-number>124</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(y == <span class=tok-number>124</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_labeled_break.zig</kbd></span>
<span class=line>1/1 test.labeled break from labeled block expression... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>Here, <code><span class=line>blk</span></code> can be any name.</p> <p>See also:</p><ul> <li><a href=#Labeled-while>Labeled while</a></li> <li><a href=#Labeled-for>Labeled for</a></li> </ul> <a name=//apple_ref/cpp/Guide/Shadowing class=dashAnchor></a><h3 id=Shadowing>Shadowing</h3> <p><a href=#Identifiers>Identifiers</a> are never allowed to "hide" other identifiers by using the same name:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> pi = <span class=tok-number>3.14</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"inside test block"</span> {</span>
<span class=line>    <span class=tok-comment>// Let's even go inside another block</span></span>
<span class=line>    {</span>
<span class=line>        <span class=tok-kw>var</span> pi: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:6:13: </span><span class=t31_1>error: </span><span class=t1_0>local variable shadows declaration of 'pi'</span>
<span class=line></span>        var pi: i32 = 1234;</span>
<span class=line>            <span class=t32_1>^~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:1:1: </span><span class=t36_1>note: </span><span class=t1_0>declared here</span>
<span class=line></span>const pi = 3.14;</span>
<span class=line><span class=t32_1>^~~~~~~~~~~~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p> Because of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing within the scope it is defined. Note that you can, however, use the same name if the scopes are separate: </p> <figure><figcaption class=zig-cap><cite class=file>test_scopes.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"separate scopes"</span> {</span>
<span class=line>    {</span>
<span class=line>        <span class=tok-kw>const</span> pi = <span class=tok-number>3.14</span>;</span>
<span class=line>        _ = pi;</span>
<span class=line>    }</span>
<span class=line>    {</span>
<span class=line>        <span class=tok-kw>var</span> pi: <span class=tok-type>bool</span> = <span class=tok-null>true</span>;</span>
<span class=line>        _ = pi;</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_scopes.zig</kbd></span>
<span class=line>1/1 test.separate scopes... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Empty%20Blocks class=dashAnchor></a><h3 id=Empty-Blocks>Empty Blocks</h3> <p>An empty block is equivalent to <code><span class=line><span class=tok-type>void</span>{}</span></code>:</p> <figure><figcaption class=zig-cap><cite class=file>empty_block.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> {</span>
<span class=line>    <span class=tok-kw>const</span> a = {};</span>
<span class=line>    <span class=tok-kw>const</span> b = <span class=tok-type>void</span>{};</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(a) == <span class=tok-type>void</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(b) == <span class=tok-type>void</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(a == b);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test empty_block.zig</kbd></span>
<span class=line>1/1 test_0... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Keyword/switch class=dashAnchor></a><h2 id=switch>switch</h2> <figure><figcaption class=zig-cap><cite class=file>switch.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> builtin = <span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"switch simple"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> a: <span class=tok-type>u64</span> = <span class=tok-number>10</span>;</span>
<span class=line>    <span class=tok-kw>const</span> zz: <span class=tok-type>u64</span> = <span class=tok-number>103</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// All branches of a switch expression must be able to be coerced to a</span></span>
<span class=line>    <span class=tok-comment>// common type.</span></span>
<span class=line>    <span class=tok-comment>//</span></span>
<span class=line>    <span class=tok-comment>// Branches cannot fallthrough. If fallthrough behavior is desired, combine</span></span>
<span class=line>    <span class=tok-comment>// the cases and use an if.</span></span>
<span class=line>    <span class=tok-kw>const</span> b = <span class=tok-kw>switch</span> (a) {</span>
<span class=line>        <span class=tok-comment>// Multiple cases can be combined via a ','</span></span>
<span class=line>        <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span> =&gt; <span class=tok-number>0</span>,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// Ranges can be specified using the ... syntax. These are inclusive</span></span>
<span class=line>        <span class=tok-comment>// of both ends.</span></span>
<span class=line>        <span class=tok-number>5</span>...<span class=tok-number>100</span> =&gt; <span class=tok-number>1</span>,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// Branches can be arbitrarily complex.</span></span>
<span class=line>        <span class=tok-number>101</span> =&gt; blk: {</span>
<span class=line>            <span class=tok-kw>const</span> c: <span class=tok-type>u64</span> = <span class=tok-number>5</span>;</span>
<span class=line>            <span class=tok-kw>break</span> :blk c * <span class=tok-number>2</span> + <span class=tok-number>1</span>;</span>
<span class=line>        },</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// Switching on arbitrary expressions is allowed as long as the</span></span>
<span class=line>        <span class=tok-comment>// expression is known at compile-time.</span></span>
<span class=line>        zz =&gt; zz,</span>
<span class=line>        blk: {</span>
<span class=line>            <span class=tok-kw>const</span> d: <span class=tok-type>u32</span> = <span class=tok-number>5</span>;</span>
<span class=line>            <span class=tok-kw>const</span> e: <span class=tok-type>u32</span> = <span class=tok-number>100</span>;</span>
<span class=line>            <span class=tok-kw>break</span> :blk d + e;</span>
<span class=line>        } =&gt; <span class=tok-number>107</span>,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// The else branch catches everything not already captured.</span></span>
<span class=line>        <span class=tok-comment>// Else branches are mandatory unless the entire range of values</span></span>
<span class=line>        <span class=tok-comment>// is handled.</span></span>
<span class=line>        <span class=tok-kw>else</span> =&gt; <span class=tok-number>9</span>,</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(b == <span class=tok-number>1</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Switch expressions can be used outside a function:</span></span>
<span class=line><span class=tok-kw>const</span> os_msg = <span class=tok-kw>switch</span> (builtin.target.os.tag) {</span>
<span class=line>    .linux =&gt; <span class=tok-str>"we found a linux user"</span>,</span>
<span class=line>    <span class=tok-kw>else</span> =&gt; <span class=tok-str>"not a linux user"</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Inside a function, switch statements implicitly are compile-time</span></span>
<span class=line><span class=tok-comment>// evaluated if the target expression is compile-time known.</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"switch inside function"</span> {</span>
<span class=line>    <span class=tok-kw>switch</span> (builtin.target.os.tag) {</span>
<span class=line>        .fuchsia =&gt; {</span>
<span class=line>            <span class=tok-comment>// On an OS other than fuchsia, block is not even analyzed,</span></span>
<span class=line>            <span class=tok-comment>// so this compile error is not triggered.</span></span>
<span class=line>            <span class=tok-comment>// On fuchsia this compile error would be triggered.</span></span>
<span class=line>            <span class=tok-builtin>@compileError</span>(<span class=tok-str>"fuchsia not supported"</span>);</span>
<span class=line>        },</span>
<span class=line>        <span class=tok-kw>else</span> =&gt; {},</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test switch.zig</kbd></span>
<span class=line>1/2 test.switch simple... OK</span>
<span class=line>2/2 test.switch inside function... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <p> <code><span class=line><span class=tok-kw>switch</span></span></code> can be used to capture the field values of a <a href=#Tagged-union>Tagged union</a>. Modifications to the field values can be done by placing a <code><span class=line>*</span></code> before the capture variable name, turning it into a pointer. </p> <figure><figcaption class=zig-cap><cite class=file>test_switch_tagged_union.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"switch on tagged union"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> Point = <span class=tok-kw>struct</span> {</span>
<span class=line>        x: <span class=tok-type>u8</span>,</span>
<span class=line>        y: <span class=tok-type>u8</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>const</span> Item = <span class=tok-kw>union</span>(<span class=tok-kw>enum</span>) {</span>
<span class=line>        a: <span class=tok-type>u32</span>,</span>
<span class=line>        c: Point,</span>
<span class=line>        d,</span>
<span class=line>        e: <span class=tok-type>u32</span>,</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> a = Item{ .c = Point{ .x = <span class=tok-number>1</span>, .y = <span class=tok-number>2</span> } };</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Switching on more complex enums is allowed.</span></span>
<span class=line>    <span class=tok-kw>const</span> b = <span class=tok-kw>switch</span> (a) {</span>
<span class=line>        <span class=tok-comment>// A capture group is allowed on a match, and will return the enum</span></span>
<span class=line>        <span class=tok-comment>// value matched. If the payload types of both cases are the same</span></span>
<span class=line>        <span class=tok-comment>// they can be put into the same switch prong.</span></span>
<span class=line>        Item.a, Item.e =&gt; |item| item,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// A reference to the matched value can be obtained using `*` syntax.</span></span>
<span class=line>        Item.c =&gt; |*item| blk: {</span>
<span class=line>            item.*.x += <span class=tok-number>1</span>;</span>
<span class=line>            <span class=tok-kw>break</span> :blk <span class=tok-number>6</span>;</span>
<span class=line>        },</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// No else is required if the types cases was exhaustively handled</span></span>
<span class=line>        Item.d =&gt; <span class=tok-number>8</span>,</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(b == <span class=tok-number>6</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(a.c.x == <span class=tok-number>2</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_switch_tagged_union.zig</kbd></span>
<span class=line>1/1 test.switch on tagged union... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#comptime>comptime</a></li> <li><a href=#enum>enum</a></li> <li><a href=#compileError>@compileError</a></li> <li><a href=#Compile-Variables>Compile Variables</a></li> </ul> <a name=//apple_ref/cpp/Guide/Exhaustive%20Switching class=dashAnchor></a><h3 id=Exhaustive-Switching>Exhaustive Switching</h3> <p> When a <code><span class=line><span class=tok-kw>switch</span></span></code> expression does not have an <code><span class=line><span class=tok-kw>else</span></span></code> clause, it must exhaustively list all the possible values. Failure to do so is a compile error: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Color = <span class=tok-kw>enum</span> {</span>
<span class=line>    auto,</span>
<span class=line>    off,</span>
<span class=line>    on,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"exhaustive switching"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> color = Color.off;</span>
<span class=line>    <span class=tok-kw>switch</span> (color) {</span>
<span class=line>        Color.auto =&gt; {},</span>
<span class=line>        Color.on =&gt; {},</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:9:5: </span><span class=t31_1>error: </span><span class=t1_0>switch must handle all possibilities</span>
<span class=line></span>    switch (color) {</span>
<span class=line>    <span class=t32_1>^~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:3:5: </span><span class=t36_1>note: </span><span class=t1_0>unhandled enumeration value: 'off'</span>
<span class=line></span>    off,</span>
<span class=line>    <span class=t32_1>^~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:1:15: </span><span class=t36_1>note: </span><span class=t1_0>enum 'test.Color' declared here</span>
<span class=line></span>const Color = enum {</span>
<span class=line>              <span class=t32_1>^~~~</span>
<span class=line></span></span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Switching%20with%20Enum%20Literals class=dashAnchor></a><h3 id=Switching-with-Enum-Literals>Switching with Enum Literals</h3> <p> <a href=#Enum-Literals>Enum Literals</a> can be useful to use with <code><span class=line><span class=tok-kw>switch</span></span></code> to avoid repetitively specifying <a href=#enum>enum</a> or <a href=#union>union</a> types: </p> <figure><figcaption class=zig-cap><cite class=file>test_exhaustive_switch.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Color = <span class=tok-kw>enum</span> {</span>
<span class=line>    auto,</span>
<span class=line>    off,</span>
<span class=line>    on,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"enum literals with switch"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> color = Color.off;</span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>switch</span> (color) {</span>
<span class=line>        .auto =&gt; <span class=tok-null>false</span>,</span>
<span class=line>        .on =&gt; <span class=tok-null>false</span>,</span>
<span class=line>        .off =&gt; <span class=tok-null>true</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>try</span> expect(result);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_exhaustive_switch.zig</kbd></span>
<span class=line>1/1 test.enum literals with switch... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Inline%20switch class=dashAnchor></a><h3 id=Inline-switch>Inline switch</h3> <p> Switch prongs can be marked as <code><span class=line><span class=tok-kw>inline</span></span></code> to generate the prong's body for each possible value it could have: </p> <figure><figcaption class=zig-cap><cite class=file>test_inline_switch.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line><span class=tok-kw>const</span> expectError = std.testing.expectError;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>isFieldOptional</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, field_index: <span class=tok-type>usize</span>) !<span class=tok-type>bool</span> {</span>
<span class=line>    <span class=tok-kw>const</span> fields = <span class=tok-builtin>@typeInfo</span>(T).Struct.fields;</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>switch</span> (field_index) {</span>
<span class=line>        <span class=tok-comment>// This prong is analyzed `fields.len - 1` times with `idx` being an</span></span>
<span class=line>        <span class=tok-comment>// unique comptime known value each time.</span></span>
<span class=line>        <span class=tok-kw>inline</span> <span class=tok-number>0</span>...fields.len - <span class=tok-number>1</span> =&gt; |idx| <span class=tok-builtin>@typeInfo</span>(fields[idx].field_type) == .Optional,</span>
<span class=line>        <span class=tok-kw>else</span> =&gt; <span class=tok-kw>return</span> <span class=tok-kw>error</span>.IndexOutOfBounds,</span>
<span class=line>    };</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Struct1 = <span class=tok-kw>struct</span> { a: <span class=tok-type>u32</span>, b: ?<span class=tok-type>u32</span> };</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"using @typeInfo with runtime values"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> index: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(!<span class=tok-kw>try</span> isFieldOptional(Struct1, index));</span>
<span class=line>    index += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-kw>try</span> isFieldOptional(Struct1, index));</span>
<span class=line>    index += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expectError(<span class=tok-kw>error</span>.IndexOutOfBounds, isFieldOptional(Struct1, index));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Calls to `isFieldOptional` on `Struct1` get unrolled to an equivalent</span></span>
<span class=line><span class=tok-comment>// of this function: </span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>isFieldOptionalUnrolled</span>(field_index: <span class=tok-type>usize</span>) !<span class=tok-type>bool</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>switch</span> (field_index) {</span>
<span class=line>        <span class=tok-number>0</span> =&gt; <span class=tok-null>false</span>,</span>
<span class=line>        <span class=tok-number>1</span> =&gt; <span class=tok-null>true</span>,</span>
<span class=line>        <span class=tok-kw>else</span> =&gt; <span class=tok-kw>return</span> <span class=tok-kw>error</span>.IndexOutOfBounds,</span>
<span class=line>    };</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_inline_switch.zig</kbd></span>
<span class=line>1/1 test.using @typeInfo with runtime values... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> <code><span class=line><span class=tok-kw>inline</span> <span class=tok-kw>else</span></span></code> prongs can be used as a type safe alternative to <code><span class=line><span class=tok-kw>inline</span> <span class=tok-kw>for</span></span></code> loops: </p> <figure><figcaption class=zig-cap><cite class=file>test_inline_else.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> SliceTypeA = <span class=tok-kw>extern</span> <span class=tok-kw>struct</span> {</span>
<span class=line>    len: <span class=tok-type>usize</span>,</span>
<span class=line>    ptr: [*]<span class=tok-type>u32</span>,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> SliceTypeB = <span class=tok-kw>extern</span> <span class=tok-kw>struct</span> {</span>
<span class=line>    ptr: [*]SliceTypeA,</span>
<span class=line>    len: <span class=tok-type>usize</span>,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> AnySlice = <span class=tok-kw>union</span>(<span class=tok-kw>enum</span>) {</span>
<span class=line>    a: SliceTypeA,</span>
<span class=line>    b: SliceTypeB,</span>
<span class=line>    c: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>,</span>
<span class=line>    d: []AnySlice,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>withFor</span>(any: AnySlice) <span class=tok-type>usize</span> {</span>
<span class=line>    <span class=tok-kw>const</span> Tag = <span class=tok-builtin>@typeInfo</span>(AnySlice).Union.tag_type.?;</span>
<span class=line>    <span class=tok-kw>inline</span> <span class=tok-kw>for</span> (<span class=tok-builtin>@typeInfo</span>(Tag).Enum.fields) |field| {</span>
<span class=line>        <span class=tok-comment>// With `inline for` the function gets generated as</span></span>
<span class=line>        <span class=tok-comment>// a series of `if` statements relying on the optimizer</span></span>
<span class=line>        <span class=tok-comment>// to convert it to a switch.</span></span>
<span class=line>        <span class=tok-kw>if</span> (field.value == <span class=tok-builtin>@enumToInt</span>(any)) {</span>
<span class=line>            <span class=tok-kw>return</span> <span class=tok-builtin>@field</span>(any, field.name).len;</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-comment>// When using `inline for` the compiler doesn't know that every</span></span>
<span class=line>    <span class=tok-comment>// possible case has been handled requiring an explicit `unreachable`.</span></span>
<span class=line>    <span class=tok-kw>unreachable</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>withSwitch</span>(any: AnySlice) <span class=tok-type>usize</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>switch</span> (any) {</span>
<span class=line>        <span class=tok-comment>// With `inline else` the function is explicitly generated</span></span>
<span class=line>        <span class=tok-comment>// as the desired switch and the compiler can check that</span></span>
<span class=line>        <span class=tok-comment>// every possible case is handled.</span></span>
<span class=line>        <span class=tok-kw>inline</span> <span class=tok-kw>else</span> =&gt; |slice| slice.len,</span>
<span class=line>    };</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"inline for and inline else similarity"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> any = AnySlice{ .c = <span class=tok-str>"hello"</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(withFor(any) == <span class=tok-number>5</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(withSwitch(any) == <span class=tok-number>5</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_inline_else.zig</kbd></span>
<span class=line>1/1 test.inline for and inline else similarity... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> When using an inline prong switching on an union an additional capture can be used to obtain the union's enum tag value. </p> <figure><figcaption class=zig-cap><cite class=file>test_inline_switch_union_tag.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> U = <span class=tok-kw>union</span>(<span class=tok-kw>enum</span>) {</span>
<span class=line>    a: <span class=tok-type>u32</span>,</span>
<span class=line>    b: <span class=tok-type>f32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>getNum</span>(u: U) <span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>switch</span> (u) {</span>
<span class=line>        <span class=tok-comment>// Here `num` is a runtime known value that is either</span></span>
<span class=line>        <span class=tok-comment>// `u.a` or `u.b` and `tag` is `u`'s comptime known tag value.</span></span>
<span class=line>        <span class=tok-kw>inline</span> <span class=tok-kw>else</span> =&gt; |num, tag| {</span>
<span class=line>            <span class=tok-kw>if</span> (tag == .b) {</span>
<span class=line>                <span class=tok-kw>return</span> <span class=tok-builtin>@floatToInt</span>(<span class=tok-type>u32</span>, num);</span>
<span class=line>            }</span>
<span class=line>            <span class=tok-kw>return</span> num;</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"test"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> u = U{ .b = <span class=tok-number>42</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(getNum(u) == <span class=tok-number>42</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_inline_switch_union_tag.zig</kbd></span>
<span class=line>1/1 test.test... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#inline-while>inline while</a></li> <li><a href=#inline-for>inline for</a></li> </ul> <a name=//apple_ref/cpp/Keyword/while class=dashAnchor></a><h2 id=while>while</h2> <p> A while loop is used to repeatedly execute an expression until some condition is no longer true. </p> <figure><figcaption class=zig-cap><cite class=file>while.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"while basic"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> i: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>while</span> (i &lt; <span class=tok-number>10</span>) {</span>
<span class=line>        i += <span class=tok-number>1</span>;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(i == <span class=tok-number>10</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test while.zig</kbd></span>
<span class=line>1/1 test.while basic... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Use <code><span class=line><span class=tok-kw>break</span></span></code> to exit a while loop early. </p> <figure><figcaption class=zig-cap><cite class=file>while.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"while break"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> i: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>while</span> (<span class=tok-null>true</span>) {</span>
<span class=line>        <span class=tok-kw>if</span> (i == <span class=tok-number>10</span>)</span>
<span class=line>            <span class=tok-kw>break</span>;</span>
<span class=line>        i += <span class=tok-number>1</span>;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(i == <span class=tok-number>10</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test while.zig</kbd></span>
<span class=line>1/1 test.while break... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Use <code><span class=line><span class=tok-kw>continue</span></span></code> to jump back to the beginning of the loop. </p> <figure><figcaption class=zig-cap><cite class=file>while.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"while continue"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> i: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>while</span> (<span class=tok-null>true</span>) {</span>
<span class=line>        i += <span class=tok-number>1</span>;</span>
<span class=line>        <span class=tok-kw>if</span> (i &lt; <span class=tok-number>10</span>)</span>
<span class=line>            <span class=tok-kw>continue</span>;</span>
<span class=line>        <span class=tok-kw>break</span>;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(i == <span class=tok-number>10</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test while.zig</kbd></span>
<span class=line>1/1 test.while continue... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> While loops support a continue expression which is executed when the loop is continued. The <code><span class=line><span class=tok-kw>continue</span></span></code> keyword respects this expression. </p> <figure><figcaption class=zig-cap><cite class=file>while.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"while loop continue expression"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> i: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>while</span> (i &lt; <span class=tok-number>10</span>) : (i += <span class=tok-number>1</span>) {}</span>
<span class=line>    <span class=tok-kw>try</span> expect(i == <span class=tok-number>10</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"while loop continue expression, more complicated"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> i: <span class=tok-type>usize</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>var</span> j: <span class=tok-type>usize</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>while</span> (i * j &lt; <span class=tok-number>2000</span>) : ({ i *= <span class=tok-number>2</span>; j *= <span class=tok-number>3</span>; }) {</span>
<span class=line>        <span class=tok-kw>const</span> my_ij = i * j;</span>
<span class=line>        <span class=tok-kw>try</span> expect(my_ij &lt; <span class=tok-number>2000</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test while.zig</kbd></span>
<span class=line>1/2 test.while loop continue expression... OK</span>
<span class=line>2/2 test.while loop continue expression, more complicated... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <p> While loops are expressions. The result of the expression is the result of the <code><span class=line><span class=tok-kw>else</span></span></code> clause of a while loop, which is executed when the condition of the while loop is tested as false. </p> <p> <code><span class=line><span class=tok-kw>break</span></span></code>, like <code><span class=line><span class=tok-kw>return</span></span></code>, accepts a value parameter. This is the result of the <code><span class=line><span class=tok-kw>while</span></span></code> expression. When you <code><span class=line><span class=tok-kw>break</span></span></code> from a while loop, the <code><span class=line><span class=tok-kw>else</span></span></code> branch is not evaluated. </p> <figure><figcaption class=zig-cap><cite class=file>while.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"while else"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(rangeHasNumber(<span class=tok-number>0</span>, <span class=tok-number>10</span>, <span class=tok-number>5</span>));</span>
<span class=line>    <span class=tok-kw>try</span> expect(!rangeHasNumber(<span class=tok-number>0</span>, <span class=tok-number>10</span>, <span class=tok-number>15</span>));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>rangeHasNumber</span>(begin: <span class=tok-type>usize</span>, end: <span class=tok-type>usize</span>, number: <span class=tok-type>usize</span>) <span class=tok-type>bool</span> {</span>
<span class=line>    <span class=tok-kw>var</span> i = begin;</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>while</span> (i &lt; end) : (i += <span class=tok-number>1</span>) {</span>
<span class=line>        <span class=tok-kw>if</span> (i == number) {</span>
<span class=line>            <span class=tok-kw>break</span> <span class=tok-null>true</span>;</span>
<span class=line>        }</span>
<span class=line>    } <span class=tok-kw>else</span> <span class=tok-null>false</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test while.zig</kbd></span>
<span class=line>1/1 test.while else... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Labeled%20while class=dashAnchor></a><h3 id=Labeled-while>Labeled while</h3> <p>When a <code><span class=line><span class=tok-kw>while</span></span></code> loop is labeled, it can be referenced from a <code><span class=line><span class=tok-kw>break</span></span></code> or <code><span class=line><span class=tok-kw>continue</span></span></code> from within a nested loop:</p> <figure><figcaption class=zig-cap><cite class=file>test_nested_break.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"nested break"</span> {</span>
<span class=line>    outer: <span class=tok-kw>while</span> (<span class=tok-null>true</span>) {</span>
<span class=line>        <span class=tok-kw>while</span> (<span class=tok-null>true</span>) {</span>
<span class=line>            <span class=tok-kw>break</span> :outer;</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"nested continue"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> i: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    outer: <span class=tok-kw>while</span> (i &lt; <span class=tok-number>10</span>) : (i += <span class=tok-number>1</span>) {</span>
<span class=line>        <span class=tok-kw>while</span> (<span class=tok-null>true</span>) {</span>
<span class=line>            <span class=tok-kw>continue</span> :outer;</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_nested_break.zig</kbd></span>
<span class=line>1/2 test.nested break... OK</span>
<span class=line>2/2 test.nested continue... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/while%20with%20Optionals class=dashAnchor></a><h3 id=while-with-Optionals>while with Optionals</h3> <p> Just like <a href=#if>if</a> expressions, while loops can take an optional as the condition and capture the payload. When <a href=#null>null</a> is encountered the loop exits. </p> <p> When the <code><span class=line>|x|</span></code> syntax is present on a <code><span class=line><span class=tok-kw>while</span></span></code> expression, the while condition must have an <a href=#Optional-Type>Optional Type</a>. </p> <p> The <code><span class=line><span class=tok-kw>else</span></span></code> branch is allowed on optional iteration. In this case, it will be executed on the first null value encountered. </p> <figure><figcaption class=zig-cap><cite class=file>while.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"while null capture"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> sum1: <span class=tok-type>u32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    numbers_left = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>while</span> (eventuallyNullSequence()) |value| {</span>
<span class=line>        sum1 += value;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(sum1 == <span class=tok-number>3</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> sum2: <span class=tok-type>u32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    numbers_left = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>while</span> (eventuallyNullSequence()) |value| {</span>
<span class=line>        sum2 += value;</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        <span class=tok-kw>try</span> expect(sum2 == <span class=tok-number>3</span>);</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> numbers_left: <span class=tok-type>u32</span> = <span class=tok-null>undefined</span>;</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>eventuallyNullSequence</span>() ?<span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>if</span> (numbers_left == <span class=tok-number>0</span>) <span class=tok-null>null</span> <span class=tok-kw>else</span> blk: {</span>
<span class=line>        numbers_left -= <span class=tok-number>1</span>;</span>
<span class=line>        <span class=tok-kw>break</span> :blk numbers_left;</span>
<span class=line>    };</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test while.zig</kbd></span>
<span class=line>1/1 test.while null capture... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/while%20with%20Error%20Unions class=dashAnchor></a><h3 id=while-with-Error-Unions>while with Error Unions</h3> <p> Just like <a href=#if>if</a> expressions, while loops can take an error union as the condition and capture the payload or the error code. When the condition results in an error code the else branch is evaluated and the loop is finished. </p> <p> When the <code><span class=line><span class=tok-kw>else</span> |x|</span></code> syntax is present on a <code><span class=line><span class=tok-kw>while</span></span></code> expression, the while condition must have an <a href=#Error-Union-Type>Error Union Type</a>. </p> <figure><figcaption class=zig-cap><cite class=file>while.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"while error union capture"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> sum1: <span class=tok-type>u32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    numbers_left = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>while</span> (eventuallyErrorSequence()) |value| {</span>
<span class=line>        sum1 += value;</span>
<span class=line>    } <span class=tok-kw>else</span> |err| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(err == <span class=tok-kw>error</span>.ReachedZero);</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> numbers_left: <span class=tok-type>u32</span> = <span class=tok-null>undefined</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>eventuallyErrorSequence</span>() <span class=tok-type>anyerror</span>!<span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>if</span> (numbers_left == <span class=tok-number>0</span>) <span class=tok-kw>error</span>.ReachedZero <span class=tok-kw>else</span> blk: {</span>
<span class=line>        numbers_left -= <span class=tok-number>1</span>;</span>
<span class=line>        <span class=tok-kw>break</span> :blk numbers_left;</span>
<span class=line>    };</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test while.zig</kbd></span>
<span class=line>1/1 test.while error union capture... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Keyword/inline%20while class=dashAnchor></a><h3 id=inline-while>inline while</h3> <p> While loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. </p> <figure><figcaption class=zig-cap><cite class=file>test_inline_while.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"inline while loop"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>var</span> i = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>var</span> sum: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>inline</span> <span class=tok-kw>while</span> (i &lt; <span class=tok-number>3</span>) : (i += <span class=tok-number>1</span>) {</span>
<span class=line>        <span class=tok-kw>const</span> T = <span class=tok-kw>switch</span> (i) {</span>
<span class=line>            <span class=tok-number>0</span> =&gt; <span class=tok-type>f32</span>,</span>
<span class=line>            <span class=tok-number>1</span> =&gt; <span class=tok-type>i8</span>,</span>
<span class=line>            <span class=tok-number>2</span> =&gt; <span class=tok-type>bool</span>,</span>
<span class=line>            <span class=tok-kw>else</span> =&gt; <span class=tok-kw>unreachable</span>,</span>
<span class=line>        };</span>
<span class=line>        sum += typeNameLength(T);</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(sum == <span class=tok-number>9</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>typeNameLength</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>) <span class=tok-type>usize</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-builtin>@typeName</span>(T).len;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_inline_while.zig</kbd></span>
<span class=line>1/1 test.inline while loop... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> It is recommended to use <code><span class=line><span class=tok-kw>inline</span></span></code> loops only for one of these reasons: </p> <ul> <li>You need the loop to execute at <a href=#comptime>comptime</a> for the semantics to work.</li> <li> You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster. </li> </ul> <p>See also:</p><ul> <li><a href=#if>if</a></li> <li><a href=#Optionals>Optionals</a></li> <li><a href=#Errors>Errors</a></li> <li><a href=#comptime>comptime</a></li> <li><a href=#unreachable>unreachable</a></li> </ul> <a name=//apple_ref/cpp/Keyword/for class=dashAnchor></a><h2 id=for>for</h2> <figure><figcaption class=zig-cap><cite class=file>for.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"for basics"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> items = [_]<span class=tok-type>i32</span> { <span class=tok-number>4</span>, <span class=tok-number>5</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span>, <span class=tok-number>0</span> };</span>
<span class=line>    <span class=tok-kw>var</span> sum: <span class=tok-type>i32</span> = <span class=tok-number>0</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// For loops iterate over slices and arrays.</span></span>
<span class=line>    <span class=tok-kw>for</span> (items) |value| {</span>
<span class=line>        <span class=tok-comment>// Break and continue are supported.</span></span>
<span class=line>        <span class=tok-kw>if</span> (value == <span class=tok-number>0</span>) {</span>
<span class=line>            <span class=tok-kw>continue</span>;</span>
<span class=line>        }</span>
<span class=line>        sum += value;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(sum == <span class=tok-number>16</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// To iterate over a portion of a slice, reslice.</span></span>
<span class=line>    <span class=tok-kw>for</span> (items[<span class=tok-number>0</span>..<span class=tok-number>1</span>]) |value| {</span>
<span class=line>        sum += value;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(sum == <span class=tok-number>20</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// To access the index of iteration, specify a second capture value.</span></span>
<span class=line>    <span class=tok-comment>// This is zero-indexed.</span></span>
<span class=line>    <span class=tok-kw>var</span> sum2: <span class=tok-type>i32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>for</span> (items) |_, i| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(i) == <span class=tok-type>usize</span>);</span>
<span class=line>        sum2 += <span class=tok-builtin>@intCast</span>(<span class=tok-type>i32</span>, i);</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(sum2 == <span class=tok-number>10</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"for reference"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> items = [_]<span class=tok-type>i32</span> { <span class=tok-number>3</span>, <span class=tok-number>4</span>, <span class=tok-number>2</span> };</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Iterate over the slice by reference by</span></span>
<span class=line>    <span class=tok-comment>// specifying that the capture value is a pointer.</span></span>
<span class=line>    <span class=tok-kw>for</span> (items) |*value| {</span>
<span class=line>        value.* += <span class=tok-number>1</span>;</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(items[<span class=tok-number>0</span>] == <span class=tok-number>4</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(items[<span class=tok-number>1</span>] == <span class=tok-number>5</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(items[<span class=tok-number>2</span>] == <span class=tok-number>3</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"for else"</span> {</span>
<span class=line>    <span class=tok-comment>// For allows an else attached to it, the same as a while loop.</span></span>
<span class=line>    <span class=tok-kw>var</span> items = [_]?<span class=tok-type>i32</span> { <span class=tok-number>3</span>, <span class=tok-number>4</span>, <span class=tok-null>null</span>, <span class=tok-number>5</span> };</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// For loops can also be used as expressions.</span></span>
<span class=line>    <span class=tok-comment>// Similar to while loops, when you break from a for loop, the else branch is not evaluated.</span></span>
<span class=line>    <span class=tok-kw>var</span> sum: <span class=tok-type>i32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>for</span> (items) |value| {</span>
<span class=line>        <span class=tok-kw>if</span> (value != <span class=tok-null>null</span>) {</span>
<span class=line>            sum += value.?;</span>
<span class=line>        }</span>
<span class=line>    } <span class=tok-kw>else</span> blk: {</span>
<span class=line>        <span class=tok-kw>try</span> expect(sum == <span class=tok-number>12</span>);</span>
<span class=line>        <span class=tok-kw>break</span> :blk sum;</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>try</span> expect(result == <span class=tok-number>12</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test for.zig</kbd></span>
<span class=line>1/3 test.for basics... OK</span>
<span class=line>2/3 test.for reference... OK</span>
<span class=line>3/3 test.for else... OK</span>
<span class=line>All 3 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Labeled%20for class=dashAnchor></a><h3 id=Labeled-for>Labeled for</h3> <p>When a <code><span class=line><span class=tok-kw>for</span></span></code> loop is labeled, it can be referenced from a <code><span class=line><span class=tok-kw>break</span></span></code> or <code><span class=line><span class=tok-kw>continue</span></span></code> from within a nested loop:</p> <figure><figcaption class=zig-cap><cite class=file>test_nested_break.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"nested break"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> count: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    outer: <span class=tok-kw>for</span> ([_]<span class=tok-type>i32</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span>, <span class=tok-number>5</span> }) |_| {</span>
<span class=line>        <span class=tok-kw>for</span> ([_]<span class=tok-type>i32</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span>, <span class=tok-number>5</span> }) |_| {</span>
<span class=line>            count += <span class=tok-number>1</span>;</span>
<span class=line>            <span class=tok-kw>break</span> :outer;</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(count == <span class=tok-number>1</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"nested continue"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> count: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    outer: <span class=tok-kw>for</span> ([_]<span class=tok-type>i32</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span>, <span class=tok-number>5</span>, <span class=tok-number>6</span>, <span class=tok-number>7</span>, <span class=tok-number>8</span> }) |_| {</span>
<span class=line>        <span class=tok-kw>for</span> ([_]<span class=tok-type>i32</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span>, <span class=tok-number>5</span> }) |_| {</span>
<span class=line>            count += <span class=tok-number>1</span>;</span>
<span class=line>            <span class=tok-kw>continue</span> :outer;</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(count == <span class=tok-number>8</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_nested_break.zig</kbd></span>
<span class=line>1/2 test.nested break... OK</span>
<span class=line>2/2 test.nested continue... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Keyword/inline%20for class=dashAnchor></a><h3 id=inline-for>inline for</h3> <p> For loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known. </p> <figure><figcaption class=zig-cap><cite class=file>test_inline_loop.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"inline for loop"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> nums = [_]<span class=tok-type>i32</span>{<span class=tok-number>2</span>, <span class=tok-number>4</span>, <span class=tok-number>6</span>};</span>
<span class=line>    <span class=tok-kw>var</span> sum: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>inline</span> <span class=tok-kw>for</span> (nums) |i| {</span>
<span class=line>        <span class=tok-kw>const</span> T = <span class=tok-kw>switch</span> (i) {</span>
<span class=line>            <span class=tok-number>2</span> =&gt; <span class=tok-type>f32</span>,</span>
<span class=line>            <span class=tok-number>4</span> =&gt; <span class=tok-type>i8</span>,</span>
<span class=line>            <span class=tok-number>6</span> =&gt; <span class=tok-type>bool</span>,</span>
<span class=line>            <span class=tok-kw>else</span> =&gt; <span class=tok-kw>unreachable</span>,</span>
<span class=line>        };</span>
<span class=line>        sum += typeNameLength(T);</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(sum == <span class=tok-number>9</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>typeNameLength</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>) <span class=tok-type>usize</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-builtin>@typeName</span>(T).len;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_inline_loop.zig</kbd></span>
<span class=line>1/1 test.inline for loop... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> It is recommended to use <code><span class=line><span class=tok-kw>inline</span></span></code> loops only for one of these reasons: </p> <ul> <li>You need the loop to execute at <a href=#comptime>comptime</a> for the semantics to work.</li> <li> You have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster. </li> </ul> <p>See also:</p><ul> <li><a href=#while>while</a></li> <li><a href=#comptime>comptime</a></li> <li><a href=#Arrays>Arrays</a></li> <li><a href=#Slices>Slices</a></li> </ul> <a name=//apple_ref/cpp/Keyword/if class=dashAnchor></a><h2 id=if>if</h2> <figure><figcaption class=zig-cap><cite class=file>if.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>// If expressions have three uses, corresponding to the three types:</span></span>
<span class=line><span class=tok-comment>// * bool</span></span>
<span class=line><span class=tok-comment>// * ?T</span></span>
<span class=line><span class=tok-comment>// * anyerror!T</span></span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"if expression"</span> {</span>
<span class=line>    <span class=tok-comment>// If expressions are used instead of a ternary expression.</span></span>
<span class=line>    <span class=tok-kw>const</span> a: <span class=tok-type>u32</span> = <span class=tok-number>5</span>;</span>
<span class=line>    <span class=tok-kw>const</span> b: <span class=tok-type>u32</span> = <span class=tok-number>4</span>;</span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>if</span> (a != b) <span class=tok-number>47</span> <span class=tok-kw>else</span> <span class=tok-number>3089</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(result == <span class=tok-number>47</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"if boolean"</span> {</span>
<span class=line>    <span class=tok-comment>// If expressions test boolean conditions.</span></span>
<span class=line>    <span class=tok-kw>const</span> a: <span class=tok-type>u32</span> = <span class=tok-number>5</span>;</span>
<span class=line>    <span class=tok-kw>const</span> b: <span class=tok-type>u32</span> = <span class=tok-number>4</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (a != b) {</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-null>true</span>);</span>
<span class=line>    } <span class=tok-kw>else</span> <span class=tok-kw>if</span> (a == <span class=tok-number>9</span>) {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"if optional"</span> {</span>
<span class=line>    <span class=tok-comment>// If expressions test for null.</span></span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> a: ?<span class=tok-type>u32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (a) |value| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(value == <span class=tok-number>0</span>);</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> b: ?<span class=tok-type>u32</span> = <span class=tok-null>null</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (b) |_| {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-null>true</span>);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// The else is not required.</span></span>
<span class=line>    <span class=tok-kw>if</span> (a) |value| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(value == <span class=tok-number>0</span>);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// To test against null only, use the binary equality operator.</span></span>
<span class=line>    <span class=tok-kw>if</span> (b == <span class=tok-null>null</span>) {</span>
<span class=line>        <span class=tok-kw>try</span> expect(<span class=tok-null>true</span>);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Access the value by reference using a pointer capture.</span></span>
<span class=line>    <span class=tok-kw>var</span> c: ?<span class=tok-type>u32</span> = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (c) |*value| {</span>
<span class=line>        value.* = <span class=tok-number>2</span>;</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>if</span> (c) |value| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(value == <span class=tok-number>2</span>);</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"if error union"</span> {</span>
<span class=line>    <span class=tok-comment>// If expressions test for errors.</span></span>
<span class=line>    <span class=tok-comment>// Note the |err| capture on the else.</span></span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> a: <span class=tok-type>anyerror</span>!<span class=tok-type>u32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (a) |value| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(value == <span class=tok-number>0</span>);</span>
<span class=line>    } <span class=tok-kw>else</span> |err| {</span>
<span class=line>        _ = err;</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> b: <span class=tok-type>anyerror</span>!<span class=tok-type>u32</span> = <span class=tok-kw>error</span>.BadValue;</span>
<span class=line>    <span class=tok-kw>if</span> (b) |value| {</span>
<span class=line>        _ = value;</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    } <span class=tok-kw>else</span> |err| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(err == <span class=tok-kw>error</span>.BadValue);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// The else and |err| capture is strictly required.</span></span>
<span class=line>    <span class=tok-kw>if</span> (a) |value| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(value == <span class=tok-number>0</span>);</span>
<span class=line>    } <span class=tok-kw>else</span> |_| {}</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// To check only the error value, use an empty block expression.</span></span>
<span class=line>    <span class=tok-kw>if</span> (b) |_| {} <span class=tok-kw>else</span> |err| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(err == <span class=tok-kw>error</span>.BadValue);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Access the value by reference using a pointer capture.</span></span>
<span class=line>    <span class=tok-kw>var</span> c: <span class=tok-type>anyerror</span>!<span class=tok-type>u32</span> = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (c) |*value| {</span>
<span class=line>        value.* = <span class=tok-number>9</span>;</span>
<span class=line>    } <span class=tok-kw>else</span> |_| {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>if</span> (c) |value| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(value == <span class=tok-number>9</span>);</span>
<span class=line>    } <span class=tok-kw>else</span> |_| {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"if error union with optional"</span> {</span>
<span class=line>    <span class=tok-comment>// If expressions test for errors before unwrapping optionals.</span></span>
<span class=line>    <span class=tok-comment>// The |optional_value| capture's type is ?u32.</span></span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> a: <span class=tok-type>anyerror</span>!?<span class=tok-type>u32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (a) |optional_value| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(optional_value.? == <span class=tok-number>0</span>);</span>
<span class=line>    } <span class=tok-kw>else</span> |err| {</span>
<span class=line>        _ = err;</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> b: <span class=tok-type>anyerror</span>!?<span class=tok-type>u32</span> = <span class=tok-null>null</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (b) |optional_value| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(optional_value == <span class=tok-null>null</span>);</span>
<span class=line>    } <span class=tok-kw>else</span> |_| {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> c: <span class=tok-type>anyerror</span>!?<span class=tok-type>u32</span> = <span class=tok-kw>error</span>.BadValue;</span>
<span class=line>    <span class=tok-kw>if</span> (c) |optional_value| {</span>
<span class=line>        _ = optional_value;</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    } <span class=tok-kw>else</span> |err| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(err == <span class=tok-kw>error</span>.BadValue);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Access the value by reference by using a pointer capture each time.</span></span>
<span class=line>    <span class=tok-kw>var</span> d: <span class=tok-type>anyerror</span>!?<span class=tok-type>u32</span> = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (d) |*optional_value| {</span>
<span class=line>        <span class=tok-kw>if</span> (optional_value.*) |*value| {</span>
<span class=line>            value.* = <span class=tok-number>9</span>;</span>
<span class=line>        }</span>
<span class=line>    } <span class=tok-kw>else</span> |_| {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>if</span> (d) |optional_value| {</span>
<span class=line>        <span class=tok-kw>try</span> expect(optional_value.? == <span class=tok-number>9</span>);</span>
<span class=line>    } <span class=tok-kw>else</span> |_| {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test if.zig</kbd></span>
<span class=line>1/5 test.if expression... OK</span>
<span class=line>2/5 test.if boolean... OK</span>
<span class=line>3/5 test.if optional... OK</span>
<span class=line>4/5 test.if error union... OK</span>
<span class=line>5/5 test.if error union with optional... OK</span>
<span class=line>All 5 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Optionals>Optionals</a></li> <li><a href=#Errors>Errors</a></li> </ul> <a name=//apple_ref/cpp/Keyword/defer class=dashAnchor></a><h2 id=defer>defer</h2> <figure><figcaption class=zig-cap><cite class=file>defer.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line><span class=tok-kw>const</span> print = std.debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// defer will execute an expression at the end of the current scope.</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>deferExample</span>() !<span class=tok-type>usize</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>usize</span> = <span class=tok-number>1</span>;</span>
<span class=line></span>
<span class=line>    {</span>
<span class=line>        <span class=tok-kw>defer</span> a = <span class=tok-number>2</span>;</span>
<span class=line>        a = <span class=tok-number>1</span>;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>try</span> expect(a == <span class=tok-number>2</span>);</span>
<span class=line></span>
<span class=line>    a = <span class=tok-number>5</span>;</span>
<span class=line>    <span class=tok-kw>return</span> a;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"defer basics"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect((<span class=tok-kw>try</span> deferExample()) == <span class=tok-number>5</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// If multiple defer statements are specified, they will be executed in</span></span>
<span class=line><span class=tok-comment>// the reverse order they were run.</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>deferUnwindExample</span>() <span class=tok-type>void</span> {</span>
<span class=line>    print(<span class=tok-str>"\n"</span>, .{});</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>defer</span> {</span>
<span class=line>        print(<span class=tok-str>"1 "</span>, .{});</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>defer</span> {</span>
<span class=line>        print(<span class=tok-str>"2 "</span>, .{});</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>if</span> (<span class=tok-null>false</span>) {</span>
<span class=line>        <span class=tok-comment>// defers are not run if they are never executed.</span></span>
<span class=line>        <span class=tok-kw>defer</span> {</span>
<span class=line>            print(<span class=tok-str>"3 "</span>, .{});</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"defer unwinding"</span> {</span>
<span class=line>    deferUnwindExample();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The errdefer keyword is similar to defer, but will only execute if the</span></span>
<span class=line><span class=tok-comment>// scope returns with an error.</span></span>
<span class=line><span class=tok-comment>//</span></span>
<span class=line><span class=tok-comment>// This is especially useful in allowing a function to clean up properly</span></span>
<span class=line><span class=tok-comment>// on error, and replaces goto error handling tactics as seen in c.</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>deferErrorExample</span>(is_error: <span class=tok-type>bool</span>) !<span class=tok-type>void</span> {</span>
<span class=line>    print(<span class=tok-str>"\nstart of function\n"</span>, .{});</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// This will always be executed on exit</span></span>
<span class=line>    <span class=tok-kw>defer</span> {</span>
<span class=line>        print(<span class=tok-str>"end of function\n"</span>, .{});</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>errdefer</span> {</span>
<span class=line>        print(<span class=tok-str>"encountered an error!\n"</span>, .{});</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// inside a defer method the return statement</span></span>
<span class=line>    <span class=tok-comment>// is not allowed.</span></span>
<span class=line>    <span class=tok-comment>// The following lines produce the following</span></span>
<span class=line>    <span class=tok-comment>// error if uncomment</span></span>
<span class=line>    <span class=tok-comment>// ```</span></span>
<span class=line>    <span class=tok-comment>// defer.zig:73:9: error: cannot return from defer expression</span></span>
<span class=line>    <span class=tok-comment>// return error.DeferError;</span></span>
<span class=line>    <span class=tok-comment>// ```</span></span>
<span class=line>    <span class=tok-comment>//</span></span>
<span class=line>    <span class=tok-comment>//defer {</span></span>
<span class=line>    <span class=tok-comment>//    return error.DeferError;</span></span>
<span class=line>    <span class=tok-comment>//}</span></span>
<span class=line></span>
<span class=line>    <span class=tok-kw>if</span> (is_error) {</span>
<span class=line>        <span class=tok-kw>return</span> <span class=tok-kw>error</span>.DeferError;</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The errdefer keyword support also an alternative syntax to capture the</span></span>
<span class=line><span class=tok-comment>// error generated in case of one error.</span></span>
<span class=line><span class=tok-comment>//</span></span>
<span class=line><span class=tok-comment>// This is useful when during the clean up after an error additional</span></span>
<span class=line><span class=tok-comment>// message want to be printed.</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>deferErrorCaptureExample</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>errdefer</span> |err| {</span>
<span class=line>        std.debug.print(<span class=tok-str>"the error is {s}\n"</span>, .{<span class=tok-builtin>@errorName</span>(err)});</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>error</span>.DeferError;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"errdefer unwinding"</span> {</span>
<span class=line>    deferErrorExample(<span class=tok-null>false</span>) <span class=tok-kw>catch</span> {};</span>
<span class=line>    deferErrorExample(<span class=tok-null>true</span>) <span class=tok-kw>catch</span> {};</span>
<span class=line>    deferErrorCaptureExample() <span class=tok-kw>catch</span> {};</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test defer.zig</kbd></span>
<span class=line>1/3 test.defer basics... OK</span>
<span class=line>2/3 test.defer unwinding...</span>
<span class=line>2 1 OK</span>
<span class=line>3/3 test.errdefer unwinding...</span>
<span class=line>start of function</span>
<span class=line>end of function</span>
<span class=line></span>
<span class=line>start of function</span>
<span class=line>encountered an error!</span>
<span class=line>end of function</span>
<span class=line>the error is DeferError</span>
<span class=line>OK</span>
<span class=line>All 3 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Errors>Errors</a></li> </ul> <a name=//apple_ref/cpp/Keyword/unreachable class=dashAnchor></a><h2 id=unreachable>unreachable</h2> <p> In <a href=#Debug>Debug</a> and <a href=#ReleaseSafe>ReleaseSafe</a> mode <code><span class=line><span class=tok-kw>unreachable</span></span></code> emits a call to <code><span class=line>panic</span></code> with the message <code>reached unreachable code</code>. </p> <p> In <a href=#ReleaseFast>ReleaseFast</a> and <a href=#ReleaseSmall>ReleaseSmall</a> mode, the optimizer uses the assumption that <code><span class=line><span class=tok-kw>unreachable</span></span></code> code will never be hit to perform optimizations. </p> <a name=//apple_ref/cpp/Guide/Basics class=dashAnchor></a><h3 id=Basics>Basics</h3> <figure><figcaption class=zig-cap><cite class=file>test_unreachable.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>// unreachable is used to assert that control flow will never reach a</span></span>
<span class=line><span class=tok-comment>// particular location:</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"basic math"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>const</span> y = <span class=tok-number>2</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (x + y != <span class=tok-number>3</span>) {</span>
<span class=line>        <span class=tok-kw>unreachable</span>;</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_unreachable.zig</kbd></span>
<span class=line>1/1 test.basic math... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>In fact, this is how <code><span class=line>std.debug.assert</span></code> is implemented:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>// This is how std.debug.assert is implemented</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>assert</span>(ok: <span class=tok-type>bool</span>) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (!ok) <span class=tok-kw>unreachable</span>; <span class=tok-comment>// assertion failure</span></span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// This test will fail because we hit unreachable.</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"this will fail"</span> {</span>
<span class=line>    assert(<span class=tok-null>false</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.this will fail... thread 1636371 panic: reached unreachable code</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:3:14</span>: <span class=t2_0>0x211580 in assert (test)</span></span>
<span class=line>    if (!ok) unreachable; // assertion failure</span>
<span class=line>             <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:8:11</span>: <span class=t2_0>0x21154a in test.this will fail (test)</span></span>
<span class=line>    assert(false);</span>
<span class=line>          <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x212b88 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x211e6b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x211931 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>error: the following test command crashed:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/At%20Compile-Time class=dashAnchor></a><h3 id=At-Compile-Time>At Compile-Time</h3> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> assert = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.assert;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"type of unreachable"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-comment>// The type of unreachable is noreturn.</span></span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// However this assertion will still fail to compile because</span></span>
<span class=line>        <span class=tok-comment>// unreachable expressions are compile errors.</span></span>
<span class=line></span>
<span class=line>        assert(<span class=tok-builtin>@TypeOf</span>(<span class=tok-kw>unreachable</span>) == <span class=tok-type>noreturn</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:10:16: </span><span class=t31_1>error: </span><span class=t1_0>unreachable code</span>
<span class=line></span>        assert(@TypeOf(unreachable) == noreturn);</span>
<span class=line>               <span class=t32_1>^~~~~~~~~~~~~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:10:24: </span><span class=t36_1>note: </span><span class=t1_0>control flow is diverted here</span>
<span class=line></span>        assert(@TypeOf(unreachable) == noreturn);</span>
<span class=line>                       <span class=t32_1>^~~~~~~~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Zig-Test>Zig Test</a></li> <li><a href=#Build-Mode>Build Mode</a></li> <li><a href=#comptime>comptime</a></li> </ul> <a name=//apple_ref/cpp/Keyword/noreturn class=dashAnchor></a><h2 id=noreturn>noreturn</h2> <p> <code><span class=line><span class=tok-type>noreturn</span></span></code> is the type of: </p> <ul> <li><code><span class=line><span class=tok-kw>break</span></span></code></li> <li><code><span class=line><span class=tok-kw>continue</span></span></code></li> <li><code><span class=line><span class=tok-kw>return</span></span></code></li> <li><code><span class=line><span class=tok-kw>unreachable</span></span></code></li> <li><code><span class=line><span class=tok-kw>while</span> (<span class=tok-null>true</span>) {}</span></code></li> </ul> <p>When resolving types together, such as <code><span class=line><span class=tok-kw>if</span></span></code> clauses or <code><span class=line><span class=tok-kw>switch</span></span></code> prongs, the <code><span class=line><span class=tok-type>noreturn</span></span></code> type is compatible with every other type. Consider: </p> <figure><figcaption class=zig-cap><cite class=file>test_noreturn.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(condition: <span class=tok-type>bool</span>, b: <span class=tok-type>u32</span>) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> a = <span class=tok-kw>if</span> (condition) b <span class=tok-kw>else</span> <span class=tok-kw>return</span>;</span>
<span class=line>    _ = a;</span>
<span class=line>    <span class=tok-builtin>@panic</span>(<span class=tok-str>"do something with a"</span>);</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"noreturn"</span> {</span>
<span class=line>    foo(<span class=tok-null>false</span>, <span class=tok-number>1</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_noreturn.zig</kbd></span>
<span class=line>1/1 test.noreturn... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>Another use case for <code><span class=line><span class=tok-type>noreturn</span></span></code> is the <code><span class=line>exit</span></code> function:</p> <figure><figcaption class=zig-cap><cite class=file>noreturn_from_exit.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> builtin = <span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>);</span>
<span class=line><span class=tok-kw>const</span> native_arch = builtin.cpu.arch;</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> WINAPI: std.builtin.CallingConvention = <span class=tok-kw>if</span> (native_arch == .<span class=tok-type>i386</span>) .Stdcall <span class=tok-kw>else</span> .C;</span>
<span class=line><span class=tok-kw>extern</span> <span class=tok-str>"kernel32"</span> <span class=tok-kw>fn</span> <span class=tok-fn>ExitProcess</span>(exit_code: <span class=tok-type>c_uint</span>) <span class=tok-kw>callconv</span>(WINAPI) <span class=tok-type>noreturn</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"foo"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> value = bar() <span class=tok-kw>catch</span> ExitProcess(<span class=tok-number>1</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(value == <span class=tok-number>1234</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bar</span>() <span class=tok-type>anyerror</span>!<span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-number>1234</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test noreturn_from_exit.zig -target x86_64-windows --test-no-exec</kbd></span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Functions class=dashAnchor></a><h2 id=Functions>Functions</h2> <figure><figcaption class=zig-cap><cite class=file>functions.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> builtin = <span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>);</span>
<span class=line><span class=tok-kw>const</span> native_arch = builtin.cpu.arch;</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Functions are declared like this</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>add</span>(a: <span class=tok-type>i8</span>, b: <span class=tok-type>i8</span>) <span class=tok-type>i8</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (a == <span class=tok-number>0</span>) {</span>
<span class=line>        <span class=tok-kw>return</span> b;</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>return</span> a + b;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The export specifier makes a function externally visible in the generated</span></span>
<span class=line><span class=tok-comment>// object file, and makes it use the C ABI.</span></span>
<span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>sub</span>(a: <span class=tok-type>i8</span>, b: <span class=tok-type>i8</span>) <span class=tok-type>i8</span> { <span class=tok-kw>return</span> a - b; }</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The extern specifier is used to declare a function that will be resolved</span></span>
<span class=line><span class=tok-comment>// at link time, when linking statically, or at runtime, when linking</span></span>
<span class=line><span class=tok-comment>// dynamically.</span></span>
<span class=line><span class=tok-comment>// The callconv specifier changes the calling convention of the function.</span></span>
<span class=line><span class=tok-kw>const</span> WINAPI: std.builtin.CallingConvention = <span class=tok-kw>if</span> (native_arch == .<span class=tok-type>i386</span>) .Stdcall <span class=tok-kw>else</span> .C;</span>
<span class=line><span class=tok-kw>extern</span> <span class=tok-str>"kernel32"</span> <span class=tok-kw>fn</span> <span class=tok-fn>ExitProcess</span>(exit_code: <span class=tok-type>u32</span>) <span class=tok-kw>callconv</span>(WINAPI) <span class=tok-type>noreturn</span>;</span>
<span class=line><span class=tok-kw>extern</span> <span class=tok-str>"c"</span> <span class=tok-kw>fn</span> <span class=tok-fn>atan2</span>(a: <span class=tok-type>f64</span>, b: <span class=tok-type>f64</span>) <span class=tok-type>f64</span>;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The @setCold builtin tells the optimizer that a function is rarely called.</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>abort</span>() <span class=tok-type>noreturn</span> {</span>
<span class=line>    <span class=tok-builtin>@setCold</span>(<span class=tok-null>true</span>);</span>
<span class=line>    <span class=tok-kw>while</span> (<span class=tok-null>true</span>) {}</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The naked calling convention makes a function not have any function prologue or epilogue.</span></span>
<span class=line><span class=tok-comment>// This can be useful when integrating with assembly.</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>_start</span>() <span class=tok-kw>callconv</span>(.Naked) <span class=tok-type>noreturn</span> {</span>
<span class=line>    abort();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The inline calling convention forces a function to be inlined at all call sites.</span></span>
<span class=line><span class=tok-comment>// If the function cannot be inlined, it is a compile-time error.</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>shiftLeftOne</span>(a: <span class=tok-type>u32</span>) <span class=tok-kw>callconv</span>(.Inline) <span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> a &lt;&lt; <span class=tok-number>1</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The pub specifier allows the function to be visible when importing.</span></span>
<span class=line><span class=tok-comment>// Another file can use @import and call sub2</span></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>sub2</span>(a: <span class=tok-type>i8</span>, b: <span class=tok-type>i8</span>) <span class=tok-type>i8</span> { <span class=tok-kw>return</span> a - b; }</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Function pointers are prefixed with `*const `.</span></span>
<span class=line><span class=tok-kw>const</span> call2_op = *<span class=tok-kw>const</span> <span class=tok-kw>fn</span> (a: <span class=tok-type>i8</span>, b: <span class=tok-type>i8</span>) <span class=tok-type>i8</span>;</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>do_op</span>(fn_call: call2_op, op1: <span class=tok-type>i8</span>, op2: <span class=tok-type>i8</span>) <span class=tok-type>i8</span> {</span>
<span class=line>    <span class=tok-kw>return</span> fn_call(op1, op2);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"function"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(do_op(add, <span class=tok-number>5</span>, <span class=tok-number>6</span>) == <span class=tok-number>11</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(do_op(sub2, <span class=tok-number>5</span>, <span class=tok-number>6</span>) == -<span class=tok-number>1</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test functions.zig</kbd></span>
<span class=line>1/1 test.function... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>There is a difference between a function <em>body</em> and a function <em>pointer</em>. Function bodies are <a href=#comptime>comptime</a>-only types while function <a href=#Pointers>Pointers</a> may be runtime-known.</p> <a name=//apple_ref/cpp/Guide/Pass-by-value%20Parameters class=dashAnchor></a><h3 id=Pass-by-value-Parameters>Pass-by-value Parameters</h3> <p> Primitive types such as <a href=#Integers>Integers</a> and <a href=#Floats>Floats</a> passed as parameters are copied, and then the copy is available in the function body. This is called "passing by value". Copying a primitive type is essentially free and typically involves nothing more than setting a register. </p> <p> Structs, unions, and arrays can sometimes be more efficiently passed as a reference, since a copy could be arbitrarily expensive depending on the size. When these types are passed as parameters, Zig may choose to copy and pass by value, or pass by reference, whichever way Zig decides will be faster. This is made possible, in part, by the fact that parameters are immutable. </p> <figure><figcaption class=zig-cap><cite class=file>pass_by_reference_or_value.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Point = <span class=tok-kw>struct</span> {</span>
<span class=line>    x: <span class=tok-type>i32</span>,</span>
<span class=line>    y: <span class=tok-type>i32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(point: Point) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-comment>// Here, `point` could be a reference, or a copy. The function body</span></span>
<span class=line>    <span class=tok-comment>// can ignore the difference and treat it as a value. Be very careful</span></span>
<span class=line>    <span class=tok-comment>// taking the address of the parameter - it should be treated as if</span></span>
<span class=line>    <span class=tok-comment>// the address will become invalid when the function returns.</span></span>
<span class=line>    <span class=tok-kw>return</span> point.x + point.y;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"pass struct to function"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(foo(Point{ .x = <span class=tok-number>1</span>, .y = <span class=tok-number>2</span> }) == <span class=tok-number>3</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test pass_by_reference_or_value.zig</kbd></span>
<span class=line>1/1 test.pass struct to function... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> For extern functions, Zig follows the C ABI for passing structs and unions by value. </p> <a name=//apple_ref/cpp/Guide/Function%20Parameter%20Type%20Inference class=dashAnchor></a><h3 id=Function-Parameter-Type-Inference>Function Parameter Type Inference</h3> <p> Function parameters can be declared with <code><span class=line><span class=tok-kw>anytype</span></span></code> in place of the type. In this case the parameter types will be inferred when the function is called. Use <a href=#TypeOf>@TypeOf</a> and <a href=#typeInfo>@typeInfo</a> to get information about the inferred type. </p> <figure><figcaption class=zig-cap><cite class=file>test_fn_type_inference.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>addFortyTwo</span>(x: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(x) {</span>
<span class=line>    <span class=tok-kw>return</span> x + <span class=tok-number>42</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"fn type inference"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(addFortyTwo(<span class=tok-number>1</span>) == <span class=tok-number>43</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(addFortyTwo(<span class=tok-number>1</span>)) == <span class=tok-type>comptime_int</span>);</span>
<span class=line>    <span class=tok-kw>var</span> y: <span class=tok-type>i64</span> = <span class=tok-number>2</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(addFortyTwo(y) == <span class=tok-number>44</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(addFortyTwo(y)) == <span class=tok-type>i64</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_fn_type_inference.zig</kbd></span>
<span class=line>1/1 test.fn type inference... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Function%20Reflection class=dashAnchor></a><h3 id=Function-Reflection>Function Reflection</h3> <figure><figcaption class=zig-cap><cite class=file>test_fn_reflection.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"fn reflection"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@typeInfo</span>(<span class=tok-builtin>@TypeOf</span>(expect)).Fn.args[<span class=tok-number>0</span>].arg_type.? == <span class=tok-type>bool</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@typeInfo</span>(<span class=tok-builtin>@TypeOf</span>(expect)).Fn.is_var_args == <span class=tok-null>false</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_fn_reflection.zig</kbd></span>
<span class=line>1/1 test.fn reflection... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Errors class=dashAnchor></a><h2 id=Errors>Errors</h2> <a name=//apple_ref/cpp/Guide/Error%20Set%20Type class=dashAnchor></a><h3 id=Error-Set-Type>Error Set Type</h3> <p> An error set is like an <a href=#enum>enum</a>. However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value. </p> <p> The number of unique error values across the entire compilation should determine the size of the error set type. However right now it is hard coded to be a <code><span class=line><span class=tok-type>u16</span></span></code>. See <a href=https://github.com/ziglang/zig/issues/786>#768</a>. </p> <p> You can <a href=#Type-Coercion>coerce</a> an error from a subset to a superset: </p> <figure><figcaption class=zig-cap><cite class=file>coercing_subset_to_superset.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> FileOpenError = <span class=tok-kw>error</span> {</span>
<span class=line>    AccessDenied,</span>
<span class=line>    OutOfMemory,</span>
<span class=line>    FileNotFound,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> AllocationError = <span class=tok-kw>error</span> {</span>
<span class=line>    OutOfMemory,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"coerce subset to superset"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> err = foo(AllocationError.OutOfMemory);</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expect(err == FileOpenError.OutOfMemory);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(err: AllocationError) FileOpenError {</span>
<span class=line>    <span class=tok-kw>return</span> err;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test coercing_subset_to_superset.zig</kbd></span>
<span class=line>1/1 test.coerce subset to superset... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> But you cannot <a href=#Type-Coercion>coerce</a> an error from a superset to a subset: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> FileOpenError = <span class=tok-kw>error</span> {</span>
<span class=line>    AccessDenied,</span>
<span class=line>    OutOfMemory,</span>
<span class=line>    FileNotFound,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> AllocationError = <span class=tok-kw>error</span> {</span>
<span class=line>    OutOfMemory,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"coerce superset to subset"</span> {</span>
<span class=line>    foo(FileOpenError.OutOfMemory) <span class=tok-kw>catch</span> {};</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(err: FileOpenError) AllocationError {</span>
<span class=line>    <span class=tok-kw>return</span> err;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:16:12: </span><span class=t31_1>error: </span><span class=t1_0>expected type 'error{OutOfMemory}', found 'error{AccessDenied,FileNotFound,OutOfMemory}'</span>
<span class=line></span>    return err;</span>
<span class=line>           <span class=t32_1>^~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:16:12: </span><span class=t36_1>note: </span><span class=t1_0>'error.AccessDenied' not a member of destination error set</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:16:12: </span><span class=t36_1>note: </span><span class=t1_0>'error.FileNotFound' not a member of destination error set</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:15:28: </span><span class=t36_1>note: </span><span class=t1_0>function return type declared here</span>
<span class=line></span>fn foo(err: FileOpenError) AllocationError {</span>
<span class=line>                           <span class=t32_1>^~~~~~~~~~~~~~~</span>
<span class=line></span><span class=t2_0>referenced by:</span>
<span class=line>    test.coerce superset to subset: docgen_tmp/test.zig:12:5</span>
<span class=line>    remaining reference traces hidden; use '-freference-trace' to see all reference traces</span>
<span class=line></span>
<span class=line></span></span>
</samp></pre></figure> <p> There is a shortcut for declaring an error set with only 1 value, and then getting that value: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> err = <span class=tok-kw>error</span>.FileNotFound;</span></code></pre></figure> <p>This is equivalent to:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> err = (<span class=tok-kw>error</span> {FileNotFound}).FileNotFound;</span></code></pre></figure> <p> This becomes useful when using <a href=#Inferred-Error-Sets>Inferred Error Sets</a>. </p> <a name=//apple_ref/cpp/Guide/The%20Global%20Error%20Set class=dashAnchor></a><h4 id=The-Global-Error-Set>The Global Error Set</h4> <p><code><span class=line><span class=tok-type>anyerror</span></span></code> refers to the global error set. This is the error set that contains all errors in the entire compilation unit. It is a superset of all other error sets and a subset of none of them. </p> <p> You can <a href=#Type-Coercion>coerce</a> any error set to the global one, and you can explicitly cast an error of the global error set to a non-global one. This inserts a language-level assert to make sure the error value is in fact in the destination error set. </p> <p> The global error set should generally be avoided because it prevents the compiler from knowing what errors are possible at compile-time. Knowing the error set at compile-time is better for generated documentation and helpful error messages, such as forgetting a possible error value in a <a href=#switch>switch</a>. </p> <a name=//apple_ref/cpp/Guide/Error%20Union%20Type class=dashAnchor></a><h3 id=Error-Union-Type>Error Union Type</h3> <p> An error set type and normal type can be combined with the <code><span class=line>!</span></code> binary operator to form an error union type. You are likely to use an error union type more often than an error set type by itself. </p> <p> Here is a function to parse a string into a 64-bit integer: </p> <figure><figcaption class=zig-cap><cite class=file>error_union_parsing_u64.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> maxInt = std.math.maxInt;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>parseU64</span>(buf: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>, radix: <span class=tok-type>u8</span>) !<span class=tok-type>u64</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>u64</span> = <span class=tok-number>0</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>for</span> (buf) |c| {</span>
<span class=line>        <span class=tok-kw>const</span> digit = charToDigit(c);</span>
<span class=line></span>
<span class=line>        <span class=tok-kw>if</span> (digit &gt;= radix) {</span>
<span class=line>            <span class=tok-kw>return</span> <span class=tok-kw>error</span>.InvalidChar;</span>
<span class=line>        }</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// x *= radix</span></span>
<span class=line>        <span class=tok-kw>if</span> (<span class=tok-builtin>@mulWithOverflow</span>(<span class=tok-type>u64</span>, x, radix, &amp;x)) {</span>
<span class=line>            <span class=tok-kw>return</span> <span class=tok-kw>error</span>.Overflow;</span>
<span class=line>        }</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// x += digit</span></span>
<span class=line>        <span class=tok-kw>if</span> (<span class=tok-builtin>@addWithOverflow</span>(<span class=tok-type>u64</span>, x, digit, &amp;x)) {</span>
<span class=line>            <span class=tok-kw>return</span> <span class=tok-kw>error</span>.Overflow;</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>return</span> x;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>charToDigit</span>(c: <span class=tok-type>u8</span>) <span class=tok-type>u8</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>switch</span> (c) {</span>
<span class=line>        <span class=tok-str>'0'</span> ... <span class=tok-str>'9'</span> =&gt; c - <span class=tok-str>'0'</span>,</span>
<span class=line>        <span class=tok-str>'A'</span> ... <span class=tok-str>'Z'</span> =&gt; c - <span class=tok-str>'A'</span> + <span class=tok-number>10</span>,</span>
<span class=line>        <span class=tok-str>'a'</span> ... <span class=tok-str>'z'</span> =&gt; c - <span class=tok-str>'a'</span> + <span class=tok-number>10</span>,</span>
<span class=line>        <span class=tok-kw>else</span> =&gt; maxInt(<span class=tok-type>u8</span>),</span>
<span class=line>    };</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"parse u64"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>try</span> parseU64(<span class=tok-str>"1234"</span>, <span class=tok-number>10</span>);</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expect(result == <span class=tok-number>1234</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test error_union_parsing_u64.zig</kbd></span>
<span class=line>1/1 test.parse u64... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Notice the return type is <code><span class=line>!<span class=tok-type>u64</span></span></code>. This means that the function either returns an unsigned 64 bit integer, or an error. We left off the error set to the left of the <code><span class=line>!</span></code>, so the error set is inferred. </p> <p> Within the function definition, you can see some return statements that return an error, and at the bottom a return statement that returns a <code><span class=line><span class=tok-type>u64</span></span></code>. Both types <a href=#Type-Coercion>coerce</a> to <code><span class=line><span class=tok-type>anyerror</span>!<span class=tok-type>u64</span></span></code>. </p> <p> What it looks like to use this function varies depending on what you're trying to do. One of the following: </p> <ul> <li>You want to provide a default value if it returned an error.</li> <li>If it returned an error then you want to return the same error.</li> <li>You know with complete certainty it will not return an error, so want to unconditionally unwrap it.</li> <li>You want to take a different action for each possible error.</li> </ul> <a name=//apple_ref/cpp/Keyword/catch class=dashAnchor></a><h4 id=catch>catch</h4> <p>If you want to provide a default value, you can use the <code><span class=line><span class=tok-kw>catch</span></span></code> binary operator:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> parseU64 = <span class=tok-builtin>@import</span>(<span class=tok-str>"error_union_parsing_u64.zig"</span>).parseU64;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>doAThing</span>(str: []<span class=tok-type>u8</span>) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> number = parseU64(str, <span class=tok-number>10</span>) <span class=tok-kw>catch</span> <span class=tok-number>13</span>;</span>
<span class=line>    _ = number; <span class=tok-comment>// ...</span></span>
<span class=line>}</span></code></pre></figure> <p> In this code, <code><span class=line>number</span></code> will be equal to the successfully parsed string, or a default value of 13. The type of the right hand side of the binary <code><span class=line><span class=tok-kw>catch</span></span></code> operator must match the unwrapped error union type, or be of type <code><span class=line><span class=tok-type>noreturn</span></span></code>. </p> <a name=//apple_ref/cpp/Keyword/try class=dashAnchor></a><h4 id=try>try</h4> <p>Let's say you wanted to return the error if you got one, otherwise continue with the function logic:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> parseU64 = <span class=tok-builtin>@import</span>(<span class=tok-str>"error_union_parsing_u64.zig"</span>).parseU64;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>doAThing</span>(str: []<span class=tok-type>u8</span>) !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> number = parseU64(str, <span class=tok-number>10</span>) <span class=tok-kw>catch</span> |err| <span class=tok-kw>return</span> err;</span>
<span class=line>    _ = number; <span class=tok-comment>// ...</span></span>
<span class=line>}</span></code></pre></figure> <p> There is a shortcut for this. The <code><span class=line><span class=tok-kw>try</span></span></code> expression: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> parseU64 = <span class=tok-builtin>@import</span>(<span class=tok-str>"error_union_parsing_u64.zig"</span>).parseU64;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>doAThing</span>(str: []<span class=tok-type>u8</span>) !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> number = <span class=tok-kw>try</span> parseU64(str, <span class=tok-number>10</span>);</span>
<span class=line>    _ = number; <span class=tok-comment>// ...</span></span>
<span class=line>}</span></code></pre></figure> <p> <code><span class=line><span class=tok-kw>try</span></span></code> evaluates an error union expression. If it is an error, it returns from the current function with the same error. Otherwise, the expression results in the unwrapped value. </p> <p> Maybe you know with complete certainty that an expression will never be an error. In this case you can do this: </p> <code><span class=line><span class=tok-kw>const</span> number = parseU64(<span class=tok-str>"1234"</span>, <span class=tok-number>10</span>) <span class=tok-kw>catch</span> <span class=tok-kw>unreachable</span>;</span></code> <p> Here we know for sure that "1234" will parse successfully. So we put the <code><span class=line><span class=tok-kw>unreachable</span></span></code> value on the right hand side. <code><span class=line><span class=tok-kw>unreachable</span></span></code> generates a panic in Debug and ReleaseSafe modes and undefined behavior in ReleaseFast mode. So, while we're debugging the application, if there <em>was</em> a surprise error here, the application would crash appropriately. </p> <p> Finally, you may want to take a different action for every situation. For that, we combine the <a href=#if>if</a> and <a href=#switch>switch</a> expression: </p> <figure><figcaption class=zig-cap><cite class=file>handle_all_error_scenarios.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>doAThing</span>(str: []<span class=tok-type>u8</span>) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (parseU64(str, <span class=tok-number>10</span>)) |number| {</span>
<span class=line>        doSomethingWithNumber(number);</span>
<span class=line>    } <span class=tok-kw>else</span> |err| <span class=tok-kw>switch</span> (err) {</span>
<span class=line>        <span class=tok-kw>error</span>.Overflow =&gt; {</span>
<span class=line>            <span class=tok-comment>// handle overflow...</span></span>
<span class=line>        },</span>
<span class=line>        <span class=tok-comment>// we promise that InvalidChar won't happen (or crash in debug mode if it does)</span></span>
<span class=line>        <span class=tok-kw>error</span>.InvalidChar =&gt; <span class=tok-kw>unreachable</span>,</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure> <a name=//apple_ref/cpp/Keyword/errdefer class=dashAnchor></a><h4 id=errdefer>errdefer</h4> <p> The other component to error handling is defer statements. In addition to an unconditional <a href=#defer>defer</a>, Zig has <code><span class=line><span class=tok-kw>errdefer</span></span></code>, which evaluates the deferred expression on block exit path if and only if the function returned with an error from the block. </p> <p> Example: </p> <figure><figcaption class=zig-cap><cite class=file>errdefer_example.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>createFoo</span>(param: <span class=tok-type>i32</span>) !Foo {</span>
<span class=line>    <span class=tok-kw>const</span> foo = <span class=tok-kw>try</span> tryToAllocateFoo();</span>
<span class=line>    <span class=tok-comment>// now we have allocated foo. we need to free it if the function fails.</span></span>
<span class=line>    <span class=tok-comment>// but we want to return it if the function succeeds.</span></span>
<span class=line>    <span class=tok-kw>errdefer</span> deallocateFoo(foo);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> tmp_buf = allocateTmpBuffer() <span class=tok-kw>orelse</span> <span class=tok-kw>return</span> <span class=tok-kw>error</span>.OutOfMemory;</span>
<span class=line>    <span class=tok-comment>// tmp_buf is truly a temporary resource, and we for sure want to clean it up</span></span>
<span class=line>    <span class=tok-comment>// before this block leaves scope</span></span>
<span class=line>    <span class=tok-kw>defer</span> deallocateTmpBuffer(tmp_buf);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>if</span> (param &gt; <span class=tok-number>1337</span>) <span class=tok-kw>return</span> <span class=tok-kw>error</span>.InvalidParam;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// here the errdefer will not run since we're returning success from the function.</span></span>
<span class=line>    <span class=tok-comment>// but the defer will run!</span></span>
<span class=line>    <span class=tok-kw>return</span> foo;</span>
<span class=line>}</span></code></pre></figure> <p> The neat thing about this is that you get robust error handling without the verbosity and cognitive overhead of trying to make sure every exit path is covered. The deallocation code is always directly following the allocation code. </p> <a name=//apple_ref/cpp/Guide/Common%20errdefer%20Slip-Ups class=dashAnchor></a><h4 id=Common-errdefer-Slip-Ups>Common errdefer Slip-Ups</h4> <p> It should be noted that <code><span class=line><span class=tok-kw>errdefer</span></span></code> statements only last until the end of the block they are written in, and therefore are not run if an error is returned outside of that block: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> Allocator = std.mem.Allocator;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>struct</span> {</span>
<span class=line>    data: <span class=tok-type>u32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>tryToAllocateFoo</span>(allocator: Allocator) !*Foo {</span>
<span class=line>    <span class=tok-kw>return</span> allocator.create(Foo);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>deallocateFoo</span>(allocator: Allocator, foo: *Foo) <span class=tok-type>void</span> {</span>
<span class=line>    allocator.destroy(foo);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>getFooData</span>() !<span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-number>666</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>createFoo</span>(allocator: Allocator, param: <span class=tok-type>i32</span>) !*Foo {</span>
<span class=line>    <span class=tok-kw>const</span> foo = getFoo: {</span>
<span class=line>        <span class=tok-kw>var</span> foo = <span class=tok-kw>try</span> tryToAllocateFoo(allocator);</span>
<span class=line>        <span class=tok-kw>errdefer</span> deallocateFoo(allocator, foo); <span class=tok-comment>// Only lasts until the end of getFoo</span></span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// Calls deallocateFoo on error</span></span>
<span class=line>        foo.data = <span class=tok-kw>try</span> getFooData();</span>
<span class=line></span>
<span class=line>        <span class=tok-kw>break</span> :getFoo foo;</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Outside of the scope of the errdefer, so</span></span>
<span class=line>    <span class=tok-comment>// deallocateFoo will not be called here</span></span>
<span class=line>    <span class=tok-kw>if</span> (param &gt; <span class=tok-number>1337</span>) <span class=tok-kw>return</span> <span class=tok-kw>error</span>.InvalidParam;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>return</span> foo;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"createFoo"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expectError(<span class=tok-kw>error</span>.InvalidParam, createFoo(std.testing.allocator, <span class=tok-number>2468</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.createFoo... OK</span>
<span class=line>[gpa] (err): memory address 0x7fe0613f4000 leaked:</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:9:28</span>: <span class=t2_0>0x21372f in tryToAllocateFoo (test)</span></span>
<span class=line>    return allocator.create(Foo);</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:22:39</span>: <span class=t2_0>0x21395f in createFoo (test)</span></span>
<span class=line>        var foo = try tryToAllocateFoo(allocator);</span>
<span class=line>                                      <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:39:62</span>: <span class=t2_0>0x213ccd in test.createFoo (test)</span></span>
<span class=line>    try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));</span>
<span class=line>                                                             <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x21a858 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x2145fb in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x2140c1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line></span>
<span class=line></span>
<span class=line>All 1 tests passed.</span>
<span class=line>1 errors were logged.</span>
<span class=line>1 tests leaked memory.</span>
<span class=line>error: the following test command failed with exit code 1:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <p> To ensure that <code><span class=line>deallocateFoo</span></code> is properly called when returning an error, you must add an <code><span class=line><span class=tok-kw>errdefer</span></span></code> outside of the block: </p><figure><figcaption class=zig-cap><cite class=file>test_errdefer_block.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> Allocator = std.mem.Allocator;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>struct</span> {</span>
<span class=line>    data: <span class=tok-type>u32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>tryToAllocateFoo</span>(allocator: Allocator) !*Foo {</span>
<span class=line>    <span class=tok-kw>return</span> allocator.create(Foo);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>deallocateFoo</span>(allocator: Allocator, foo: *Foo) <span class=tok-type>void</span> {</span>
<span class=line>    allocator.destroy(foo);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>getFooData</span>() !<span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-number>666</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>createFoo</span>(allocator: Allocator, param: <span class=tok-type>i32</span>) !*Foo {</span>
<span class=line>    <span class=tok-kw>const</span> foo = getFoo: {</span>
<span class=line>        <span class=tok-kw>var</span> foo = <span class=tok-kw>try</span> tryToAllocateFoo(allocator);</span>
<span class=line>        <span class=tok-kw>errdefer</span> deallocateFoo(allocator, foo);</span>
<span class=line></span>
<span class=line>        foo.data = <span class=tok-kw>try</span> getFooData();</span>
<span class=line></span>
<span class=line>        <span class=tok-kw>break</span> :getFoo foo;</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-comment>// This lasts for the rest of the function</span></span>
<span class=line>    <span class=tok-kw>errdefer</span> deallocateFoo(allocator, foo);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Error is now properly handled by errdefer</span></span>
<span class=line>    <span class=tok-kw>if</span> (param &gt; <span class=tok-number>1337</span>) <span class=tok-kw>return</span> <span class=tok-kw>error</span>.InvalidParam;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>return</span> foo;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"createFoo"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expectError(<span class=tok-kw>error</span>.InvalidParam, createFoo(std.testing.allocator, <span class=tok-number>2468</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_errdefer_block.zig</kbd></span>
<span class=line>1/1 test.createFoo... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> The fact that errdefers only last for the block they are declared in is especially important when using loops: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> Allocator = std.mem.Allocator;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>struct</span> {</span>
<span class=line>    data: *<span class=tok-type>u32</span></span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>getData</span>() !<span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-number>666</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>genFoos</span>(allocator: Allocator, num: <span class=tok-type>usize</span>) ![]Foo {</span>
<span class=line>    <span class=tok-kw>var</span> foos = <span class=tok-kw>try</span> allocator.alloc(Foo, num);</span>
<span class=line>    <span class=tok-kw>errdefer</span> allocator.free(foos);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>for</span>(foos) |*foo, i| {</span>
<span class=line>        foo.data = <span class=tok-kw>try</span> allocator.create(<span class=tok-type>u32</span>);</span>
<span class=line>        <span class=tok-comment>// This errdefer does not last between iterations</span></span>
<span class=line>        <span class=tok-kw>errdefer</span> allocator.destroy(foo.data);</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>// The data for the first 3 foos will be leaked</span></span>
<span class=line>        <span class=tok-kw>if</span>(i &gt;= <span class=tok-number>3</span>) <span class=tok-kw>return</span> <span class=tok-kw>error</span>.TooManyFoos;</span>
<span class=line></span>
<span class=line>        foo.data.* = <span class=tok-kw>try</span> getData();</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>return</span> foos;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"genFoos"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expectError(<span class=tok-kw>error</span>.TooManyFoos, genFoos(std.testing.allocator, <span class=tok-number>5</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.genFoos... OK</span>
<span class=line>[gpa] (err): memory address 0x7f4280372000 leaked:</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:17:40</span>: <span class=t2_0>0x213c3a in genFoos (test)</span></span>
<span class=line>        foo.data = try allocator.create(u32);</span>
<span class=line>                                       <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:31:59</span>: <span class=t2_0>0x21458d in test.genFoos (test)</span></span>
<span class=line>    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));</span>
<span class=line>                                                          <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x21b6a8 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x214e2b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x2148f1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line></span>
<span class=line></span>
<span class=line>[gpa] (err): memory address 0x7f4280372004 leaked:</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:17:40</span>: <span class=t2_0>0x213c3a in genFoos (test)</span></span>
<span class=line>        foo.data = try allocator.create(u32);</span>
<span class=line>                                       <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:31:59</span>: <span class=t2_0>0x21458d in test.genFoos (test)</span></span>
<span class=line>    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));</span>
<span class=line>                                                          <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x21b6a8 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x214e2b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x2148f1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line></span>
<span class=line></span>
<span class=line>[gpa] (err): memory address 0x7f4280372008 leaked:</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:17:40</span>: <span class=t2_0>0x213c3a in genFoos (test)</span></span>
<span class=line>        foo.data = try allocator.create(u32);</span>
<span class=line>                                       <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:31:59</span>: <span class=t2_0>0x21458d in test.genFoos (test)</span></span>
<span class=line>    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));</span>
<span class=line>                                                          <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x21b6a8 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x214e2b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x2148f1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line></span>
<span class=line></span>
<span class=line>All 1 tests passed.</span>
<span class=line>3 errors were logged.</span>
<span class=line>1 tests leaked memory.</span>
<span class=line>error: the following test command failed with exit code 1:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <p> Special care must be taken with code that allocates in a loop to make sure that no memory is leaked when returning an error: </p> <figure><figcaption class=zig-cap><cite class=file>test_errdefer_loop.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> Allocator = std.mem.Allocator;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>struct</span> {</span>
<span class=line>    data: *<span class=tok-type>u32</span></span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>getData</span>() !<span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-number>666</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>genFoos</span>(allocator: Allocator, num: <span class=tok-type>usize</span>) ![]Foo {</span>
<span class=line>    <span class=tok-kw>var</span> foos = <span class=tok-kw>try</span> allocator.alloc(Foo, num);</span>
<span class=line>    <span class=tok-kw>errdefer</span> allocator.free(foos);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Used to track how many foos have been initialized</span></span>
<span class=line>    <span class=tok-comment>// (including their data being allocated)</span></span>
<span class=line>    <span class=tok-kw>var</span> num_allocated: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>errdefer</span> <span class=tok-kw>for</span>(foos[<span class=tok-number>0</span>..num_allocated]) |foo| {</span>
<span class=line>        allocator.destroy(foo.data);</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>for</span>(foos) |*foo, i| {</span>
<span class=line>        foo.data = <span class=tok-kw>try</span> allocator.create(<span class=tok-type>u32</span>);</span>
<span class=line>        num_allocated += <span class=tok-number>1</span>;</span>
<span class=line></span>
<span class=line>        <span class=tok-kw>if</span>(i &gt;= <span class=tok-number>3</span>) <span class=tok-kw>return</span> <span class=tok-kw>error</span>.TooManyFoos;</span>
<span class=line></span>
<span class=line>        foo.data.* = <span class=tok-kw>try</span> getData();</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>return</span> foos;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"genFoos"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expectError(<span class=tok-kw>error</span>.TooManyFoos, genFoos(std.testing.allocator, <span class=tok-number>5</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_errdefer_loop.zig</kbd></span>
<span class=line>1/1 test.genFoos... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> A couple of other tidbits about error handling: </p> <ul> <li>These primitives give enough expressiveness that it's completely practical to have failing to check for an error be a compile error. If you really want to ignore the error, you can add <code><span class=line><span class=tok-kw>catch</span> <span class=tok-kw>unreachable</span></span></code> and get the added benefit of crashing in Debug and ReleaseSafe modes if your assumption was wrong. </li> <li> Since Zig understands error types, it can pre-weight branches in favor of errors not occurring. Just a small optimization benefit that is not available in other languages. </li> </ul> <p>See also:</p><ul> <li><a href=#defer>defer</a></li> <li><a href=#if>if</a></li> <li><a href=#switch>switch</a></li> </ul> <p>An error union is created with the <code><span class=line>!</span></code> binary operator. You can use compile-time reflection to access the child type of an error union:</p> <figure><figcaption class=zig-cap><cite class=file>test_error_union.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"error union"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> foo: <span class=tok-type>anyerror</span>!<span class=tok-type>i32</span> = <span class=tok-null>undefined</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Coerce from child type of an error union:</span></span>
<span class=line>    foo = <span class=tok-number>1234</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Coerce from an error set:</span></span>
<span class=line>    foo = <span class=tok-kw>error</span>.SomeError;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Use compile-time reflection to access the payload type of an error union:</span></span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(<span class=tok-builtin>@typeInfo</span>(<span class=tok-builtin>@TypeOf</span>(foo)).ErrorUnion.payload == <span class=tok-type>i32</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Use compile-time reflection to access the error set type of an error union:</span></span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(<span class=tok-builtin>@typeInfo</span>(<span class=tok-builtin>@TypeOf</span>(foo)).ErrorUnion.error_set == <span class=tok-type>anyerror</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_error_union.zig</kbd></span>
<span class=line>1/1 test.error union... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Merging%20Error%20Sets class=dashAnchor></a><h4 id=Merging-Error-Sets>Merging Error Sets</h4> <p> Use the <code><span class=line>||</span></code> operator to merge two error sets together. The resulting error set contains the errors of both error sets. Doc comments from the left-hand side override doc comments from the right-hand side. In this example, the doc comments for <code><span class=line>C.PathNotFound</span></code> is <code>A doc comment</code>. </p> <p> This is especially useful for functions which return different error sets depending on <a href=#comptime>comptime</a> branches. For example, the Zig standard library uses <code><span class=line>LinuxFileOpenError || WindowsFileOpenError</span></code> for the error set of opening files. </p> <figure><figcaption class=zig-cap><cite class=file>test_merging_error_sets.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> A = <span class=tok-kw>error</span>{</span>
<span class=line>    NotDir,</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>/// A doc comment</span></span>
<span class=line>    PathNotFound,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> B = <span class=tok-kw>error</span>{</span>
<span class=line>    OutOfMemory,</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>/// B doc comment</span></span>
<span class=line>    PathNotFound,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> C = A || B;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>() C!<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>error</span>.NotDir;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"merge error sets"</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (foo()) {</span>
<span class=line>        <span class=tok-builtin>@panic</span>(<span class=tok-str>"unexpected"</span>);</span>
<span class=line>    } <span class=tok-kw>else</span> |err| <span class=tok-kw>switch</span> (err) {</span>
<span class=line>        <span class=tok-kw>error</span>.OutOfMemory =&gt; <span class=tok-builtin>@panic</span>(<span class=tok-str>"unexpected"</span>),</span>
<span class=line>        <span class=tok-kw>error</span>.PathNotFound =&gt; <span class=tok-builtin>@panic</span>(<span class=tok-str>"unexpected"</span>),</span>
<span class=line>        <span class=tok-kw>error</span>.NotDir =&gt; {},</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_merging_error_sets.zig</kbd></span>
<span class=line>1/1 test.merge error sets... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Inferred%20Error%20Sets class=dashAnchor></a><h4 id=Inferred-Error-Sets>Inferred Error Sets</h4> <p> Because many functions in Zig return a possible error, Zig supports inferring the error set. To infer the error set for a function, prepend the <code><span class=line>!</span></code> operator to the function’s return type, like <code><span class=line>!T</span></code>: </p> <figure><figcaption class=zig-cap><cite class=file>inferred_error_sets.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>// With an inferred error set</span></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>add_inferred</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, b: T) !T {</span>
<span class=line>    <span class=tok-kw>var</span> answer: T = <span class=tok-null>undefined</span>;</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>if</span> (<span class=tok-builtin>@addWithOverflow</span>(T, a, b, &amp;answer)) <span class=tok-kw>error</span>.Overflow <span class=tok-kw>else</span> answer;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// With an explicit error set</span></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>add_explicit</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, b: T) Error!T {</span>
<span class=line>    <span class=tok-kw>var</span> answer: T = <span class=tok-null>undefined</span>;</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>if</span> (<span class=tok-builtin>@addWithOverflow</span>(T, a, b, &amp;answer)) <span class=tok-kw>error</span>.Overflow <span class=tok-kw>else</span> answer;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Error = <span class=tok-kw>error</span> {</span>
<span class=line>    Overflow,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"inferred error set"</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (add_inferred(<span class=tok-type>u8</span>, <span class=tok-number>255</span>, <span class=tok-number>1</span>)) |_| <span class=tok-kw>unreachable</span> <span class=tok-kw>else</span> |err| <span class=tok-kw>switch</span> (err) {</span>
<span class=line>        <span class=tok-kw>error</span>.Overflow =&gt; {}, <span class=tok-comment>// ok</span></span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test inferred_error_sets.zig</kbd></span>
<span class=line>1/1 test.inferred error set... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> When a function has an inferred error set, that function becomes generic and thus it becomes trickier to do certain things with it, such as obtain a function pointer, or have an error set that is consistent across different build targets. Additionally, inferred error sets are incompatible with recursion. </p> <p> In these situations, it is recommended to use an explicit error set. You can generally start with an empty error set and let compile errors guide you toward completing the set. </p> <p> These limitations may be overcome in a future version of Zig. </p> <a name=//apple_ref/cpp/Guide/Error%20Return%20Traces class=dashAnchor></a><h3 id=Error-Return-Traces>Error Return Traces</h3> <p> Error Return Traces show all the points in the code that an error was returned to the calling function. This makes it practical to use <a href=#try>try</a> everywhere and then still be able to know what happened if an error ends up bubbling all the way out of your application. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>try</span> foo(<span class=tok-number>12</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(x: <span class=tok-type>i32</span>) !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (x &gt;= <span class=tok-number>5</span>) {</span>
<span class=line>        <span class=tok-kw>try</span> bar();</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        <span class=tok-kw>try</span> bang2();</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bar</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (baz()) {</span>
<span class=line>        <span class=tok-kw>try</span> quux();</span>
<span class=line>    } <span class=tok-kw>else</span> |err| <span class=tok-kw>switch</span> (err) {</span>
<span class=line>        <span class=tok-kw>error</span>.FileNotFound =&gt; <span class=tok-kw>try</span> hello(),</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>baz</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>try</span> bang1();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>quux</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>try</span> bang2();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>hello</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>try</span> bang2();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bang1</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>error</span>.FileNotFound;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bang2</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>error</span>.PermissionDenied;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>error: PermissionDenied</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:34:5</span>: <span class=t2_0>0x20fcb8 in bang1 (test)</span></span>
<span class=line>    return error.FileNotFound;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:22:5</span>: <span class=t2_0>0x20fdb3 in baz (test)</span></span>
<span class=line>    try bang1();</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:38:5</span>: <span class=t2_0>0x20fdd8 in bang2 (test)</span></span>
<span class=line>    return error.PermissionDenied;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:30:5</span>: <span class=t2_0>0x20fe43 in hello (test)</span></span>
<span class=line>    try bang2();</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:17:31</span>: <span class=t2_0>0x20fef5 in bar (test)</span></span>
<span class=line>        error.FileNotFound =&gt; try hello(),</span>
<span class=line>                              <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:7:9</span>: <span class=t2_0>0x20ff63 in foo (test)</span></span>
<span class=line>        try bar();</span>
<span class=line>        <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:2:5</span>: <span class=t2_0>0x20ffb8 in main (test)</span></span>
<span class=line>    try foo(12);</span>
<span class=line>    <span class=t32_1>^</span></span>
</samp></pre></figure> <p> Look closely at this example. This is no stack trace. </p> <p> You can see that the final error bubbled up was <code><span class=line>PermissionDenied</span></code>, but the original error that started this whole thing was <code><span class=line>FileNotFound</span></code>. In the <code><span class=line>bar</span></code> function, the code handles the original error code, and then returns another one, from the switch statement. Error Return Traces make this clear, whereas a stack trace would look like this: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    foo(<span class=tok-number>12</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(x: <span class=tok-type>i32</span>) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (x &gt;= <span class=tok-number>5</span>) {</span>
<span class=line>        bar();</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        bang2();</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bar</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (baz()) {</span>
<span class=line>        quux();</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        hello();</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>baz</span>() <span class=tok-type>bool</span> {</span>
<span class=line>    <span class=tok-kw>return</span> bang1();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>quux</span>() <span class=tok-type>void</span> {</span>
<span class=line>    bang2();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>hello</span>() <span class=tok-type>void</span> {</span>
<span class=line>    bang2();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bang1</span>() <span class=tok-type>bool</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-null>false</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bang2</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-builtin>@panic</span>(<span class=tok-str>"PermissionDenied"</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1637184 panic: PermissionDenied</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:38:5</span>: <span class=t2_0>0x22f3c5 in bang2 (test)</span></span>
<span class=line>    @panic("PermissionDenied");</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:30:10</span>: <span class=t2_0>0x23a558 in hello (test)</span></span>
<span class=line>    bang2();</span>
<span class=line>         <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:17:14</span>: <span class=t2_0>0x22f39a in bar (test)</span></span>
<span class=line>        hello();</span>
<span class=line>             <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:7:12</span>: <span class=t2_0>0x21199d in foo (test)</span></span>
<span class=line>        bar();</span>
<span class=line>           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:2:8</span>: <span class=t2_0>0x21001d in main (test)</span></span>
<span class=line>    foo(12);</span>
<span class=line>       <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f6db in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f1a1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <p> Here, the stack trace does not explain how the control flow in <code><span class=line>bar</span></code> got to the <code><span class=line>hello()</span></code> call. One would have to open a debugger or further instrument the application in order to find out. The error return trace, on the other hand, shows exactly how the error bubbled up. </p> <p> This debugging feature makes it easier to iterate quickly on code that robustly handles all error conditions. This means that Zig developers will naturally find themselves writing correct, robust code in order to increase their development pace. </p> <p> Error Return Traces are enabled by default in <a href=#Debug>Debug</a> and <a href=#ReleaseSafe>ReleaseSafe</a> builds and disabled by default in <a href=#ReleaseFast>ReleaseFast</a> and <a href=#ReleaseSmall>ReleaseSmall</a> builds. </p> <p> There are a few ways to activate this error return tracing feature: </p> <ul> <li>Return an error from main</li> <li>An error makes its way to <code><span class=line><span class=tok-kw>catch</span> <span class=tok-kw>unreachable</span></span></code> and you have not overridden the default panic handler</li> <li>Use <a href=#errorReturnTrace>errorReturnTrace</a> to access the current return trace. You can use <code><span class=line>std.debug.dumpStackTrace</span></code> to print it. This function returns comptime-known <a href=#null>null</a> when building without error return tracing support.</li> </ul> <a name=//apple_ref/cpp/Guide/Implementation%20Details class=dashAnchor></a><h4 id=Implementation-Details>Implementation Details</h4> <p> To analyze performance cost, there are two cases: </p> <ul> <li>when no errors are returned</li> <li>when returning errors</li> </ul> <p> For the case when no errors are returned, the cost is a single memory write operation, only in the first non-failable function in the call graph that calls a failable function, i.e. when a function returning <code><span class=line><span class=tok-type>void</span></span></code> calls a function returning <code><span class=line><span class=tok-kw>error</span></span></code>. This is to initialize this struct in the stack memory: </p> <figure><figcaption class=zig-cap><cite class=file>stack_trace_struct.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> StackTrace = <span class=tok-kw>struct</span> {</span>
<span class=line>    index: <span class=tok-type>usize</span>,</span>
<span class=line>    instruction_addresses: [N]<span class=tok-type>usize</span>,</span>
<span class=line>};</span></code></pre></figure> <p> Here, N is the maximum function call depth as determined by call graph analysis. Recursion is ignored and counts for 2. </p> <p> A pointer to <code><span class=line>StackTrace</span></code> is passed as a secret parameter to every function that can return an error, but it's always the first parameter, so it can likely sit in a register and stay there. </p> <p> That's it for the path when no errors occur. It's practically free in terms of performance. </p> <p> When generating the code for a function that returns an error, just before the <code><span class=line><span class=tok-kw>return</span></span></code> statement (only for the <code><span class=line><span class=tok-kw>return</span></span></code> statements that return errors), Zig generates a call to this function: </p> <figure><figcaption class=zig-cap><cite class=file>zig_return_error_fn.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>// marked as "no-inline" in LLVM IR</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>__zig_return_error</span>(stack_trace: *StackTrace) <span class=tok-type>void</span> {</span>
<span class=line>    stack_trace.instruction_addresses[stack_trace.index] = <span class=tok-builtin>@returnAddress</span>();</span>
<span class=line>    stack_trace.index = (stack_trace.index + <span class=tok-number>1</span>) % N;</span>
<span class=line>}</span></code></pre></figure> <p> The cost is 2 math operations plus some memory reads and writes. The memory accessed is constrained and should remain cached for the duration of the error return bubbling. </p> <p> As for code size cost, 1 function call before a return statement is no big deal. Even so, I have <a href=https://github.com/ziglang/zig/issues/690>a plan</a> to make the call to <code><span class=line>__zig_return_error</span></code> a tail call, which brings the code size cost down to actually zero. What is a return statement in code without error return tracing can become a jump instruction in code with error return tracing. </p> <a name=//apple_ref/cpp/Guide/Optionals class=dashAnchor></a><h2 id=Optionals>Optionals</h2> <p> One area that Zig provides safety without compromising efficiency or readability is with the optional type. </p> <p> The question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>// normal integer</span></span>
<span class=line><span class=tok-kw>const</span> normal_int: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// optional integer</span></span>
<span class=line><span class=tok-kw>const</span> optional_int: ?<span class=tok-type>i32</span> = <span class=tok-number>5678</span>;</span></code></pre></figure> <p> Now the variable <code><span class=line>optional_int</span></code> could be an <code><span class=line><span class=tok-type>i32</span></span></code>, or <code><span class=line><span class=tok-null>null</span></span></code>. </p> <p> Instead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being <a href=https://www.lucidchart.com/techblog/2015/08/31/the-worst-mistake-of-computer-science/ >the worst mistake of computer science</a>. </p> <p>Zig does not have them.</p> <p> Instead, you can use an optional pointer. This secretly compiles down to a normal pointer, since we know we can use 0 as the null value for the optional type. But the compiler can check your work and make sure you don't assign null to something that can't be null. </p> <p> Typically the downside of not having null is that it makes the code more verbose to write. But, let's compare some equivalent C code and Zig code. </p> <p> Task: call malloc, if the result is null, return null. </p> <p>C code</p> <figure><figcaption class=c-cap><cite class=file>call_malloc_in_c.c</cite></figcaption><pre><code><span class=line>// malloc prototype included for reference</span>
<span class=line>void *malloc(size_t size);</span>
<span class=line></span>
<span class=line>struct Foo *do_a_thing(void) {</span>
<span class=line>    char *ptr = malloc(1234);</span>
<span class=line>    if (!ptr) return NULL;</span>
<span class=line>    // ...</span>
<span class=line>}</span></code></pre></figure> <p>Zig code</p> <figure><figcaption class=zig-cap><cite class=file>call_malloc_from_zig.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>// malloc prototype included for reference</span></span>
<span class=line><span class=tok-kw>extern</span> <span class=tok-kw>fn</span> <span class=tok-fn>malloc</span>(size: size_t) ?*<span class=tok-type>u8</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>doAThing</span>() ?*Foo {</span>
<span class=line>    <span class=tok-kw>const</span> ptr = malloc(<span class=tok-number>1234</span>) <span class=tok-kw>orelse</span> <span class=tok-kw>return</span> <span class=tok-null>null</span>;</span>
<span class=line>    _ = ptr; <span class=tok-comment>// ...</span></span>
<span class=line>}</span></code></pre></figure> <p> Here, Zig is at least as convenient, if not more, than C. And, the type of "ptr" is <code><span class=line>*<span class=tok-type>u8</span></span></code> <em>not</em> <code><span class=line>?*<span class=tok-type>u8</span></span></code>. The <code><span class=line><span class=tok-kw>orelse</span></span></code> keyword unwrapped the optional type and therefore <code><span class=line>ptr</span></code> is guaranteed to be non-null everywhere it is used in the function. </p> <p> The other form of checking against NULL you might see looks like this: </p> <figure><figcaption class=c-cap><cite class=file>checking_null_in_c.c</cite></figcaption><pre><code><span class=line>void do_a_thing(struct Foo *foo) {</span>
<span class=line>    // do some stuff</span>
<span class=line></span>
<span class=line>    if (foo) {</span>
<span class=line>        do_something_with_foo(foo);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    // do some stuff</span>
<span class=line>}</span></code></pre></figure> <p> In Zig you can accomplish the same thing: </p> <figure><figcaption class=zig-cap><cite class=file>checking_null_in_zig.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>struct</span>{};</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>doSomethingWithFoo</span>(foo: *Foo) <span class=tok-type>void</span> { _ = foo; }</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>doAThing</span>(optional_foo: ?*Foo) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-comment>// do some stuff</span></span>
<span class=line></span>
<span class=line>    <span class=tok-kw>if</span> (optional_foo) |foo| {</span>
<span class=line>      doSomethingWithFoo(foo);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// do some stuff</span></span>
<span class=line>}</span></code></pre></figure> <p> Once again, the notable thing here is that inside the if block, <code><span class=line>foo</span></code> is no longer an optional pointer, it is a pointer, which cannot be null. </p> <p> One benefit to this is that functions which take pointers as arguments can be annotated with the "nonnull" attribute - <code>__attribute__((nonnull))</code> in <a href=https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html>GCC</a>. The optimizer can sometimes make better decisions knowing that pointer arguments cannot be null. </p> <a name=//apple_ref/cpp/Guide/Optional%20Type class=dashAnchor></a><h3 id=Optional-Type>Optional Type</h3> <p>An optional is created by putting <code><span class=line>?</span></code> in front of a type. You can use compile-time reflection to access the child type of an optional:</p> <figure><figcaption class=zig-cap><cite class=file>test_optional_type.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"optional type"</span> {</span>
<span class=line>    <span class=tok-comment>// Declare an optional and coerce from null:</span></span>
<span class=line>    <span class=tok-kw>var</span> foo: ?<span class=tok-type>i32</span> = <span class=tok-null>null</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Coerce from child type of an optional</span></span>
<span class=line>    foo = <span class=tok-number>1234</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Use compile-time reflection to access the child type of the optional:</span></span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(<span class=tok-builtin>@typeInfo</span>(<span class=tok-builtin>@TypeOf</span>(foo)).Optional.child == <span class=tok-type>i32</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_optional_type.zig</kbd></span>
<span class=line>1/1 test.optional type... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Keyword/null class=dashAnchor></a><h3 id=null>null</h3> <p> Just like <a href="#undefined">undefined</a>, <code><span class=line><span class=tok-null>null</span></span></code> has its own type, and the only way to use it is to cast it to a different type: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> optional_value: ?<span class=tok-type>i32</span> = <span class=tok-null>null</span>;</span></code></pre></figure> <a name=//apple_ref/cpp/Guide/Optional%20Pointers class=dashAnchor></a><h3 id=Optional-Pointers>Optional Pointers</h3> <p>An optional pointer is guaranteed to be the same size as a pointer. The <code><span class=line><span class=tok-null>null</span></span></code> of the optional is guaranteed to be address 0.</p> <figure><figcaption class=zig-cap><cite class=file>test_optional_pointer.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"optional pointers"</span> {</span>
<span class=line>    <span class=tok-comment>// Pointers cannot be null. If you want a null pointer, use the optional</span></span>
<span class=line>    <span class=tok-comment>// prefix `?` to make the pointer type optional.</span></span>
<span class=line>    <span class=tok-kw>var</span> ptr: ?*<span class=tok-type>i32</span> = <span class=tok-null>null</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1</span>;</span>
<span class=line>    ptr = &amp;x;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(ptr.?.* == <span class=tok-number>1</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Optional pointers are the same size as normal pointers, because pointer</span></span>
<span class=line>    <span class=tok-comment>// value 0 is used as the null value.</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@sizeOf</span>(?*<span class=tok-type>i32</span>) == <span class=tok-builtin>@sizeOf</span>(*<span class=tok-type>i32</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_optional_pointer.zig</kbd></span>
<span class=line>1/1 test.optional pointers... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Casting class=dashAnchor></a><h2 id=Casting>Casting</h2> <p> A <strong>type cast</strong> converts a value of one type to another. Zig has <a href=#Type-Coercion>Type Coercion</a> for conversions that are known to be completely safe and unambiguous, and <a href=#Explicit-Casts>Explicit Casts</a> for conversions that one would not want to happen on accident. There is also a third kind of type conversion called <a href=#Peer-Type-Resolution>Peer Type Resolution</a> for the case when a result type must be decided given multiple operand types. </p> <a name=//apple_ref/cpp/Guide/Type%20Coercion class=dashAnchor></a><h3 id=Type-Coercion>Type Coercion</h3> <p> Type coercion occurs when one type is expected, but different type is provided: </p> <figure><figcaption class=zig-cap><cite class=file>type_coercion.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"type coercion - variable declaration"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u8</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>u16</span> = a;</span>
<span class=line>    _ = b;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"type coercion - function call"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u8</span> = <span class=tok-number>1</span>;</span>
<span class=line>    foo(a);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(b: <span class=tok-type>u16</span>) <span class=tok-type>void</span> {</span>
<span class=line>    _ = b;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"type coercion - @as builtin"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u8</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b = <span class=tok-builtin>@as</span>(<span class=tok-type>u16</span>, a);</span>
<span class=line>    _ = b;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test type_coercion.zig</kbd></span>
<span class=line>1/3 test.type coercion - variable declaration... OK</span>
<span class=line>2/3 test.type coercion - function call... OK</span>
<span class=line>3/3 test.type coercion - @as builtin... OK</span>
<span class=line>All 3 tests passed.</span>
</samp></pre></figure> <p> Type coercions are only allowed when it is completely unambiguous how to get from one type to another, and the transformation is guaranteed to be safe. There is one exception, which is <a href=#C-Pointers>C Pointers</a>. </p> <a name=//apple_ref/cpp/Guide/Type%20Coercion%3A%20Stricter%20Qualification class=dashAnchor></a><h4 id=Type-Coercion-Stricter-Qualification>Type Coercion: Stricter Qualification</h4> <p> Values which have the same representation at runtime can be cast to increase the strictness of the qualifiers, no matter how nested the qualifiers are: </p> <ul> <li><code><span class=line><span class=tok-kw>const</span></span></code> - non-const to const is allowed</li> <li><code><span class=line><span class=tok-kw>volatile</span></span></code> - non-volatile to volatile is allowed</li> <li><code><span class=line><span class=tok-kw>align</span></span></code> - bigger to smaller alignment is allowed </li> <li><a href=#Error-Set-Type>error sets</a> to supersets is allowed</li> </ul> <p> These casts are no-ops at runtime since the value representation does not change. </p> <figure><figcaption class=zig-cap><cite class=file>no_op_casts.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"type coercion - const qualification"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>i32</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: *<span class=tok-type>i32</span> = &amp;a;</span>
<span class=line>    foo(b);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(_: *<span class=tok-kw>const</span> <span class=tok-type>i32</span>) <span class=tok-type>void</span> {}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test no_op_casts.zig</kbd></span>
<span class=line>1/1 test.type coercion - const qualification... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> In addition, pointers coerce to const optional pointers: </p> <figure><figcaption class=zig-cap><cite class=file>pointer_coerce_const_optional.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line><span class=tok-kw>const</span> mem = std.mem;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"cast *[1][*]const u8 to [*]const ?[*]const u8"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> window_name = [<span class=tok-number>1</span>][*]<span class=tok-kw>const</span> <span class=tok-type>u8</span>{<span class=tok-str>"window name"</span>};</span>
<span class=line>    <span class=tok-kw>const</span> x: [*]<span class=tok-kw>const</span> ?[*]<span class=tok-kw>const</span> <span class=tok-type>u8</span> = &amp;window_name;</span>
<span class=line>    <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, std.mem.sliceTo(<span class=tok-builtin>@ptrCast</span>([*:<span class=tok-number>0</span>]<span class=tok-kw>const</span> <span class=tok-type>u8</span>, x[<span class=tok-number>0</span>].?), <span class=tok-number>0</span>), <span class=tok-str>"window name"</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test pointer_coerce_const_optional.zig</kbd></span>
<span class=line>1/1 test.cast *[1][*]const u8 to [*]const ?[*]const u8... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Type%20Coercion%3A%20Integer%20and%20Float%20Widening class=dashAnchor></a><h4 id=Type-Coercion-Integer-and-Float-Widening>Type Coercion: Integer and Float Widening</h4> <p> <a href=#Integers>Integers</a> coerce to integer types which can represent every value of the old type, and likewise <a href=#Floats>Floats</a> coerce to float types which can represent every value of the old type. </p> <figure><figcaption class=zig-cap><cite class=file>test_integer_widening.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> builtin = <span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line><span class=tok-kw>const</span> mem = std.mem;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"integer widening"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u8</span> = <span class=tok-number>250</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>u16</span> = a;</span>
<span class=line>    <span class=tok-kw>var</span> c: <span class=tok-type>u32</span> = b;</span>
<span class=line>    <span class=tok-kw>var</span> d: <span class=tok-type>u64</span> = c;</span>
<span class=line>    <span class=tok-kw>var</span> e: <span class=tok-type>u64</span> = d;</span>
<span class=line>    <span class=tok-kw>var</span> f: <span class=tok-type>u128</span> = e;</span>
<span class=line>    <span class=tok-kw>try</span> expect(f == a);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"implicit unsigned integer to signed integer"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u8</span> = <span class=tok-number>250</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>i16</span> = a;</span>
<span class=line>    <span class=tok-kw>try</span> expect(b == <span class=tok-number>250</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"float widening"</span> {</span>
<span class=line>    <span class=tok-comment>// Note: there is an open issue preventing this from working on aarch64:</span></span>
<span class=line>    <span class=tok-comment>// https://github.com/ziglang/zig/issues/3282</span></span>
<span class=line>    <span class=tok-kw>if</span> (builtin.target.cpu.arch == .aarch64) <span class=tok-kw>return</span> <span class=tok-kw>error</span>.SkipZigTest;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>f16</span> = <span class=tok-number>12.34</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>f32</span> = a;</span>
<span class=line>    <span class=tok-kw>var</span> c: <span class=tok-type>f64</span> = b;</span>
<span class=line>    <span class=tok-kw>var</span> d: <span class=tok-type>f128</span> = c;</span>
<span class=line>    <span class=tok-kw>try</span> expect(d == a);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_integer_widening.zig</kbd></span>
<span class=line>1/3 test.integer widening... OK</span>
<span class=line>2/3 test.implicit unsigned integer to signed integer... OK</span>
<span class=line>3/3 test.float widening... OK</span>
<span class=line>All 3 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Type%20Coercion%3A%20Coercion%20Float%20to%20Int class=dashAnchor></a><h4 id=Type-Coercion-Coercion-Float-to-Int>Type Coercion: Coercion Float to Int</h4> <p> A compiler error is appropriate because this ambiguous expression leaves the compiler two choices about the coercion. </p> <ul> <li>Cast <code><span class=line><span class=tok-number>54.0</span></span></code> to <code><span class=line><span class=tok-type>comptime_int</span></span></code> resulting in <code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>comptime_int</span>, <span class=tok-number>10</span>)</span></code>, which is casted to <code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>f32</span>, <span class=tok-number>10</span>)</span></code></li> <li>Cast <code><span class=line><span class=tok-number>5</span></span></code> to <code><span class=line><span class=tok-type>comptime_float</span></span></code> resulting in <code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>comptime_float</span>, <span class=tok-number>10.8</span>)</span></code>, which is casted to <code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>f32</span>, <span class=tok-number>10.8</span>)</span></code></li> </ul> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>// Compile time coercion of float to int</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"implicit cast to comptime_int"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> f: <span class=tok-type>f32</span> = <span class=tok-number>54.0</span> / <span class=tok-number>5</span>;</span>
<span class=line>    _ = f;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig -fstage1</kbd></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:3:18: </span><span class=t31_1>error: </span><span class=t0_1>float value 54.000000 cannot be coerced to type 'comptime_int'</span></span>
<span class=line>    var f: f32 = 54.0 / 5;</span>
<span class=line>                 <span class=t32_1>^</span></span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Type%20Coercion%3A%20Slices%2C%20Arrays%20and%20Pointers class=dashAnchor></a><h4 id=Type-Coercion-Slices-Arrays-and-Pointers>Type Coercion: Slices, Arrays and Pointers</h4> <figure><figcaption class=zig-cap><cite class=file>coerce__slices_arrays_and_ptrs.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-comment>// You can assign constant pointers to arrays to a slice with</span></span>
<span class=line><span class=tok-comment>// const modifier on the element type. Useful in particular for</span></span>
<span class=line><span class=tok-comment>// String literals.</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"*const [N]T to []const T"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x1: []<span class=tok-kw>const</span> <span class=tok-type>u8</span> = <span class=tok-str>"hello"</span>;</span>
<span class=line>    <span class=tok-kw>var</span> x2: []<span class=tok-kw>const</span> <span class=tok-type>u8</span> = &amp;[<span class=tok-number>5</span>]<span class=tok-type>u8</span>{ <span class=tok-str>'h'</span>, <span class=tok-str>'e'</span>, <span class=tok-str>'l'</span>, <span class=tok-str>'l'</span>, <span class=tok-number>111</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>u8</span>, x1, x2));</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> y: []<span class=tok-kw>const</span> <span class=tok-type>f32</span> = &amp;[<span class=tok-number>2</span>]<span class=tok-type>f32</span>{ <span class=tok-number>1.2</span>, <span class=tok-number>3.4</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(y[<span class=tok-number>0</span>] == <span class=tok-number>1.2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Likewise, it works when the destination type is an error union.</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"*const [N]T to E![]const T"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x1: <span class=tok-type>anyerror</span>![]<span class=tok-kw>const</span> <span class=tok-type>u8</span> = <span class=tok-str>"hello"</span>;</span>
<span class=line>    <span class=tok-kw>var</span> x2: <span class=tok-type>anyerror</span>![]<span class=tok-kw>const</span> <span class=tok-type>u8</span> = &amp;[<span class=tok-number>5</span>]<span class=tok-type>u8</span>{ <span class=tok-str>'h'</span>, <span class=tok-str>'e'</span>, <span class=tok-str>'l'</span>, <span class=tok-str>'l'</span>, <span class=tok-number>111</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>u8</span>, <span class=tok-kw>try</span> x1, <span class=tok-kw>try</span> x2));</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> y: <span class=tok-type>anyerror</span>![]<span class=tok-kw>const</span> <span class=tok-type>f32</span> = &amp;[<span class=tok-number>2</span>]<span class=tok-type>f32</span>{ <span class=tok-number>1.2</span>, <span class=tok-number>3.4</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect((<span class=tok-kw>try</span> y)[<span class=tok-number>0</span>] == <span class=tok-number>1.2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Likewise, it works when the destination type is an optional.</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"*const [N]T to ?[]const T"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x1: ?[]<span class=tok-kw>const</span> <span class=tok-type>u8</span> = <span class=tok-str>"hello"</span>;</span>
<span class=line>    <span class=tok-kw>var</span> x2: ?[]<span class=tok-kw>const</span> <span class=tok-type>u8</span> = &amp;[<span class=tok-number>5</span>]<span class=tok-type>u8</span>{ <span class=tok-str>'h'</span>, <span class=tok-str>'e'</span>, <span class=tok-str>'l'</span>, <span class=tok-str>'l'</span>, <span class=tok-number>111</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>u8</span>, x1.?, x2.?));</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> y: ?[]<span class=tok-kw>const</span> <span class=tok-type>f32</span> = &amp;[<span class=tok-number>2</span>]<span class=tok-type>f32</span>{ <span class=tok-number>1.2</span>, <span class=tok-number>3.4</span> };</span>
<span class=line>    <span class=tok-kw>try</span> expect(y.?[<span class=tok-number>0</span>] == <span class=tok-number>1.2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// In this cast, the array length becomes the slice length.</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"*[N]T to []T"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> buf: [<span class=tok-number>5</span>]<span class=tok-type>u8</span> = <span class=tok-str>"hello"</span>.*;</span>
<span class=line>    <span class=tok-kw>const</span> x: []<span class=tok-type>u8</span> = &amp;buf;</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>u8</span>, x, <span class=tok-str>"hello"</span>));</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> buf2 = [<span class=tok-number>2</span>]<span class=tok-type>f32</span>{ <span class=tok-number>1.2</span>, <span class=tok-number>3.4</span> };</span>
<span class=line>    <span class=tok-kw>const</span> x2: []<span class=tok-kw>const</span> <span class=tok-type>f32</span> = &amp;buf2;</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>f32</span>, x2, &amp;[<span class=tok-number>2</span>]<span class=tok-type>f32</span>{ <span class=tok-number>1.2</span>, <span class=tok-number>3.4</span> }));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Single-item pointers to arrays can be coerced to many-item pointers.</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"*[N]T to [*]T"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> buf: [<span class=tok-number>5</span>]<span class=tok-type>u8</span> = <span class=tok-str>"hello"</span>.*;</span>
<span class=line>    <span class=tok-kw>const</span> x: [*]<span class=tok-type>u8</span> = &amp;buf;</span>
<span class=line>    <span class=tok-kw>try</span> expect(x[<span class=tok-number>4</span>] == <span class=tok-str>'o'</span>);</span>
<span class=line>    <span class=tok-comment>// x[5] would be an uncaught out of bounds pointer dereference!</span></span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Likewise, it works when the destination type is an optional.</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"*[N]T to ?[*]T"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> buf: [<span class=tok-number>5</span>]<span class=tok-type>u8</span> = <span class=tok-str>"hello"</span>.*;</span>
<span class=line>    <span class=tok-kw>const</span> x: ?[*]<span class=tok-type>u8</span> = &amp;buf;</span>
<span class=line>    <span class=tok-kw>try</span> expect(x.?[<span class=tok-number>4</span>] == <span class=tok-str>'o'</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// Single-item pointers can be cast to len-1 single-item arrays.</span></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"*T to *[1]T"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line>    <span class=tok-kw>const</span> y: *[<span class=tok-number>1</span>]<span class=tok-type>i32</span> = &amp;x;</span>
<span class=line>    <span class=tok-kw>const</span> z: [*]<span class=tok-type>i32</span> = y;</span>
<span class=line>    <span class=tok-kw>try</span> expect(z[<span class=tok-number>0</span>] == <span class=tok-number>1234</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test coerce__slices_arrays_and_ptrs.zig</kbd></span>
<span class=line>1/7 test.*const [N]T to []const T... OK</span>
<span class=line>2/7 test.*const [N]T to E![]const T... OK</span>
<span class=line>3/7 test.*const [N]T to ?[]const T... OK</span>
<span class=line>4/7 test.*[N]T to []T... OK</span>
<span class=line>5/7 test.*[N]T to [*]T... OK</span>
<span class=line>6/7 test.*[N]T to ?[*]T... OK</span>
<span class=line>7/7 test.*T to *[1]T... OK</span>
<span class=line>All 7 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#C-Pointers>C Pointers</a></li> </ul> <a name=//apple_ref/cpp/Guide/Type%20Coercion%3A%20Optionals class=dashAnchor></a><h4 id=Type-Coercion-Optionals>Type Coercion: Optionals</h4> <p> The payload type of <a href=#Optionals>Optionals</a>, as well as <a href=#null>null</a>, coerce to the optional type. </p> <figure><figcaption class=zig-cap><cite class=file>test_coerce_optionals.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"coerce to optionals"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x: ?<span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line>    <span class=tok-kw>const</span> y: ?<span class=tok-type>i32</span> = <span class=tok-null>null</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(x.? == <span class=tok-number>1234</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(y == <span class=tok-null>null</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_coerce_optionals.zig</kbd></span>
<span class=line>1/1 test.coerce to optionals... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>It works nested inside the <a href=#Error-Union-Type>Error Union Type</a>, too:</p> <figure><figcaption class=zig-cap><cite class=file>test_coerce_optional_wrapped_error_union.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"coerce to optionals wrapped in error union"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x: <span class=tok-type>anyerror</span>!?<span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line>    <span class=tok-kw>const</span> y: <span class=tok-type>anyerror</span>!?<span class=tok-type>i32</span> = <span class=tok-null>null</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect((<span class=tok-kw>try</span> x).? == <span class=tok-number>1234</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect((<span class=tok-kw>try</span> y) == <span class=tok-null>null</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_coerce_optional_wrapped_error_union.zig</kbd></span>
<span class=line>1/1 test.coerce to optionals wrapped in error union... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Type%20Coercion%3A%20Error%20Unions class=dashAnchor></a><h4 id=Type-Coercion-Error-Unions>Type Coercion: Error Unions</h4> <p>The payload type of an <a href=#Error-Union-Type>Error Union Type</a> as well as the <a href=#Error-Set-Type>Error Set Type</a> coerce to the error union type: </p> <figure><figcaption class=zig-cap><cite class=file>test_coerce_to_error_union.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"coercion to error unions"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x: <span class=tok-type>anyerror</span>!<span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line>    <span class=tok-kw>const</span> y: <span class=tok-type>anyerror</span>!<span class=tok-type>i32</span> = <span class=tok-kw>error</span>.Failure;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect((<span class=tok-kw>try</span> x) == <span class=tok-number>1234</span>);</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expectError(<span class=tok-kw>error</span>.Failure, y);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_coerce_to_error_union.zig</kbd></span>
<span class=line>1/1 test.coercion to error unions... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Type%20Coercion%3A%20Compile-Time%20Known%20Numbers class=dashAnchor></a><h4 id=Type-Coercion-Compile-Time-Known-Numbers>Type Coercion: Compile-Time Known Numbers</h4> <p>When a number is <a href=#comptime>comptime</a>-known to be representable in the destination type, it may be coerced: </p> <figure><figcaption class=zig-cap><cite class=file>test_coerce_large_to_small.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"coercing large integer type to smaller one when value is comptime known to fit"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x: <span class=tok-type>u64</span> = <span class=tok-number>255</span>;</span>
<span class=line>    <span class=tok-kw>const</span> y: <span class=tok-type>u8</span> = x;</span>
<span class=line>    <span class=tok-kw>try</span> expect(y == <span class=tok-number>255</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_coerce_large_to_small.zig</kbd></span>
<span class=line>1/1 test.coercing large integer type to smaller one when value is comptime known to fit... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Type%20Coercion%3A%20unions%20and%20enums class=dashAnchor></a><h4 id=Type-Coercion-unions-and-enums>Type Coercion: unions and enums</h4> <p>Tagged unions can be coerced to enums, and enums can be coerced to tagged unions when they are <a href=#comptime>comptime</a>-known to be a field of the union that has only one possible value, such as <a href=#void>void</a>: </p> <figure><figcaption class=zig-cap><cite class=file>test_coerce_unions_enums.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> E = <span class=tok-kw>enum</span> {</span>
<span class=line>    one,</span>
<span class=line>    two,</span>
<span class=line>    three,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> U = <span class=tok-kw>union</span>(E) {</span>
<span class=line>    one: <span class=tok-type>i32</span>,</span>
<span class=line>    two: <span class=tok-type>f32</span>,</span>
<span class=line>    three,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"coercion between unions and enums"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> u = U{ .two = <span class=tok-number>12.34</span> };</span>
<span class=line>    <span class=tok-kw>var</span> e: E = u;</span>
<span class=line>    <span class=tok-kw>try</span> expect(e == E.two);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> three = E.three;</span>
<span class=line>    <span class=tok-kw>var</span> another_u: U = three;</span>
<span class=line>    <span class=tok-kw>try</span> expect(another_u == E.three);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test_coerce_unions_enums.zig</kbd></span>
<span class=line>1/1 test.coercion between unions and enums... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#union>union</a></li> <li><a href=#enum>enum</a></li> </ul> <a name="//apple_ref/cpp/Guide/Type%20Coercion%3A%20undefined" class=dashAnchor></a><h4 id="Type-Coercion-undefined">Type Coercion: undefined</h4> <p><a href="#undefined">undefined</a> can be cast to any type.</p> <a name=//apple_ref/cpp/Guide/Explicit%20Casts class=dashAnchor></a><h3 id=Explicit-Casts>Explicit Casts</h3> <p> Explicit casts are performed via <a href=#Builtin-Functions>Builtin Functions</a>. Some explicit casts are safe; some are not. Some explicit casts perform language-level assertions; some do not. Some explicit casts are no-ops at runtime; some are not. </p> <ul> <li><a href=#bitCast>@bitCast</a> - change type but maintain bit representation</li> <li><a href=#alignCast>@alignCast</a> - make a pointer have more alignment</li> <li><a href=#boolToInt>@boolToInt</a> - convert true to 1 and false to 0</li> <li><a href=#enumToInt>@enumToInt</a> - obtain the integer tag value of an enum or tagged union</li> <li><a href=#errSetCast>@errSetCast</a> - convert to a smaller error set</li> <li><a href=#errorToInt>@errorToInt</a> - obtain the integer value of an error code</li> <li><a href=#floatCast>@floatCast</a> - convert a larger float to a smaller float</li> <li><a href=#floatToInt>@floatToInt</a> - obtain the integer part of a float value</li> <li><a href=#intCast>@intCast</a> - convert between integer types</li> <li><a href=#intToEnum>@intToEnum</a> - obtain an enum value based on its integer tag value</li> <li><a href=#intToError>@intToError</a> - obtain an error code based on its integer value</li> <li><a href=#intToFloat>@intToFloat</a> - convert an integer to a float value</li> <li><a href=#intToPtr>@intToPtr</a> - convert an address to a pointer</li> <li><a href=#ptrCast>@ptrCast</a> - convert between pointer types</li> <li><a href=#ptrToInt>@ptrToInt</a> - obtain the address of a pointer</li> <li><a href=#truncate>@truncate</a> - convert between integer types, chopping off bits</li> </ul> <a name=//apple_ref/cpp/Guide/Peer%20Type%20Resolution class=dashAnchor></a><h3 id=Peer-Type-Resolution>Peer Type Resolution</h3> <p>Peer Type Resolution occurs in these places:</p> <ul> <li><a href=#switch>switch</a> expressions</li> <li><a href=#if>if</a> expressions</li> <li><a href=#while>while</a> expressions</li> <li><a href=#for>for</a> expressions</li> <li>Multiple break statements in a block</li> <li>Some <a href=#Table-of-Operators>binary operations</a></li> </ul> <p> This kind of type resolution chooses a type that all peer types can coerce into. Here are some examples: </p> <figure><figcaption class=zig-cap><cite class=file>peer_type_resolution.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line><span class=tok-kw>const</span> mem = std.mem;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"peer resolve int widening"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>i8</span> = <span class=tok-number>12</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>i16</span> = <span class=tok-number>34</span>;</span>
<span class=line>    <span class=tok-kw>var</span> c = a + b;</span>
<span class=line>    <span class=tok-kw>try</span> expect(c == <span class=tok-number>46</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(c) == <span class=tok-type>i16</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"peer resolve arrays of different size to const slice"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, boolToStr(<span class=tok-null>true</span>), <span class=tok-str>"true"</span>));</span>
<span class=line>    <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, boolToStr(<span class=tok-null>false</span>), <span class=tok-str>"false"</span>));</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, boolToStr(<span class=tok-null>true</span>), <span class=tok-str>"true"</span>));</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, boolToStr(<span class=tok-null>false</span>), <span class=tok-str>"false"</span>));</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>boolToStr</span>(b: <span class=tok-type>bool</span>) []<span class=tok-kw>const</span> <span class=tok-type>u8</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>if</span> (b) <span class=tok-str>"true"</span> <span class=tok-kw>else</span> <span class=tok-str>"false"</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"peer resolve array and const slice"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> testPeerResolveArrayConstSlice(<span class=tok-null>true</span>);</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> testPeerResolveArrayConstSlice(<span class=tok-null>true</span>);</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>testPeerResolveArrayConstSlice</span>(b: <span class=tok-type>bool</span>) !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> value1 = <span class=tok-kw>if</span> (b) <span class=tok-str>"aoeu"</span> <span class=tok-kw>else</span> <span class=tok-builtin>@as</span>([]<span class=tok-kw>const</span> <span class=tok-type>u8</span>, <span class=tok-str>"zz"</span>);</span>
<span class=line>    <span class=tok-kw>const</span> value2 = <span class=tok-kw>if</span> (b) <span class=tok-builtin>@as</span>([]<span class=tok-kw>const</span> <span class=tok-type>u8</span>, <span class=tok-str>"zz"</span>) <span class=tok-kw>else</span> <span class=tok-str>"aoeu"</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, value1, <span class=tok-str>"aoeu"</span>));</span>
<span class=line>    <span class=tok-kw>try</span> expect(mem.eql(<span class=tok-type>u8</span>, value2, <span class=tok-str>"zz"</span>));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"peer type resolution: ?T and T"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(peerTypeTAndOptionalT(<span class=tok-null>true</span>, <span class=tok-null>false</span>).? == <span class=tok-number>0</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(peerTypeTAndOptionalT(<span class=tok-null>false</span>, <span class=tok-null>false</span>).? == <span class=tok-number>3</span>);</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-kw>try</span> expect(peerTypeTAndOptionalT(<span class=tok-null>true</span>, <span class=tok-null>false</span>).? == <span class=tok-number>0</span>);</span>
<span class=line>        <span class=tok-kw>try</span> expect(peerTypeTAndOptionalT(<span class=tok-null>false</span>, <span class=tok-null>false</span>).? == <span class=tok-number>3</span>);</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>peerTypeTAndOptionalT</span>(c: <span class=tok-type>bool</span>, b: <span class=tok-type>bool</span>) ?<span class=tok-type>usize</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (c) {</span>
<span class=line>        <span class=tok-kw>return</span> <span class=tok-kw>if</span> (b) <span class=tok-null>null</span> <span class=tok-kw>else</span> <span class=tok-builtin>@as</span>(<span class=tok-type>usize</span>, <span class=tok-number>0</span>);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-builtin>@as</span>(<span class=tok-type>usize</span>, <span class=tok-number>3</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"peer type resolution: *[0]u8 and []const u8"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(peerTypeEmptyArrayAndSlice(<span class=tok-null>true</span>, <span class=tok-str>"hi"</span>).len == <span class=tok-number>0</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(peerTypeEmptyArrayAndSlice(<span class=tok-null>false</span>, <span class=tok-str>"hi"</span>).len == <span class=tok-number>1</span>);</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-kw>try</span> expect(peerTypeEmptyArrayAndSlice(<span class=tok-null>true</span>, <span class=tok-str>"hi"</span>).len == <span class=tok-number>0</span>);</span>
<span class=line>        <span class=tok-kw>try</span> expect(peerTypeEmptyArrayAndSlice(<span class=tok-null>false</span>, <span class=tok-str>"hi"</span>).len == <span class=tok-number>1</span>);</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>peerTypeEmptyArrayAndSlice</span>(a: <span class=tok-type>bool</span>, slice: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) []<span class=tok-kw>const</span> <span class=tok-type>u8</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (a) {</span>
<span class=line>        <span class=tok-kw>return</span> &amp;[_]<span class=tok-type>u8</span>{};</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>return</span> slice[<span class=tok-number>0</span>..<span class=tok-number>1</span>];</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"peer type resolution: *[0]u8, []const u8, and anyerror![]u8"</span> {</span>
<span class=line>    {</span>
<span class=line>        <span class=tok-kw>var</span> data = <span class=tok-str>"hi"</span>.*;</span>
<span class=line>        <span class=tok-kw>const</span> slice = data[<span class=tok-number>0</span>..];</span>
<span class=line>        <span class=tok-kw>try</span> expect((<span class=tok-kw>try</span> peerTypeEmptyArrayAndSliceAndError(<span class=tok-null>true</span>, slice)).len == <span class=tok-number>0</span>);</span>
<span class=line>        <span class=tok-kw>try</span> expect((<span class=tok-kw>try</span> peerTypeEmptyArrayAndSliceAndError(<span class=tok-null>false</span>, slice)).len == <span class=tok-number>1</span>);</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-kw>var</span> data = <span class=tok-str>"hi"</span>.*;</span>
<span class=line>        <span class=tok-kw>const</span> slice = data[<span class=tok-number>0</span>..];</span>
<span class=line>        <span class=tok-kw>try</span> expect((<span class=tok-kw>try</span> peerTypeEmptyArrayAndSliceAndError(<span class=tok-null>true</span>, slice)).len == <span class=tok-number>0</span>);</span>
<span class=line>        <span class=tok-kw>try</span> expect((<span class=tok-kw>try</span> peerTypeEmptyArrayAndSliceAndError(<span class=tok-null>false</span>, slice)).len == <span class=tok-number>1</span>);</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>peerTypeEmptyArrayAndSliceAndError</span>(a: <span class=tok-type>bool</span>, slice: []<span class=tok-type>u8</span>) <span class=tok-type>anyerror</span>![]<span class=tok-type>u8</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (a) {</span>
<span class=line>        <span class=tok-kw>return</span> &amp;[_]<span class=tok-type>u8</span>{};</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>return</span> slice[<span class=tok-number>0</span>..<span class=tok-number>1</span>];</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"peer type resolution: *const T and ?*T"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> a = <span class=tok-builtin>@intToPtr</span>(*<span class=tok-kw>const</span> <span class=tok-type>usize</span>, <span class=tok-number>0x123456780</span>);</span>
<span class=line>    <span class=tok-kw>const</span> b = <span class=tok-builtin>@intToPtr</span>(?*<span class=tok-type>usize</span>, <span class=tok-number>0x123456780</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(a == b);</span>
<span class=line>    <span class=tok-kw>try</span> expect(b == a);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test peer_type_resolution.zig</kbd></span>
<span class=line>1/7 test.peer resolve int widening... OK</span>
<span class=line>2/7 test.peer resolve arrays of different size to const slice... OK</span>
<span class=line>3/7 test.peer resolve array and const slice... OK</span>
<span class=line>4/7 test.peer type resolution: ?T and T... OK</span>
<span class=line>5/7 test.peer type resolution: *[0]u8 and []const u8... OK</span>
<span class=line>6/7 test.peer type resolution: *[0]u8, []const u8, and anyerror![]u8... OK</span>
<span class=line>7/7 test.peer type resolution: *const T and ?*T... OK</span>
<span class=line>All 7 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Zero%20Bit%20Types class=dashAnchor></a><h2 id=Zero-Bit-Types>Zero Bit Types</h2> <p>For some types, <a href=#sizeOf>@sizeOf</a> is 0:</p> <ul> <li><a href=#void>void</a></li> <li>The <a href=#Integers>Integers</a> <code><span class=line><span class=tok-type>u0</span></span></code> and <code><span class=line><span class=tok-type>i0</span></span></code>.</li> <li><a href=#Arrays>Arrays</a> and <a href=#Vectors>Vectors</a> with len 0, or with an element type that is a zero bit type.</li> <li>An <a href=#enum>enum</a> with only 1 tag.</li> <li>A <a href=#struct>struct</a> with all fields being zero bit types.</li> <li>A <a href=#union>union</a> with only 1 field which is a zero bit type.</li> </ul> <p> These types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>entry</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>void</span> = {};</span>
<span class=line>    <span class=tok-kw>var</span> y: <span class=tok-type>void</span> = {};</span>
<span class=line>    x = y;</span>
<span class=line>}</span></code></pre></figure> <p>When this turns into machine code, there is no code generated in the body of <code><span class=line>entry</span></code>, even in <a href=#Debug>Debug</a> mode. For example, on x86_64:</p> <pre><code>0000000000000010 &lt;entry&gt;:
  10:	55                   	push   %rbp
  11:	48 89 e5             	mov    %rsp,%rbp
  14:	5d                   	pop    %rbp
  15:	c3                   	retq   </code></pre> <p>These assembly instructions do not have any code associated with the void values - they only perform the function call prologue and epilogue.</p> <a name=//apple_ref/cpp/Keyword/void class=dashAnchor></a><h3 id=void>void</h3> <p> <code><span class=line><span class=tok-type>void</span></span></code> can be useful for instantiating generic types. For example, given a <code><span class=line>Map(Key, Value)</span></code>, one can pass <code><span class=line><span class=tok-type>void</span></span></code> for the <code><span class=line>Value</span></code> type to make it into a <code><span class=line>Set</span></code>: </p> <figure><figcaption class=zig-cap><cite class=file>void_in_hashmap.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"turn HashMap into a set with void"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> map = std.AutoHashMap(<span class=tok-type>i32</span>, <span class=tok-type>void</span>).init(std.testing.allocator);</span>
<span class=line>    <span class=tok-kw>defer</span> map.deinit();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> map.put(<span class=tok-number>1</span>, {});</span>
<span class=line>    <span class=tok-kw>try</span> map.put(<span class=tok-number>2</span>, {});</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(map.contains(<span class=tok-number>2</span>));</span>
<span class=line>    <span class=tok-kw>try</span> expect(!map.contains(<span class=tok-number>3</span>));</span>
<span class=line></span>
<span class=line>    _ = map.remove(<span class=tok-number>2</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(!map.contains(<span class=tok-number>2</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test void_in_hashmap.zig</kbd></span>
<span class=line>1/1 test.turn HashMap into a set with void... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>Note that this is different from using a dummy value for the hash map value. By using <code><span class=line><span class=tok-type>void</span></span></code> as the type of the value, the hash map entry type has no value field, and thus the hash map takes up less space. Further, all the code that deals with storing and loading the value is deleted, as seen above. </p> <p> <code><span class=line><span class=tok-type>void</span></span></code> is distinct from <code><span class=line><span class=tok-type>anyopaque</span></span></code>. <code><span class=line><span class=tok-type>void</span></span></code> has a known size of 0 bytes, and <code><span class=line><span class=tok-type>anyopaque</span></span></code> has an unknown, but non-zero, size. </p> <p> Expressions of type <code><span class=line><span class=tok-type>void</span></span></code> are the only ones whose value can be ignored. For example: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"ignoring expression value"</span> {</span>
<span class=line>    foo();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>() <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-number>1234</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:2:8: </span><span class=t31_1>error: </span><span class=t1_0>value of type 'i32' ignored</span>
<span class=line></span>    foo();</span>
<span class=line>    <span class=t32_1>~~~^~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:2:8: </span><span class=t36_1>note: </span><span class=t1_0>all non-void values must be used</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:2:8: </span><span class=t36_1>note: </span><span class=t1_0>this error can be suppressed by assigning the value to '_'</span>
<span class=line></span></span>
</samp></pre></figure> <p>However, if the expression has type <code><span class=line><span class=tok-type>void</span></span></code>, there will be no error. Function return values can also be explicitly ignored by assigning them to <code><span class=line>_</span></code>. </p> <figure><figcaption class=zig-cap><cite class=file>void_ignored.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"void is ignored"</span> {</span>
<span class=line>    returnsVoid();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"explicitly ignoring expression value"</span> {</span>
<span class=line>    _ = foo();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>returnsVoid</span>() <span class=tok-type>void</span> {}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>() <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-number>1234</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test void_ignored.zig</kbd></span>
<span class=line>1/2 test.void is ignored... OK</span>
<span class=line>2/2 test.explicitly ignoring expression value... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Result%20Location%20Semantics class=dashAnchor></a><h2 id=Result-Location-Semantics>Result Location Semantics</h2> <p> <a href=https://github.com/ziglang/zig/issues/2809>TODO add documentation for this</a> </p> <a name=//apple_ref/cpp/Keyword/usingnamespace class=dashAnchor></a><h2 id=usingnamespace>usingnamespace</h2> <p> <code><span class=line><span class=tok-kw>usingnamespace</span></span></code> is a declaration that mixes all the public declarations of the operand, which must be a <a href=#struct>struct</a>, <a href=#union>union</a>, <a href=#enum>enum</a>, or <a href=#opaque>opaque</a>, into the namespace: </p> <figure><figcaption class=zig-cap><cite class=file>usingnamespace.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"using std namespace"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> S = <span class=tok-kw>struct</span> {</span>
<span class=line>        <span class=tok-kw>usingnamespace</span> <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>try</span> S.testing.expect(<span class=tok-null>true</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test usingnamespace.zig</kbd></span>
<span class=line>1/1 test.using std namespace... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> <code><span class=line><span class=tok-kw>usingnamespace</span></span></code> has an important use case when organizing the public API of a file or package. For example, one might have <code class=file>c.zig</code> with all of the <a href=#Import-from-C-Header-File>C imports</a>: </p> <figure><figcaption class=zig-cap><cite class=file>c.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>usingnamespace</span> <span class=tok-builtin>@cImport</span>({</span>
<span class=line>    <span class=tok-builtin>@cInclude</span>(<span class=tok-str>"epoxy/gl.h"</span>);</span>
<span class=line>    <span class=tok-builtin>@cInclude</span>(<span class=tok-str>"GLFW/glfw3.h"</span>);</span>
<span class=line>    <span class=tok-builtin>@cDefine</span>(<span class=tok-str>"STBI_ONLY_PNG"</span>, <span class=tok-str>""</span>);</span>
<span class=line>    <span class=tok-builtin>@cDefine</span>(<span class=tok-str>"STBI_NO_STDIO"</span>, <span class=tok-str>""</span>);</span>
<span class=line>    <span class=tok-builtin>@cInclude</span>(<span class=tok-str>"stb_image.h"</span>);</span>
<span class=line>});</span></code></pre></figure> <p> The above example demonstrates using <code><span class=line><span class=tok-kw>pub</span></span></code> to qualify the <code><span class=line><span class=tok-kw>usingnamespace</span></span></code> additionally makes the imported declarations <code><span class=line><span class=tok-kw>pub</span></span></code>. This can be used to forward declarations, giving precise control over what declarations a given file exposes. </p> <a name=//apple_ref/cpp/Keyword/comptime class=dashAnchor></a><h2 id=comptime>comptime</h2> <p> Zig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful. </p> <a name=//apple_ref/cpp/Guide/Introducing%20the%20Compile-Time%20Concept class=dashAnchor></a><h3 id=Introducing-the-Compile-Time-Concept>Introducing the Compile-Time Concept</h3> <a name=//apple_ref/cpp/Guide/Compile-Time%20Parameters class=dashAnchor></a><h4 id=Compile-Time-Parameters>Compile-Time Parameters</h4> <p> Compile-time parameters is how Zig implements generics. It is compile-time duck typing. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>max</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, b: T) T {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>if</span> (a &gt; b) a <span class=tok-kw>else</span> b;</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>gimmeTheBiggerFloat</span>(a: <span class=tok-type>f32</span>, b: <span class=tok-type>f32</span>) <span class=tok-type>f32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> max(<span class=tok-type>f32</span>, a, b);</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>gimmeTheBiggerInteger</span>(a: <span class=tok-type>u64</span>, b: <span class=tok-type>u64</span>) <span class=tok-type>u64</span> {</span>
<span class=line>    <span class=tok-kw>return</span> max(<span class=tok-type>u64</span>, a, b);</span>
<span class=line>}</span></code></pre></figure> <p> In Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions, and returned from functions. However, they can only be used in expressions which are known at <em>compile-time</em>, which is why the parameter <code><span class=line>T</span></code> in the above snippet must be marked with <code><span class=line><span class=tok-kw>comptime</span></span></code>. </p> <p> A <code><span class=line><span class=tok-kw>comptime</span></span></code> parameter means that: </p> <ul> <li>At the callsite, the value must be known at compile-time, or it is a compile error.</li> <li>In the function definition, the value is known at compile-time.</li> </ul> <p> For example, if we were to introduce another function to the above snippet: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>max</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, b: T) T {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>if</span> (a &gt; b) a <span class=tok-kw>else</span> b;</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"try to pass a runtime type"</span> {</span>
<span class=line>    foo(<span class=tok-null>false</span>);</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(condition: <span class=tok-type>bool</span>) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> result = max(</span>
<span class=line>        <span class=tok-kw>if</span> (condition) <span class=tok-type>f32</span> <span class=tok-kw>else</span> <span class=tok-type>u64</span>,</span>
<span class=line>        <span class=tok-number>1234</span>,</span>
<span class=line>        <span class=tok-number>5678</span>);</span>
<span class=line>    _ = result;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:9:13: </span><span class=t31_1>error: </span><span class=t1_0>unable to resolve comptime value</span>
<span class=line></span>        if (condition) f32 else u64,</span>
<span class=line>            <span class=t32_1>^~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:9:13: </span><span class=t36_1>note: </span><span class=t1_0>condition in comptime branch must be comptime-known</span>
<span class=line></span><span class=t2_0>referenced by:</span>
<span class=line>    test.try to pass a runtime type: docgen_tmp/test.zig:5:5</span>
<span class=line>    remaining reference traces hidden; use '-freference-trace' to see all reference traces</span>
<span class=line></span>
<span class=line></span></span>
</samp></pre></figure> <p> This is an error because the programmer attempted to pass a value only known at run-time to a function which expects a value known at compile-time. </p> <p> Another way to get an error is if we pass a type that violates the type checker when the function is analyzed. This is what it means to have <em>compile-time duck typing</em>. </p> <p> For example: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>max</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, b: T) T {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>if</span> (a &gt; b) a <span class=tok-kw>else</span> b;</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"try to compare bools"</span> {</span>
<span class=line>    _ = max(<span class=tok-type>bool</span>, <span class=tok-null>true</span>, <span class=tok-null>false</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:2:18: </span><span class=t31_1>error: </span><span class=t1_0>operator &gt; not allowed for type 'bool'</span>
<span class=line></span>    return if (a &gt; b) a else b;</span>
<span class=line>               <span class=t32_1>~~^~~</span>
<span class=line></span><span class=t2_0>referenced by:</span>
<span class=line>    test.try to compare bools: docgen_tmp/test.zig:5:9</span>
<span class=line>    remaining reference traces hidden; use '-freference-trace' to see all reference traces</span>
<span class=line></span>
<span class=line></span></span>
</samp></pre></figure> <p> On the flip side, inside the function definition with the <code><span class=line><span class=tok-kw>comptime</span></span></code> parameter, the value is known at compile-time. This means that we actually could make this work for the bool type if we wanted to: </p> <figure><figcaption class=zig-cap><cite class=file>comptime_max_with_bool.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>max</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, b: T) T {</span>
<span class=line>    <span class=tok-kw>if</span> (T == <span class=tok-type>bool</span>) {</span>
<span class=line>        <span class=tok-kw>return</span> a <span class=tok-kw>or</span> b;</span>
<span class=line>    } <span class=tok-kw>else</span> <span class=tok-kw>if</span> (a &gt; b) {</span>
<span class=line>        <span class=tok-kw>return</span> a;</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        <span class=tok-kw>return</span> b;</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"try to compare bools"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect(max(<span class=tok-type>bool</span>, <span class=tok-null>false</span>, <span class=tok-null>true</span>) == <span class=tok-null>true</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test comptime_max_with_bool.zig</kbd></span>
<span class=line>1/1 test.try to compare bools... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> This works because Zig implicitly inlines <code><span class=line><span class=tok-kw>if</span></span></code> expressions when the condition is known at compile-time, and the compiler guarantees that it will skip analysis of the branch not taken. </p> <p> This means that the actual function generated for <code><span class=line>max</span></code> in this situation looks like this: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>max</span>(a: <span class=tok-type>bool</span>, b: <span class=tok-type>bool</span>) <span class=tok-type>bool</span> {</span>
<span class=line>    <span class=tok-kw>return</span> a <span class=tok-kw>or</span> b;</span>
<span class=line>}</span></code></pre></figure> <p> All the code that dealt with compile-time known values is eliminated and we are left with only the necessary run-time code to accomplish the task. </p> <p> This works the same way for <code><span class=line><span class=tok-kw>switch</span></span></code> expressions - they are implicitly inlined when the target expression is compile-time known. </p> <a name=//apple_ref/cpp/Guide/Compile-Time%20Variables class=dashAnchor></a><h4 id=Compile-Time-Variables>Compile-Time Variables</h4> <p> In Zig, the programmer can label variables as <code><span class=line><span class=tok-kw>comptime</span></span></code>. This guarantees to the compiler that every load and store of the variable is performed at compile-time. Any violation of this results in a compile error. </p> <p> This combined with the fact that we can <code><span class=line><span class=tok-kw>inline</span></span></code> loops allows us to write a function which is partially evaluated at compile-time and partially at run-time. </p> <p> For example: </p> <figure><figcaption class=zig-cap><cite class=file>comptime_vars.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> CmdFn = <span class=tok-kw>struct</span> {</span>
<span class=line>    name: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>,</span>
<span class=line>    func: <span class=tok-kw>fn</span>(<span class=tok-type>i32</span>) <span class=tok-type>i32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> cmd_fns = [_]CmdFn{</span>
<span class=line>    CmdFn {.name = <span class=tok-str>"one"</span>, .func = one},</span>
<span class=line>    CmdFn {.name = <span class=tok-str>"two"</span>, .func = two},</span>
<span class=line>    CmdFn {.name = <span class=tok-str>"three"</span>, .func = three},</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>one</span>(value: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> { <span class=tok-kw>return</span> value + <span class=tok-number>1</span>; }</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>two</span>(value: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> { <span class=tok-kw>return</span> value + <span class=tok-number>2</span>; }</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>three</span>(value: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> { <span class=tok-kw>return</span> value + <span class=tok-number>3</span>; }</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>performFn</span>(<span class=tok-kw>comptime</span> prefix_char: <span class=tok-type>u8</span>, start_value: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>var</span> result: <span class=tok-type>i32</span> = start_value;</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>var</span> i = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>inline</span> <span class=tok-kw>while</span> (i &lt; cmd_fns.len) : (i += <span class=tok-number>1</span>) {</span>
<span class=line>        <span class=tok-kw>if</span> (cmd_fns[i].name[<span class=tok-number>0</span>] == prefix_char) {</span>
<span class=line>            result = cmd_fns[i].func(result);</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>return</span> result;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"perform fn"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(performFn(<span class=tok-str>'t'</span>, <span class=tok-number>1</span>) == <span class=tok-number>6</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(performFn(<span class=tok-str>'o'</span>, <span class=tok-number>0</span>) == <span class=tok-number>1</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(performFn(<span class=tok-str>'w'</span>, <span class=tok-number>99</span>) == <span class=tok-number>99</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test comptime_vars.zig</kbd></span>
<span class=line>1/1 test.perform fn... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> This example is a bit contrived, because the compile-time evaluation component is unnecessary; this code would work fine if it was all done at run-time. But it does end up generating different code. In this example, the function <code><span class=line>performFn</span></code> is generated three different times, for the different values of <code><span class=line>prefix_char</span></code> provided: </p> <figure><figcaption class=zig-cap><cite class=file>performFn_1</cite></figcaption><pre><code><span class=line><span class=tok-comment>// From the line:</span></span>
<span class=line><span class=tok-comment>// expect(performFn('t', 1) == 6);</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>performFn</span>(start_value: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>var</span> result: <span class=tok-type>i32</span> = start_value;</span>
<span class=line>    result = two(result);</span>
<span class=line>    result = three(result);</span>
<span class=line>    <span class=tok-kw>return</span> result;</span>
<span class=line>}</span></code></pre></figure> <figure><figcaption class=zig-cap><cite class=file>performFn_2</cite></figcaption><pre><code><span class=line><span class=tok-comment>// From the line:</span></span>
<span class=line><span class=tok-comment>// expect(performFn('o', 0) == 1);</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>performFn</span>(start_value: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>var</span> result: <span class=tok-type>i32</span> = start_value;</span>
<span class=line>    result = one(result);</span>
<span class=line>    <span class=tok-kw>return</span> result;</span>
<span class=line>}</span></code></pre></figure> <figure><figcaption class=zig-cap><cite class=file>performFn_3</cite></figcaption><pre><code><span class=line><span class=tok-comment>// From the line:</span></span>
<span class=line><span class=tok-comment>// expect(performFn('w', 99) == 99);</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>performFn</span>(start_value: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>var</span> result: <span class=tok-type>i32</span> = start_value;</span>
<span class=line>    <span class=tok-kw>return</span> result;</span>
<span class=line>}</span></code></pre></figure> <p> Note that this happens even in a debug build; in a release build these generated functions still pass through rigorous LLVM optimizations. The important thing to note, however, is not that this is a way to write more optimized code, but that it is a way to make sure that what <em>should</em> happen at compile-time, <em>does</em> happen at compile-time. This catches more errors and as demonstrated later in this article, allows expressiveness that in other languages requires using macros, generated code, or a preprocessor to accomplish. </p> <a name=//apple_ref/cpp/Guide/Compile-Time%20Expressions class=dashAnchor></a><h4 id=Compile-Time-Expressions>Compile-Time Expressions</h4> <p> In Zig, it matters whether a given expression is known at compile-time or run-time. A programmer can use a <code><span class=line><span class=tok-kw>comptime</span></span></code> expression to guarantee that the expression will be evaluated at compile-time. If this cannot be accomplished, the compiler will emit an error. For example: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>extern</span> <span class=tok-kw>fn</span> <span class=tok-fn>exit</span>() <span class=tok-type>noreturn</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"foo"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        exit();</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:5:13: </span><span class=t31_1>error: </span><span class=t1_0>comptime call of extern function</span>
<span class=line></span>        exit();</span>
<span class=line>        <span class=t32_1>~~~~^~</span>
<span class=line></span></span>
</samp></pre></figure> <p> It doesn't make sense that a program could call <code><span class=line>exit()</span></code> (or any other external function) at compile-time, so this is a compile error. However, a <code><span class=line><span class=tok-kw>comptime</span></span></code> expression does much more than sometimes cause a compile error. </p> <p> Within a <code><span class=line><span class=tok-kw>comptime</span></span></code> expression: </p> <ul> <li>All variables are <code><span class=line><span class=tok-kw>comptime</span></span></code> variables.</li> <li>All <code><span class=line><span class=tok-kw>if</span></span></code>, <code><span class=line><span class=tok-kw>while</span></span></code>, <code><span class=line><span class=tok-kw>for</span></span></code>, and <code><span class=line><span class=tok-kw>switch</span></span></code> expressions are evaluated at compile-time, or emit a compile error if this is not possible.</li> <li>All function calls cause the compiler to interpret the function at compile-time, emitting a compile error if the function tries to do something that has global run-time side effects.</li> </ul> <p> This means that a programmer can create a function which is called both at compile-time and run-time, with no modification to the function required. </p> <p> Let's look at an example: </p> <figure><figcaption class=zig-cap><cite class=file>fibonacci_recursion.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>fibonacci</span>(index: <span class=tok-type>u32</span>) <span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (index &lt; <span class=tok-number>2</span>) <span class=tok-kw>return</span> index;</span>
<span class=line>    <span class=tok-kw>return</span> fibonacci(index - <span class=tok-number>1</span>) + fibonacci(index - <span class=tok-number>2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"fibonacci"</span> {</span>
<span class=line>    <span class=tok-comment>// test fibonacci at run-time</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(fibonacci(<span class=tok-number>7</span>) == <span class=tok-number>13</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// test fibonacci at compile-time</span></span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-kw>try</span> expect(fibonacci(<span class=tok-number>7</span>) == <span class=tok-number>13</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test fibonacci_recursion.zig</kbd></span>
<span class=line>1/1 test.fibonacci... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Imagine if we had forgotten the base case of the recursive function and tried to run the tests: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>fibonacci</span>(index: <span class=tok-type>u32</span>) <span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-comment>//if (index &lt; 2) return index;</span></span>
<span class=line>    <span class=tok-kw>return</span> fibonacci(index - <span class=tok-number>1</span>) + fibonacci(index - <span class=tok-number>2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"fibonacci"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-kw>try</span> expect(fibonacci(<span class=tok-number>7</span>) == <span class=tok-number>13</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:5:28: </span><span class=t31_1>error: </span><span class=t1_0>overflow of integer type 'u32' with value '-1'</span>
<span class=line></span>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                     <span class=t32_1>~~~~~~^~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t1_0>called from here</span><span class=t2_0> (7 times)</span>
<span class=line></span>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>           <span class=t32_1>~~~~~~~~~^~~~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:10:29: </span><span class=t36_1>note: </span><span class=t1_0>called from here</span>
<span class=line></span>        try expect(fibonacci(7) == 13);</span>
<span class=line>                   <span class=t32_1>~~~~~~~~~^~~</span>
<span class=line></span></span>
</samp></pre></figure> <p> The compiler produces an error which is a stack trace from trying to evaluate the function at compile-time. </p> <p> Luckily, we used an unsigned integer, and so when we tried to subtract 1 from 0, it triggered undefined behavior, which is always a compile error if the compiler knows it happened. But what would have happened if we used a signed integer? </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> assert = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.assert;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>fibonacci</span>(index: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-comment>//if (index &lt; 2) return index;</span></span>
<span class=line>    <span class=tok-kw>return</span> fibonacci(index - <span class=tok-number>1</span>) + fibonacci(index - <span class=tok-number>2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"fibonacci"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-kw>try</span> assert(fibonacci(<span class=tok-number>7</span>) == <span class=tok-number>13</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig -fstage1</kbd></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t31_1>error: </span><span class=t0_1>evaluation exceeded 1000 backwards branches</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>called from here</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:5:21: </span><span class=t36_1>note: </span><span class=t0_1>use @setEvalBranchQuota to raise branch limit from 1000</span></span>
<span class=line>    return fibonacci(index - 1) + fibonacci(index - 2);</span>
<span class=line>                    <span class=t32_1>^</span></span>
</samp></pre></figure> <p> The compiler noticed that evaluating this function at compile-time took a long time, and thus emitted a compile error and gave up. If the programmer wants to increase the budget for compile-time computation, they can use a built-in function called <a href=#setEvalBranchQuota>@setEvalBranchQuota</a> to change the default number 1000 to something else. </p> <p> What if we fix the base case, but put the wrong value in the <code><span class=line>expect</span></code> line? </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> assert = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.assert;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>fibonacci</span>(index: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (index &lt; <span class=tok-number>2</span>) <span class=tok-kw>return</span> index;</span>
<span class=line>    <span class=tok-kw>return</span> fibonacci(index - <span class=tok-number>1</span>) + fibonacci(index - <span class=tok-number>2</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"fibonacci"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-kw>try</span> assert(fibonacci(<span class=tok-number>7</span>) == <span class=tok-number>99999</span>);</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/debug.zig:278:14: </span><span class=t31_1>error: </span><span class=t1_0>reached unreachable code</span>
<span class=line></span>    if (!ok) unreachable; // assertion failure</span>
<span class=line>             <span class=t32_1>^~~~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:10:19: </span><span class=t36_1>note: </span><span class=t1_0>called from here</span>
<span class=line></span>        try assert(fibonacci(7) == 99999);</span>
<span class=line>            <span class=t32_1>~~~~~~^~~~~~~~~~~~~~~~~~~~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p> At container level (outside of any function), all expressions are implicitly <code><span class=line><span class=tok-kw>comptime</span></span></code> expressions. This means that we can use functions to initialize complex static data. For example: </p> <figure><figcaption class=zig-cap><cite class=file>N_primes.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> first_25_primes = firstNPrimes(<span class=tok-number>25</span>);</span>
<span class=line><span class=tok-kw>const</span> sum_of_first_25_primes = sum(&amp;first_25_primes);</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>firstNPrimes</span>(<span class=tok-kw>comptime</span> n: <span class=tok-type>usize</span>) [n]<span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>var</span> prime_list: [n]<span class=tok-type>i32</span> = <span class=tok-null>undefined</span>;</span>
<span class=line>    <span class=tok-kw>var</span> next_index: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>var</span> test_number: <span class=tok-type>i32</span> = <span class=tok-number>2</span>;</span>
<span class=line>    <span class=tok-kw>while</span> (next_index &lt; prime_list.len) : (test_number += <span class=tok-number>1</span>) {</span>
<span class=line>        <span class=tok-kw>var</span> test_prime_index: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>        <span class=tok-kw>var</span> is_prime = <span class=tok-null>true</span>;</span>
<span class=line>        <span class=tok-kw>while</span> (test_prime_index &lt; next_index) : (test_prime_index += <span class=tok-number>1</span>) {</span>
<span class=line>            <span class=tok-kw>if</span> (test_number % prime_list[test_prime_index] == <span class=tok-number>0</span>) {</span>
<span class=line>                is_prime = <span class=tok-null>false</span>;</span>
<span class=line>                <span class=tok-kw>break</span>;</span>
<span class=line>            }</span>
<span class=line>        }</span>
<span class=line>        <span class=tok-kw>if</span> (is_prime) {</span>
<span class=line>            prime_list[next_index] = test_number;</span>
<span class=line>            next_index += <span class=tok-number>1</span>;</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>return</span> prime_list;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>sum</span>(numbers: []<span class=tok-kw>const</span> <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>var</span> result: <span class=tok-type>i32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>for</span> (numbers) |x| {</span>
<span class=line>        result += x;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>return</span> result;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"variable values"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect(sum_of_first_25_primes == <span class=tok-number>1060</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test N_primes.zig</kbd></span>
<span class=line>1/1 test.variable values... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> When we compile this program, Zig generates the constants with the answer pre-computed. Here are the lines from the generated LLVM IR: </p> <pre><code class=llvm>@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97]
@1 = internal unnamed_addr constant i32 1060</code></pre> <p> Note that we did not have to do anything special with the syntax of these functions. For example, we could call the <code><span class=line>sum</span></code> function as is with a slice of numbers whose length and values were only known at run-time. </p> <a name=//apple_ref/cpp/Guide/Generic%20Data%20Structures class=dashAnchor></a><h3 id=Generic-Data-Structures>Generic Data Structures</h3> <p> Zig uses these capabilities to implement generic data structures without introducing any special-case syntax. If you followed along so far, you may already know how to create a generic data structure. </p> <p> Here is an example of a generic <code><span class=line>List</span></code> data structure. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>List</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>) <span class=tok-type>type</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>struct</span> {</span>
<span class=line>        items: []T,</span>
<span class=line>        len: <span class=tok-type>usize</span>,</span>
<span class=line>    };</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The generic List data structure can be instantiated by passing in a type:</span></span>
<span class=line><span class=tok-kw>var</span> buffer: [<span class=tok-number>10</span>]<span class=tok-type>i32</span> = <span class=tok-null>undefined</span>;</span>
<span class=line><span class=tok-kw>var</span> list = List(<span class=tok-type>i32</span>){</span>
<span class=line>    .items = &amp;buffer,</span>
<span class=line>    .len = <span class=tok-number>0</span>,</span>
<span class=line>};</span></code></pre></figure> <p> That's it. It's a function that returns an anonymous <code><span class=line><span class=tok-kw>struct</span></span></code>. To keep the language small and uniform, all aggregate types in Zig are anonymous. For the purposes of error messages and debugging, Zig infers the name <code><span class=line><span class=tok-str>"List(i32)"</span></span></code> from the function name and parameters invoked when creating the anonymous struct. </p> <p> To explicitly give a type a name, we assign it to a constant. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Node = <span class=tok-kw>struct</span> {</span>
<span class=line>    next: ?*Node,</span>
<span class=line>    name: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> node_a = Node{</span>
<span class=line>    .next = <span class=tok-null>null</span>,</span>
<span class=line>    .name = &amp;<span class=tok-str>"Node A"</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> node_b = Node{</span>
<span class=line>    .next = &amp;node_a,</span>
<span class=line>    .name = &amp;<span class=tok-str>"Node B"</span>,</span>
<span class=line>};</span></code></pre></figure> <p> In this example, the <code><span class=line>Node</span></code> struct refers to itself. This works because all top level declarations are order-independent. As long as the compiler can determine the size of the struct, it is free to refer to itself. In this case, <code><span class=line>Node</span></code> refers to itself as a pointer, which has a well-defined size at compile time, so it works fine. </p> <a name=//apple_ref/cpp/Guide/Case%20Study%3A%20print%20in%20Zig class=dashAnchor></a><h3 id=Case-Study-print-in-Zig>Case Study: print in Zig</h3> <p> Putting all of this together, let's see how <code><span class=line>print</span></code> works in Zig. </p> <figure><figcaption class=zig-cap><cite class=file>print.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> a_number: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line><span class=tok-kw>const</span> a_string = <span class=tok-str>"foobar"</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    print(<span class=tok-str>"here is a string: '{s}' here is a number: {}\n"</span>, .{a_string, a_number});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe print.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./print</kbd></span>
<span class=line>here is a string: 'foobar' here is a number: 1234</span>
</samp></pre></figure> <p> Let's crack open the implementation of this and see how it works: </p> <figure><figcaption class=zig-cap><cite class=file>poc_print_fn.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Writer = <span class=tok-kw>struct</span> {</span>
<span class=line>    <span class=tok-comment>/// Calls print and then flushes the buffer.</span></span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>print</span>(self: *Writer, <span class=tok-kw>comptime</span> format: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>, args: <span class=tok-kw>anytype</span>) <span class=tok-type>anyerror</span>!<span class=tok-type>void</span> {</span>
<span class=line>        <span class=tok-kw>const</span> State = <span class=tok-kw>enum</span> {</span>
<span class=line>            start,</span>
<span class=line>            open_brace,</span>
<span class=line>            close_brace,</span>
<span class=line>        };</span>
<span class=line></span>
<span class=line>        <span class=tok-kw>comptime</span> <span class=tok-kw>var</span> start_index: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line>        <span class=tok-kw>comptime</span> <span class=tok-kw>var</span> state = State.start;</span>
<span class=line>        <span class=tok-kw>comptime</span> <span class=tok-kw>var</span> next_arg: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line></span>
<span class=line>        <span class=tok-kw>inline</span> <span class=tok-kw>for</span> (format) |c, i| {</span>
<span class=line>            <span class=tok-kw>switch</span> (state) {</span>
<span class=line>                State.start =&gt; <span class=tok-kw>switch</span> (c) {</span>
<span class=line>                    <span class=tok-str>'{'</span> =&gt; {</span>
<span class=line>                        <span class=tok-kw>if</span> (start_index &lt; i) <span class=tok-kw>try</span> self.write(format[start_index..i]);</span>
<span class=line>                        state = State.open_brace;</span>
<span class=line>                    },</span>
<span class=line>                    <span class=tok-str>'}'</span> =&gt; {</span>
<span class=line>                        <span class=tok-kw>if</span> (start_index &lt; i) <span class=tok-kw>try</span> self.write(format[start_index..i]);</span>
<span class=line>                        state = State.close_brace;</span>
<span class=line>                    },</span>
<span class=line>                    <span class=tok-kw>else</span> =&gt; {},</span>
<span class=line>                },</span>
<span class=line>                State.open_brace =&gt; <span class=tok-kw>switch</span> (c) {</span>
<span class=line>                    <span class=tok-str>'{'</span> =&gt; {</span>
<span class=line>                        state = State.start;</span>
<span class=line>                        start_index = i;</span>
<span class=line>                    },</span>
<span class=line>                    <span class=tok-str>'}'</span> =&gt; {</span>
<span class=line>                        <span class=tok-kw>try</span> self.printValue(args[next_arg]);</span>
<span class=line>                        next_arg += <span class=tok-number>1</span>;</span>
<span class=line>                        state = State.start;</span>
<span class=line>                        start_index = i + <span class=tok-number>1</span>;</span>
<span class=line>                    },</span>
<span class=line>                    <span class=tok-str>'s'</span> =&gt; {</span>
<span class=line>                        <span class=tok-kw>continue</span>;</span>
<span class=line>                    },</span>
<span class=line>                    <span class=tok-kw>else</span> =&gt; <span class=tok-builtin>@compileError</span>(<span class=tok-str>"Unknown format character: "</span> ++ [<span class=tok-number>1</span>]<span class=tok-type>u8</span>{c}),</span>
<span class=line>                },</span>
<span class=line>                State.close_brace =&gt; <span class=tok-kw>switch</span> (c) {</span>
<span class=line>                    <span class=tok-str>'}'</span> =&gt; {</span>
<span class=line>                        state = State.start;</span>
<span class=line>                        start_index = i;</span>
<span class=line>                    },</span>
<span class=line>                    <span class=tok-kw>else</span> =&gt; <span class=tok-builtin>@compileError</span>(<span class=tok-str>"Single '}' encountered in format string"</span>),</span>
<span class=line>                },</span>
<span class=line>            }</span>
<span class=line>        }</span>
<span class=line>        <span class=tok-kw>comptime</span> {</span>
<span class=line>            <span class=tok-kw>if</span> (args.len != next_arg) {</span>
<span class=line>                <span class=tok-builtin>@compileError</span>(<span class=tok-str>"Unused arguments"</span>);</span>
<span class=line>            }</span>
<span class=line>            <span class=tok-kw>if</span> (state != State.start) {</span>
<span class=line>                <span class=tok-builtin>@compileError</span>(<span class=tok-str>"Incomplete format string: "</span> ++ format);</span>
<span class=line>            }</span>
<span class=line>        }</span>
<span class=line>        <span class=tok-kw>if</span> (start_index &lt; format.len) {</span>
<span class=line>            <span class=tok-kw>try</span> self.write(format[start_index..format.len]);</span>
<span class=line>        }</span>
<span class=line>        <span class=tok-kw>try</span> self.flush();</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>fn</span> <span class=tok-fn>write</span>(self: *Writer, value: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) !<span class=tok-type>void</span> {</span>
<span class=line>        _ = self;</span>
<span class=line>        _ = value;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>printValue</span>(self: *Writer, value: <span class=tok-kw>anytype</span>) !<span class=tok-type>void</span> {</span>
<span class=line>        _ = self;</span>
<span class=line>        _ = value;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>fn</span> <span class=tok-fn>flush</span>(self: *Writer) !<span class=tok-type>void</span> {</span>
<span class=line>        _ = self;</span>
<span class=line>    }</span>
<span class=line>};</span></code></pre></figure> <p> This is a proof of concept implementation; the actual function in the standard library has more formatting capabilities. </p> <p> Note that this is not hard-coded into the Zig compiler; this is userland code in the standard library. </p> <p> When this function is analyzed from our example code above, Zig partially evaluates the function and emits a function that actually looks like this: </p> <figure><figcaption class=zig-cap><cite class=file>Emitted print Function</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>print</span>(self: *Writer, arg0: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>, arg1: <span class=tok-type>i32</span>) !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>try</span> self.write(<span class=tok-str>"here is a string: '"</span>);</span>
<span class=line>    <span class=tok-kw>try</span> self.printValue(arg0);</span>
<span class=line>    <span class=tok-kw>try</span> self.write(<span class=tok-str>"' here is a number: "</span>);</span>
<span class=line>    <span class=tok-kw>try</span> self.printValue(arg1);</span>
<span class=line>    <span class=tok-kw>try</span> self.write(<span class=tok-str>"\n"</span>);</span>
<span class=line>    <span class=tok-kw>try</span> self.flush();</span>
<span class=line>}</span></code></pre></figure> <p> <code><span class=line>printValue</span></code> is a function that takes a parameter of any type, and does different things depending on the type: </p> <figure><figcaption class=zig-cap><cite class=file>poc_printValue_fn.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Writer = <span class=tok-kw>struct</span> {</span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>printValue</span>(self: *Writer, value: <span class=tok-kw>anytype</span>) !<span class=tok-type>void</span> {</span>
<span class=line>        <span class=tok-kw>switch</span> (<span class=tok-builtin>@typeInfo</span>(<span class=tok-builtin>@TypeOf</span>(value))) {</span>
<span class=line>            .Int =&gt; {</span>
<span class=line>                <span class=tok-kw>return</span> self.writeInt(value);</span>
<span class=line>            },</span>
<span class=line>            .Float =&gt; {</span>
<span class=line>                <span class=tok-kw>return</span> self.writeFloat(value);</span>
<span class=line>            },</span>
<span class=line>            .Pointer =&gt; {</span>
<span class=line>                <span class=tok-kw>return</span> self.write(value);</span>
<span class=line>            },</span>
<span class=line>            <span class=tok-kw>else</span> =&gt; {</span>
<span class=line>                <span class=tok-builtin>@compileError</span>(<span class=tok-str>"Unable to print type '"</span> ++ <span class=tok-builtin>@typeName</span>(<span class=tok-builtin>@TypeOf</span>(value)) ++ <span class=tok-str>"'"</span>);</span>
<span class=line>            },</span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>fn</span> <span class=tok-fn>write</span>(self: *Writer, value: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) !<span class=tok-type>void</span> {</span>
<span class=line>        _ = self;</span>
<span class=line>        _ = value;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>fn</span> <span class=tok-fn>writeInt</span>(self: *Writer, value: <span class=tok-kw>anytype</span>) !<span class=tok-type>void</span> {</span>
<span class=line>        _ = self;</span>
<span class=line>        _ = value;</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-kw>fn</span> <span class=tok-fn>writeFloat</span>(self: *Writer, value: <span class=tok-kw>anytype</span>) !<span class=tok-type>void</span> {</span>
<span class=line>        _ = self;</span>
<span class=line>        _ = value;</span>
<span class=line>    }</span>
<span class=line>};</span></code></pre></figure> <p> And now, what happens if we give too many arguments to <code><span class=line>print</span></code>? </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> a_number: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line><span class=tok-kw>const</span> a_string = <span class=tok-str>"foobar"</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"print too many arguments"</span> {</span>
<span class=line>    print(<span class=tok-str>"here is a string: '{s}' here is a number: {}\n"</span>, .{</span>
<span class=line>        a_string,</span>
<span class=line>        a_number,</span>
<span class=line>        a_number,</span>
<span class=line>    });</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/fmt.zig:201:18: </span><span class=t31_1>error: </span><span class=t1_0>unused argument in 'here is a string: '{s}' here is a number: {}</span>
<span class=line>                                                  '</span>
<span class=line></span>            1 =&gt; @compileError("unused argument in '" ++ fmt ++ "'"),</span>
<span class=line>                 <span class=t32_1>^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class=line></span><span class=t2_0>referenced by:</span>
<span class=line>    print__anon_2760: /home/andy/tmp/zig/lib/std/io/writer.zig:28:27</span>
<span class=line>    print__anon_1068: /home/andy/tmp/zig/lib/std/debug.zig:93:21</span>
<span class=line>    remaining reference traces hidden; use '-freference-trace' to see all reference traces</span>
<span class=line></span>
<span class=line></span></span>
</samp></pre></figure> <p> Zig gives programmers the tools needed to protect themselves against their own mistakes. </p> <p> Zig doesn't care whether the format argument is a string literal, only that it is a compile-time known value that can be coerced to a <code><span class=line>[]<span class=tok-kw>const</span> <span class=tok-type>u8</span></span></code>: </p> <figure><figcaption class=zig-cap><cite class=file>print.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> a_number: <span class=tok-type>i32</span> = <span class=tok-number>1234</span>;</span>
<span class=line><span class=tok-kw>const</span> a_string = <span class=tok-str>"foobar"</span>;</span>
<span class=line><span class=tok-kw>const</span> fmt = <span class=tok-str>"here is a string: '{s}' here is a number: {}\n"</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    print(fmt, .{a_string, a_number});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe print.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./print</kbd></span>
<span class=line>here is a string: 'foobar' here is a number: 1234</span>
</samp></pre></figure> <p> This works fine. </p> <p> Zig does not special case string formatting in the compiler and instead exposes enough power to accomplish this task in userland. It does so without introducing another language on top of Zig, such as a macro language or a preprocessor language. It's Zig all the way down. </p> <p>See also:</p><ul> <li><a href=#inline-while>inline while</a></li> <li><a href=#inline-for>inline for</a></li> </ul> <a name=//apple_ref/cpp/Guide/Assembly class=dashAnchor></a><h2 id=Assembly>Assembly</h2> <p> For some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>noreturn</span> {</span>
<span class=line>    <span class=tok-kw>const</span> msg = <span class=tok-str>"hello world\n"</span>;</span>
<span class=line>    _ = syscall3(SYS_write, STDOUT_FILENO, <span class=tok-builtin>@ptrToInt</span>(msg), msg.len);</span>
<span class=line>    _ = syscall1(SYS_exit, <span class=tok-number>0</span>);</span>
<span class=line>    <span class=tok-kw>unreachable</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> SYS_write = <span class=tok-number>1</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> SYS_exit = <span class=tok-number>60</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> STDOUT_FILENO = <span class=tok-number>1</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>syscall1</span>(number: <span class=tok-type>usize</span>, arg1: <span class=tok-type>usize</span>) <span class=tok-type>usize</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>asm</span> <span class=tok-kw>volatile</span> (<span class=tok-str>"syscall"</span></span>
<span class=line>        : [ret] <span class=tok-str>"={rax}"</span> (-&gt; <span class=tok-type>usize</span>)</span>
<span class=line>        : [number] <span class=tok-str>"{rax}"</span> (number),</span>
<span class=line>          [arg1] <span class=tok-str>"{rdi}"</span> (arg1)</span>
<span class=line>        : <span class=tok-str>"rcx"</span>, <span class=tok-str>"r11"</span></span>
<span class=line>    );</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>syscall3</span>(number: <span class=tok-type>usize</span>, arg1: <span class=tok-type>usize</span>, arg2: <span class=tok-type>usize</span>, arg3: <span class=tok-type>usize</span>) <span class=tok-type>usize</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>asm</span> <span class=tok-kw>volatile</span> (<span class=tok-str>"syscall"</span></span>
<span class=line>        : [ret] <span class=tok-str>"={rax}"</span> (-&gt; <span class=tok-type>usize</span>)</span>
<span class=line>        : [number] <span class=tok-str>"{rax}"</span> (number),</span>
<span class=line>          [arg1] <span class=tok-str>"{rdi}"</span> (arg1),</span>
<span class=line>          [arg2] <span class=tok-str>"{rsi}"</span> (arg2),</span>
<span class=line>          [arg3] <span class=tok-str>"{rdx}"</span> (arg3)</span>
<span class=line>        : <span class=tok-str>"rcx"</span>, <span class=tok-str>"r11"</span></span>
<span class=line>    );</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig -fstage1-target x86_64-linux</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>hello world</span>
</samp></pre></figure> <p> Dissecting the syntax: </p> <figure><figcaption class=zig-cap><cite class=file>Assembly Syntax Explained</cite></figcaption><pre><code><span class=line><span class=tok-comment>// Inline assembly is an expression which returns a value.</span></span>
<span class=line><span class=tok-comment>// the `asm` keyword begins the expression.</span></span>
<span class=line>_ = <span class=tok-kw>asm</span></span>
<span class=line><span class=tok-comment>// `volatile` is an optional modifier that tells Zig this</span></span>
<span class=line><span class=tok-comment>// inline assembly expression has side-effects. Without</span></span>
<span class=line><span class=tok-comment>// `volatile`, Zig is allowed to delete the inline assembly</span></span>
<span class=line><span class=tok-comment>// code if the result is unused.</span></span>
<span class=line><span class=tok-kw>volatile</span> (</span>
<span class=line><span class=tok-comment>// Next is a comptime string which is the assembly code.</span></span>
<span class=line><span class=tok-comment>// Inside this string one may use `%[ret]`, `%[number]`,</span></span>
<span class=line><span class=tok-comment>// or `%[arg1]` where a register is expected, to specify</span></span>
<span class=line><span class=tok-comment>// the register that Zig uses for the argument or return value,</span></span>
<span class=line><span class=tok-comment>// if the register constraint strings are used. However in</span></span>
<span class=line><span class=tok-comment>// the below code, this is not used. A literal `%` can be</span></span>
<span class=line><span class=tok-comment>// obtained by escaping it with a double percent: `%%`.</span></span>
<span class=line><span class=tok-comment>// Often multiline string syntax comes in handy here.</span></span>
<span class=line>    <span class=tok-str>\\syscall</span></span>
<span class=line><span class=tok-comment>// Next is the output. It is possible in the future Zig will</span></span>
<span class=line><span class=tok-comment>// support multiple outputs, depending on how</span></span>
<span class=line><span class=tok-comment>// https://github.com/ziglang/zig/issues/215 is resolved.</span></span>
<span class=line><span class=tok-comment>// It is allowed for there to be no outputs, in which case</span></span>
<span class=line><span class=tok-comment>// this colon would be directly followed by the colon for the inputs.</span></span>
<span class=line>    :</span>
<span class=line><span class=tok-comment>// This specifies the name to be used in `%[ret]` syntax in</span></span>
<span class=line><span class=tok-comment>// the above assembly string. This example does not use it,</span></span>
<span class=line><span class=tok-comment>// but the syntax is mandatory.</span></span>
<span class=line>    [ret]</span>
<span class=line><span class=tok-comment>// Next is the output constraint string. This feature is still</span></span>
<span class=line><span class=tok-comment>// considered unstable in Zig, and so LLVM/GCC documentation</span></span>
<span class=line><span class=tok-comment>// must be used to understand the semantics.</span></span>
<span class=line><span class=tok-comment>// http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string</span></span>
<span class=line><span class=tok-comment>// https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</span></span>
<span class=line><span class=tok-comment>// In this example, the constraint string means "the result value of</span></span>
<span class=line><span class=tok-comment>// this inline assembly instruction is whatever is in $rax".</span></span>
<span class=line>    <span class=tok-str>"={rax}"</span></span>
<span class=line><span class=tok-comment>// Next is either a value binding, or `-&gt;` and then a type. The</span></span>
<span class=line><span class=tok-comment>// type is the result type of the inline assembly expression.</span></span>
<span class=line><span class=tok-comment>// If it is a value binding, then `%[ret]` syntax would be used</span></span>
<span class=line><span class=tok-comment>// to refer to the register bound to the value.</span></span>
<span class=line>    (-&gt; <span class=tok-type>usize</span>)</span>
<span class=line><span class=tok-comment>// Next is the list of inputs.</span></span>
<span class=line><span class=tok-comment>// The constraint for these inputs means, "when the assembly code is</span></span>
<span class=line><span class=tok-comment>// executed, $rax shall have the value of `number` and $rdi shall have</span></span>
<span class=line><span class=tok-comment>// the value of `arg1`". Any number of input parameters is allowed,</span></span>
<span class=line><span class=tok-comment>// including none.</span></span>
<span class=line>    : [number] <span class=tok-str>"{rax}"</span> (number),</span>
<span class=line>        [arg1] <span class=tok-str>"{rdi}"</span> (arg1)</span>
<span class=line><span class=tok-comment>// Next is the list of clobbers. These declare a set of registers whose</span></span>
<span class=line><span class=tok-comment>// values will not be preserved by the execution of this assembly code.</span></span>
<span class=line><span class=tok-comment>// These do not include output or input registers. The special clobber</span></span>
<span class=line><span class=tok-comment>// value of "memory" means that the assembly writes to arbitrary undeclared</span></span>
<span class=line><span class=tok-comment>// memory locations - not only the memory pointed to by a declared indirect</span></span>
<span class=line><span class=tok-comment>// output. In this example we list $rcx and $r11 because it is known the</span></span>
<span class=line><span class=tok-comment>// kernel syscall does not preserve these registers.</span></span>
<span class=line>    : <span class=tok-str>"rcx"</span>, <span class=tok-str>"r11"</span></span>
<span class=line>);</span></code></pre></figure> <p> For i386 and x86_64 targets, the syntax is AT&amp;T syntax, rather than the more popular Intel syntax. This is due to technical constraints; assembly parsing is provided by LLVM and its support for Intel syntax is buggy and not well tested. </p> <p> Some day Zig may have its own assembler. This would allow it to integrate more seamlessly into the language, as well as be compatible with the popular NASM syntax. This documentation section will be updated before 1.0.0 is released, with a conclusive statement about the status of AT&amp;T vs Intel/NASM syntax. </p> <a name=//apple_ref/cpp/Guide/Output%20Constraints class=dashAnchor></a><h3 id=Output-Constraints>Output Constraints</h3> <p> Output constraints are still considered to be unstable in Zig, and so <a href=http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string>LLVM documentation</a> and <a href=https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>GCC documentation</a> must be used to understand the semantics. </p> <p> Note that some breaking changes to output constraints are planned with <a href=https://github.com/ziglang/zig/issues/215>issue #215</a>. </p> <a name=//apple_ref/cpp/Guide/Input%20Constraints class=dashAnchor></a><h3 id=Input-Constraints>Input Constraints</h3> <p> Input constraints are still considered to be unstable in Zig, and so <a href=http://releases.llvm.org/10.0.0/docs/LangRef.html#inline-asm-constraint-string>LLVM documentation</a> and <a href=https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html>GCC documentation</a> must be used to understand the semantics. </p> <p> Note that some breaking changes to input constraints are planned with <a href=https://github.com/ziglang/zig/issues/215>issue #215</a>. </p> <a name=//apple_ref/cpp/Guide/Clobbers class=dashAnchor></a><h3 id=Clobbers>Clobbers</h3> <p> Clobbers are the set of registers whose values will not be preserved by the execution of the assembly code. These do not include output or input registers. The special clobber value of <code><span class=line><span class=tok-str>"memory"</span></span></code> means that the assembly causes writes to arbitrary undeclared memory locations - not only the memory pointed to by a declared indirect output. </p> <p> Failure to declare the full set of clobbers for a given inline assembly expression is unchecked <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <a name=//apple_ref/cpp/Guide/Global%20Assembly class=dashAnchor></a><h3 id=Global-Assembly>Global Assembly</h3> <p> When an assembly expression occurs in a container level <a href=#comptime>comptime</a> block, this is <strong>global assembly</strong>. </p> <p> This kind of assembly has different rules than inline assembly. First, <code><span class=line><span class=tok-kw>volatile</span></span></code> is not valid because all global assembly is unconditionally included. Second, there are no inputs, outputs, or clobbers. All global assembly is concatenated verbatim into one long string and assembled together. There are no template substitution rules regarding <code>%</code> as there are in inline assembly expressions. </p> <figure><figcaption class=zig-cap><cite class=file>global-asm.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>asm</span> (</span>
<span class=line>        <span class=tok-str>\\.global my_func;</span></span>
<span class=line>        <span class=tok-str>\\.type my_func, @function;</span></span>
<span class=line>        <span class=tok-str>\\my_func:</span></span>
<span class=line>        <span class=tok-str>\\  lea (%rdi,%rsi,1),%eax</span></span>
<span class=line>        <span class=tok-str>\\  retq</span></span>
<span class=line>    );</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>extern</span> <span class=tok-kw>fn</span> <span class=tok-fn>my_func</span>(a: <span class=tok-type>i32</span>, b: <span class=tok-type>i32</span>) <span class=tok-type>i32</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"global assembly"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(my_func(<span class=tok-number>12</span>, <span class=tok-number>34</span>) == <span class=tok-number>46</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test global-asm.zig -target x86_64-linux</kbd></span>
<span class=line>1/1 test.global assembly... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Atomics class=dashAnchor></a><h2 id=Atomics>Atomics</h2> <p>TODO: @fence()</p> <p>TODO: @atomic rmw</p> <p>TODO: builtin atomic memory ordering enum</p> <a name=//apple_ref/cpp/Guide/Async%20Functions class=dashAnchor></a><h2 id=Async-Functions>Async Functions</h2> <p> When a function is called, a frame is pushed to the stack, the function runs until it reaches a return statement, and then the frame is popped from the stack. The code following the callsite does not run until the function returns. </p> <p> An async function is a function whose execution is split into an <code><span class=line><span class=tok-kw>async</span></span></code> initiation, followed by an <code><span class=line><span class=tok-kw>await</span></span></code> completion. Its frame is provided explicitly by the caller, and it can be suspended and resumed any number of times. </p> <p> The code following the <code><span class=line><span class=tok-kw>async</span></span></code> callsite runs immediately after the async function first suspends. When the return value of the async function is needed, the calling code can <code><span class=line><span class=tok-kw>await</span></span></code> on the async function frame. This will suspend the calling code until the async function completes, at which point execution resumes just after the <code><span class=line><span class=tok-kw>await</span></span></code> callsite. </p> <p> Zig infers that a function is <code><span class=line><span class=tok-kw>async</span></span></code> when it observes that the function contains a <strong>suspension point</strong>. Async functions can be called the same as normal functions. A function call of an async function is a suspend point. </p> <a name=//apple_ref/cpp/Guide/Suspend%20and%20Resume class=dashAnchor></a><h3 id=Suspend-and-Resume>Suspend and Resume</h3> <p> At any point, a function may suspend itself. This causes control flow to return to the callsite (in the case of the first suspension), or resumer (in the case of subsequent suspensions). </p> <figure><figcaption class=zig-cap><cite class=file>suspend_no_resume.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> x: <span class=tok-type>i32</span> = <span class=tok-number>1</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"suspend with no resume"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> frame = <span class=tok-kw>async</span> func();</span>
<span class=line>    <span class=tok-kw>try</span> expect(x == <span class=tok-number>2</span>);</span>
<span class=line>    _ = frame;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>func</span>() <span class=tok-type>void</span> {</span>
<span class=line>    x += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>suspend</span> {}</span>
<span class=line>    <span class=tok-comment>// This line is never reached because the suspend has no matching resume.</span></span>
<span class=line>    x += <span class=tok-number>1</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test suspend_no_resume.zig -fstage1</kbd></span>
<span class=line>1/1 test "suspend with no resume"... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> In the same way that each allocation should have a corresponding free, Each <code><span class=line><span class=tok-kw>suspend</span></span></code> should have a corresponding <code><span class=line><span class=tok-kw>resume</span></span></code>. A <strong>suspend block</strong> allows a function to put a pointer to its own frame somewhere, for example into an event loop, even if that action will perform a <code><span class=line><span class=tok-kw>resume</span></span></code> operation on a different thread. <a href=#frame>@frame</a> provides access to the async function frame pointer. </p> <figure><figcaption class=zig-cap><cite class=file>async_suspend_block.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> the_frame: <span class=tok-kw>anyframe</span> = <span class=tok-null>undefined</span>;</span>
<span class=line><span class=tok-kw>var</span> result = <span class=tok-null>false</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"async function suspend with block"</span> {</span>
<span class=line>    _ = <span class=tok-kw>async</span> testSuspendBlock();</span>
<span class=line>    <span class=tok-kw>try</span> expect(!result);</span>
<span class=line>    <span class=tok-kw>resume</span> the_frame;</span>
<span class=line>    <span class=tok-kw>try</span> expect(result);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>testSuspendBlock</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>suspend</span> {</span>
<span class=line>        <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(<span class=tok-builtin>@frame</span>()) == *<span class=tok-builtin>@Frame</span>(testSuspendBlock));</span>
<span class=line>        the_frame = <span class=tok-builtin>@frame</span>();</span>
<span class=line>    }</span>
<span class=line>    result = <span class=tok-null>true</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test async_suspend_block.zig -fstage1</kbd></span>
<span class=line>1/1 test "async function suspend with block"... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> <code><span class=line><span class=tok-kw>suspend</span></span></code> causes a function to be <code><span class=line><span class=tok-kw>async</span></span></code>. </p> <a name=//apple_ref/cpp/Guide/Resuming%20from%20Suspend%20Blocks class=dashAnchor></a><h4 id=Resuming-from-Suspend-Blocks>Resuming from Suspend Blocks</h4> <p> Upon entering a <code><span class=line><span class=tok-kw>suspend</span></span></code> block, the async function is already considered suspended, and can be resumed. For example, if you started another kernel thread, and had that thread call <code><span class=line><span class=tok-kw>resume</span></span></code> on the frame pointer provided by the <a href=#frame>@frame</a>, the new thread would begin executing after the suspend block, while the old thread continued executing the suspend block. </p> <p> However, the async function can be directly resumed from the suspend block, in which case it never returns to its resumer and continues executing. </p> <figure><figcaption class=zig-cap><cite class=file>resume_from_suspend.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"resume from suspend"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> my_result: <span class=tok-type>i32</span> = <span class=tok-number>1</span>;</span>
<span class=line>    _ = <span class=tok-kw>async</span> testResumeFromSuspend(&amp;my_result);</span>
<span class=line>    <span class=tok-kw>try</span> std.testing.expect(my_result == <span class=tok-number>2</span>);</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>testResumeFromSuspend</span>(my_result: *<span class=tok-type>i32</span>) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>suspend</span> {</span>
<span class=line>        <span class=tok-kw>resume</span> <span class=tok-builtin>@frame</span>();</span>
<span class=line>    }</span>
<span class=line>    my_result.* += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>suspend</span> {}</span>
<span class=line>    my_result.* += <span class=tok-number>1</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test resume_from_suspend.zig -fstage1</kbd></span>
<span class=line>1/1 test "resume from suspend"... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> This is guaranteed to tail call, and therefore will not cause a new stack frame. </p> <a name=//apple_ref/cpp/Guide/Async%20and%20Await class=dashAnchor></a><h3 id=Async-and-Await>Async and Await</h3> <p> In the same way that every <code><span class=line><span class=tok-kw>suspend</span></span></code> has a matching <code><span class=line><span class=tok-kw>resume</span></span></code>, every <code><span class=line><span class=tok-kw>async</span></span></code> has a matching <code><span class=line><span class=tok-kw>await</span></span></code> in standard code. </p> <p> However, it is possible to have an <code><span class=line><span class=tok-kw>async</span></span></code> call without a matching <code><span class=line><span class=tok-kw>await</span></span></code>. Upon completion of the async function, execution would continue at the most recent <code><span class=line><span class=tok-kw>async</span></span></code> callsite or <code><span class=line><span class=tok-kw>resume</span></span></code> callsite, and the return value of the async function would be lost. </p> <figure><figcaption class=zig-cap><cite class=file>async_await.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"async and await"</span> {</span>
<span class=line>    <span class=tok-comment>// The test block is not async and so cannot have a suspend</span></span>
<span class=line>    <span class=tok-comment>// point in it. By using the nosuspend keyword, we promise that</span></span>
<span class=line>    <span class=tok-comment>// the code in amain will finish executing without suspending</span></span>
<span class=line>    <span class=tok-comment>// back to the test block.</span></span>
<span class=line>    <span class=tok-kw>nosuspend</span> amain();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>amain</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> frame = <span class=tok-kw>async</span> func();</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(frame) == <span class=tok-builtin>@Frame</span>(func));</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> ptr: <span class=tok-kw>anyframe</span>-&gt;<span class=tok-type>void</span> = &amp;frame;</span>
<span class=line>    <span class=tok-kw>const</span> any_ptr: <span class=tok-kw>anyframe</span> = ptr;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>resume</span> any_ptr;</span>
<span class=line>    <span class=tok-kw>await</span> ptr;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>func</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>suspend</span> {}</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test async_await.zig -fstage1</kbd></span>
<span class=line>1/1 test "async and await"... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> The <code><span class=line><span class=tok-kw>await</span></span></code> keyword is used to coordinate with an async function's <code><span class=line><span class=tok-kw>return</span></span></code> statement. </p> <p> <code><span class=line><span class=tok-kw>await</span></span></code> is a suspend point, and takes as an operand anything that coerces to <code><span class=line><span class=tok-kw>anyframe</span>-&gt;T</span></code>. Calling <code><span class=line><span class=tok-kw>await</span></span></code> on the frame of an async function will cause execution to continue at the <code><span class=line><span class=tok-kw>await</span></span></code> callsite once the target function completes. </p> <p> There is a common misconception that <code><span class=line><span class=tok-kw>await</span></span></code> resumes the target function. It is the other way around: it suspends until the target function completes. In the event that the target function has already completed, <code><span class=line><span class=tok-kw>await</span></span></code> does not suspend; instead it copies the return value directly from the target function's frame. </p> <figure><figcaption class=zig-cap><cite class=file>async_await_sequence.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> the_frame: <span class=tok-kw>anyframe</span> = <span class=tok-null>undefined</span>;</span>
<span class=line><span class=tok-kw>var</span> final_result: <span class=tok-type>i32</span> = <span class=tok-number>0</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"async function await"</span> {</span>
<span class=line>    seq(<span class=tok-str>'a'</span>);</span>
<span class=line>    _ = <span class=tok-kw>async</span> amain();</span>
<span class=line>    seq(<span class=tok-str>'f'</span>);</span>
<span class=line>    <span class=tok-kw>resume</span> the_frame;</span>
<span class=line>    seq(<span class=tok-str>'i'</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(final_result == <span class=tok-number>1234</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>u8</span>, &amp;seq_points, <span class=tok-str>"abcdefghi"</span>));</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>amain</span>() <span class=tok-type>void</span> {</span>
<span class=line>    seq(<span class=tok-str>'b'</span>);</span>
<span class=line>    <span class=tok-kw>var</span> f = <span class=tok-kw>async</span> another();</span>
<span class=line>    seq(<span class=tok-str>'e'</span>);</span>
<span class=line>    final_result = <span class=tok-kw>await</span> f;</span>
<span class=line>    seq(<span class=tok-str>'h'</span>);</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>another</span>() <span class=tok-type>i32</span> {</span>
<span class=line>    seq(<span class=tok-str>'c'</span>);</span>
<span class=line>    <span class=tok-kw>suspend</span> {</span>
<span class=line>        seq(<span class=tok-str>'d'</span>);</span>
<span class=line>        the_frame = <span class=tok-builtin>@frame</span>();</span>
<span class=line>    }</span>
<span class=line>    seq(<span class=tok-str>'g'</span>);</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-number>1234</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> seq_points = [_]<span class=tok-type>u8</span>{<span class=tok-number>0</span>} ** <span class=tok-str>"abcdefghi"</span>.len;</span>
<span class=line><span class=tok-kw>var</span> seq_index: <span class=tok-type>usize</span> = <span class=tok-number>0</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>seq</span>(c: <span class=tok-type>u8</span>) <span class=tok-type>void</span> {</span>
<span class=line>    seq_points[seq_index] = c;</span>
<span class=line>    seq_index += <span class=tok-number>1</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test async_await_sequence.zig -fstage1</kbd></span>
<span class=line>1/1 test "async function await"... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> In general, <code><span class=line><span class=tok-kw>suspend</span></span></code> is lower level than <code><span class=line><span class=tok-kw>await</span></span></code>. Most application code will use only <code><span class=line><span class=tok-kw>async</span></span></code> and <code><span class=line><span class=tok-kw>await</span></span></code>, but event loop implementations will make use of <code><span class=line><span class=tok-kw>suspend</span></span></code> internally. </p> <a name=//apple_ref/cpp/Guide/Async%20Function%20Example class=dashAnchor></a><h3 id=Async-Function-Example>Async Function Example</h3> <p> Putting all of this together, here is an example of typical <code><span class=line><span class=tok-kw>async</span></span></code>/<code><span class=line><span class=tok-kw>await</span></span></code> usage: </p> <figure><figcaption class=zig-cap><cite class=file>async.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> Allocator = std.mem.Allocator;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    _ = <span class=tok-kw>async</span> amainWrap();</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Typically we would use an event loop to manage resuming async functions,</span></span>
<span class=line>    <span class=tok-comment>// but in this example we hard code what the event loop would do,</span></span>
<span class=line>    <span class=tok-comment>// to make things deterministic.</span></span>
<span class=line>    <span class=tok-kw>resume</span> global_file_frame;</span>
<span class=line>    <span class=tok-kw>resume</span> global_download_frame;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>amainWrap</span>() <span class=tok-type>void</span> {</span>
<span class=line>    amain() <span class=tok-kw>catch</span> |e| {</span>
<span class=line>        std.debug.print(<span class=tok-str>"{}\n"</span>, .{e});</span>
<span class=line>        <span class=tok-kw>if</span> (<span class=tok-builtin>@errorReturnTrace</span>()) |trace| {</span>
<span class=line>            std.debug.dumpStackTrace(trace.*);</span>
<span class=line>        }</span>
<span class=line>        std.process.exit(<span class=tok-number>1</span>);</span>
<span class=line>    };</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>amain</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> allocator = std.heap.page_allocator;</span>
<span class=line>    <span class=tok-kw>var</span> download_frame = <span class=tok-kw>async</span> fetchUrl(allocator, <span class=tok-str>"https://example.com/"</span>);</span>
<span class=line>    <span class=tok-kw>var</span> awaited_download_frame = <span class=tok-null>false</span>;</span>
<span class=line>    <span class=tok-kw>errdefer</span> <span class=tok-kw>if</span> (!awaited_download_frame) {</span>
<span class=line>        <span class=tok-kw>if</span> (<span class=tok-kw>await</span> download_frame) |r| allocator.free(r) <span class=tok-kw>else</span> |_| {}</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> file_frame = <span class=tok-kw>async</span> readFile(allocator, <span class=tok-str>"something.txt"</span>);</span>
<span class=line>    <span class=tok-kw>var</span> awaited_file_frame = <span class=tok-null>false</span>;</span>
<span class=line>    <span class=tok-kw>errdefer</span> <span class=tok-kw>if</span> (!awaited_file_frame) {</span>
<span class=line>        <span class=tok-kw>if</span> (<span class=tok-kw>await</span> file_frame) |r| allocator.free(r) <span class=tok-kw>else</span> |_| {}</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    awaited_file_frame = <span class=tok-null>true</span>;</span>
<span class=line>    <span class=tok-kw>const</span> file_text = <span class=tok-kw>try</span> <span class=tok-kw>await</span> file_frame;</span>
<span class=line>    <span class=tok-kw>defer</span> allocator.free(file_text);</span>
<span class=line></span>
<span class=line>    awaited_download_frame = <span class=tok-null>true</span>;</span>
<span class=line>    <span class=tok-kw>const</span> download_text = <span class=tok-kw>try</span> <span class=tok-kw>await</span> download_frame;</span>
<span class=line>    <span class=tok-kw>defer</span> allocator.free(download_text);</span>
<span class=line></span>
<span class=line>    std.debug.print(<span class=tok-str>"download_text: {s}\n"</span>, .{download_text});</span>
<span class=line>    std.debug.print(<span class=tok-str>"file_text: {s}\n"</span>, .{file_text});</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> global_download_frame: <span class=tok-kw>anyframe</span> = <span class=tok-null>undefined</span>;</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>fetchUrl</span>(allocator: Allocator, url: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) ![]<span class=tok-type>u8</span> {</span>
<span class=line>    _ = url; <span class=tok-comment>// this is just an example, we don't actually do it!</span></span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>try</span> allocator.dupe(<span class=tok-type>u8</span>, <span class=tok-str>"this is the downloaded url contents"</span>);</span>
<span class=line>    <span class=tok-kw>errdefer</span> allocator.free(result);</span>
<span class=line>    <span class=tok-kw>suspend</span> {</span>
<span class=line>        global_download_frame = <span class=tok-builtin>@frame</span>();</span>
<span class=line>    }</span>
<span class=line>    std.debug.print(<span class=tok-str>"fetchUrl returning\n"</span>, .{});</span>
<span class=line>    <span class=tok-kw>return</span> result;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>var</span> global_file_frame: <span class=tok-kw>anyframe</span> = <span class=tok-null>undefined</span>;</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>readFile</span>(allocator: Allocator, filename: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) ![]<span class=tok-type>u8</span> {</span>
<span class=line>    _ = filename; <span class=tok-comment>// this is just an example, we don't actually do it!</span></span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>try</span> allocator.dupe(<span class=tok-type>u8</span>, <span class=tok-str>"this is the file contents"</span>);</span>
<span class=line>    <span class=tok-kw>errdefer</span> allocator.free(result);</span>
<span class=line>    <span class=tok-kw>suspend</span> {</span>
<span class=line>        global_file_frame = <span class=tok-builtin>@frame</span>();</span>
<span class=line>    }</span>
<span class=line>    std.debug.print(<span class=tok-str>"readFile returning\n"</span>, .{});</span>
<span class=line>    <span class=tok-kw>return</span> result;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe async.zig -fstage1</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./async</kbd></span>
<span class=line>readFile returning</span>
<span class=line>fetchUrl returning</span>
<span class=line>download_text: this is the downloaded url contents</span>
<span class=line>file_text: this is the file contents</span>
</samp></pre></figure> <p> Now we remove the <code><span class=line><span class=tok-kw>suspend</span></span></code> and <code><span class=line><span class=tok-kw>resume</span></span></code> code, and observe the same behavior, with one tiny difference: </p> <figure><figcaption class=zig-cap><cite class=file>blocking.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> Allocator = std.mem.Allocator;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    _ = <span class=tok-kw>async</span> amainWrap();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>amainWrap</span>() <span class=tok-type>void</span> {</span>
<span class=line>    amain() <span class=tok-kw>catch</span> |e| {</span>
<span class=line>        std.debug.print(<span class=tok-str>"{}\n"</span>, .{e});</span>
<span class=line>        <span class=tok-kw>if</span> (<span class=tok-builtin>@errorReturnTrace</span>()) |trace| {</span>
<span class=line>            std.debug.dumpStackTrace(trace.*);</span>
<span class=line>        }</span>
<span class=line>        std.process.exit(<span class=tok-number>1</span>);</span>
<span class=line>    };</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>amain</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> allocator = std.heap.page_allocator;</span>
<span class=line>    <span class=tok-kw>var</span> download_frame = <span class=tok-kw>async</span> fetchUrl(allocator, <span class=tok-str>"https://example.com/"</span>);</span>
<span class=line>    <span class=tok-kw>var</span> awaited_download_frame = <span class=tok-null>false</span>;</span>
<span class=line>    <span class=tok-kw>errdefer</span> <span class=tok-kw>if</span> (!awaited_download_frame) {</span>
<span class=line>        <span class=tok-kw>if</span> (<span class=tok-kw>await</span> download_frame) |r| allocator.free(r) <span class=tok-kw>else</span> |_| {}</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> file_frame = <span class=tok-kw>async</span> readFile(allocator, <span class=tok-str>"something.txt"</span>);</span>
<span class=line>    <span class=tok-kw>var</span> awaited_file_frame = <span class=tok-null>false</span>;</span>
<span class=line>    <span class=tok-kw>errdefer</span> <span class=tok-kw>if</span> (!awaited_file_frame) {</span>
<span class=line>        <span class=tok-kw>if</span> (<span class=tok-kw>await</span> file_frame) |r| allocator.free(r) <span class=tok-kw>else</span> |_| {}</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    awaited_file_frame = <span class=tok-null>true</span>;</span>
<span class=line>    <span class=tok-kw>const</span> file_text = <span class=tok-kw>try</span> <span class=tok-kw>await</span> file_frame;</span>
<span class=line>    <span class=tok-kw>defer</span> allocator.free(file_text);</span>
<span class=line></span>
<span class=line>    awaited_download_frame = <span class=tok-null>true</span>;</span>
<span class=line>    <span class=tok-kw>const</span> download_text = <span class=tok-kw>try</span> <span class=tok-kw>await</span> download_frame;</span>
<span class=line>    <span class=tok-kw>defer</span> allocator.free(download_text);</span>
<span class=line></span>
<span class=line>    std.debug.print(<span class=tok-str>"download_text: {s}\n"</span>, .{download_text});</span>
<span class=line>    std.debug.print(<span class=tok-str>"file_text: {s}\n"</span>, .{file_text});</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>fetchUrl</span>(allocator: Allocator, url: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) ![]<span class=tok-type>u8</span> {</span>
<span class=line>    _ = url; <span class=tok-comment>// this is just an example, we don't actually do it!</span></span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>try</span> allocator.dupe(<span class=tok-type>u8</span>, <span class=tok-str>"this is the downloaded url contents"</span>);</span>
<span class=line>    <span class=tok-kw>errdefer</span> allocator.free(result);</span>
<span class=line>    std.debug.print(<span class=tok-str>"fetchUrl returning\n"</span>, .{});</span>
<span class=line>    <span class=tok-kw>return</span> result;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>readFile</span>(allocator: Allocator, filename: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) ![]<span class=tok-type>u8</span> {</span>
<span class=line>    _ = filename; <span class=tok-comment>// this is just an example, we don't actually do it!</span></span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>try</span> allocator.dupe(<span class=tok-type>u8</span>, <span class=tok-str>"this is the file contents"</span>);</span>
<span class=line>    <span class=tok-kw>errdefer</span> allocator.free(result);</span>
<span class=line>    std.debug.print(<span class=tok-str>"readFile returning\n"</span>, .{});</span>
<span class=line>    <span class=tok-kw>return</span> result;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe blocking.zig -fstage1</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./blocking</kbd></span>
<span class=line>fetchUrl returning</span>
<span class=line>readFile returning</span>
<span class=line>download_text: this is the downloaded url contents</span>
<span class=line>file_text: this is the file contents</span>
</samp></pre></figure> <p> Previously, the <code><span class=line>fetchUrl</span></code> and <code><span class=line>readFile</span></code> functions suspended, and were resumed in an order determined by the <code><span class=line>main</span></code> function. Now, since there are no suspend points, the order of the printed "... returning" messages is determined by the order of <code><span class=line><span class=tok-kw>async</span></span></code> callsites. </p> <a name=//apple_ref/cpp/Guide/Builtin%20Functions class=dashAnchor></a><h2 id=Builtin-Functions>Builtin Functions</h2> <p> Builtin functions are provided by the compiler and are prefixed with <code>@</code>. The <code><span class=line><span class=tok-kw>comptime</span></span></code> keyword on a parameter means that the parameter must be known at compile time. </p> <a name=//apple_ref/cpp/Builtin/%40addrSpaceCast class=dashAnchor></a><h3 id=addrSpaceCast>@addrSpaceCast</h3> <pre><code><span class=line><span class=tok-builtin>@addrSpaceCast</span>(<span class=tok-kw>comptime</span> <span class=tok-kw>addrspace</span>: std.builtin.AddressSpace, ptr: <span class=tok-kw>anytype</span>) <span class=tok-kw>anytype</span></span></code></pre> <p> Converts a pointer from one address space to another. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the pointer operand. It is always valid to cast a pointer between the same address spaces. </p> <a name=//apple_ref/cpp/Builtin/%40addWithOverflow class=dashAnchor></a><h3 id=addWithOverflow>@addWithOverflow</h3> <pre><code><span class=line><span class=tok-builtin>@addWithOverflow</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, b: T, result: *T) <span class=tok-type>bool</span></span></code></pre> <p> Performs <code><span class=line>result.* = a + b</span></code>. If overflow or underflow occurs, stores the overflowed bits in <code><span class=line>result</span></code> and returns <code><span class=line><span class=tok-null>true</span></span></code>. If no overflow or underflow occurs, returns <code><span class=line><span class=tok-null>false</span></span></code>. </p> <a name=//apple_ref/cpp/Builtin/%40alignCast class=dashAnchor></a><h3 id=alignCast>@alignCast</h3> <pre><code><span class=line><span class=tok-builtin>@alignCast</span>(<span class=tok-kw>comptime</span> alignment: <span class=tok-type>u29</span>, ptr: <span class=tok-kw>anytype</span>) <span class=tok-kw>anytype</span></span></code></pre> <p> <code><span class=line>ptr</span></code> can be <code><span class=line>*T</span></code>, <code><span class=line>?*T</span></code>, or <code><span class=line>[]T</span></code>. It returns the same type as <code><span class=line>ptr</span></code> except with the alignment adjusted to the new value. </p> <p>A <a href=#Incorrect-Pointer-Alignment>pointer alignment safety check</a> is added to the generated code to make sure the pointer is aligned as promised.</p> <a name=//apple_ref/cpp/Builtin/%40alignOf class=dashAnchor></a><h3 id=alignOf>@alignOf</h3> <pre><code><span class=line><span class=tok-builtin>@alignOf</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>) <span class=tok-type>comptime_int</span></span></code></pre> <p> This function returns the number of bytes that this type should be aligned to for the current target to match the C ABI. When the child type of a pointer has this alignment, the alignment can be omitted from the type. </p> <pre><code><span class=line><span class=tok-kw>const</span> assert = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.assert;</span>
<span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    assert(*<span class=tok-type>u32</span> == *<span class=tok-kw>align</span>(<span class=tok-builtin>@alignOf</span>(<span class=tok-type>u32</span>)) <span class=tok-type>u32</span>);</span>
<span class=line>}</span></code></pre> <p> The result is a target-specific compile time constant. It is guaranteed to be less than or equal to <a href=#sizeOf>@sizeOf(T)</a>. </p> <p>See also:</p><ul> <li><a href=#Alignment>Alignment</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40as class=dashAnchor></a><h3 id=as>@as</h3> <pre><code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, expression) T</span></code></pre> <p> Performs <a href=#Type-Coercion>Type Coercion</a>. This cast is allowed when the conversion is unambiguous and safe, and is the preferred way to convert between types, whenever possible. </p> <a name=//apple_ref/cpp/Builtin/%40asyncCall class=dashAnchor></a><h3 id=asyncCall>@asyncCall</h3> <pre><code><span class=line><span class=tok-builtin>@asyncCall</span>(frame_buffer: []<span class=tok-kw>align</span>(<span class=tok-builtin>@alignOf</span>(<span class=tok-builtin>@Frame</span>(anyAsyncFunction))) <span class=tok-type>u8</span>, result_ptr, function_ptr, args: <span class=tok-kw>anytype</span>) <span class=tok-kw>anyframe</span>-&gt;T</span></code></pre> <p> <code><span class=line><span class=tok-builtin>@asyncCall</span></span></code> performs an <code><span class=line><span class=tok-kw>async</span></span></code> call on a function pointer, which may or may not be an <a href=#Async-Functions>async function</a>. </p> <p> The provided <code><span class=line>frame_buffer</span></code> must be large enough to fit the entire function frame. This size can be determined with <a href=#frameSize>@frameSize</a>. To provide a too-small buffer invokes safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <p> <code><span class=line>result_ptr</span></code> is optional (<a href=#null>null</a> may be provided). If provided, the function call will write its result directly to the result pointer, which will be available to read after <a href=#Async-and-Await>await</a> completes. Any result location provided to <code><span class=line><span class=tok-kw>await</span></span></code> will copy the result from <code><span class=line>result_ptr</span></code>. </p> <figure><figcaption class=zig-cap><cite class=file>async_struct_field_fn_pointer.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"async fn pointer in a struct field"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> data: <span class=tok-type>i32</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>const</span> Foo = <span class=tok-kw>struct</span> {</span>
<span class=line>        bar: <span class=tok-kw>fn</span> (*<span class=tok-type>i32</span>) <span class=tok-kw>callconv</span>(.Async) <span class=tok-type>void</span>,</span>
<span class=line>    };</span>
<span class=line>    <span class=tok-kw>var</span> foo = Foo{ .bar = func };</span>
<span class=line>    <span class=tok-kw>var</span> bytes: [<span class=tok-number>64</span>]<span class=tok-type>u8</span> <span class=tok-kw>align</span>(<span class=tok-builtin>@alignOf</span>(<span class=tok-builtin>@Frame</span>(func))) = <span class=tok-null>undefined</span>;</span>
<span class=line>    <span class=tok-kw>const</span> f = <span class=tok-builtin>@asyncCall</span>(&amp;bytes, {}, foo.bar, .{&amp;data});</span>
<span class=line>    <span class=tok-kw>try</span> expect(data == <span class=tok-number>2</span>);</span>
<span class=line>    <span class=tok-kw>resume</span> f;</span>
<span class=line>    <span class=tok-kw>try</span> expect(data == <span class=tok-number>4</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>func</span>(y: *<span class=tok-type>i32</span>) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>defer</span> y.* += <span class=tok-number>2</span>;</span>
<span class=line>    y.* += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>suspend</span> {}</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test async_struct_field_fn_pointer.zig -fstage1</kbd></span>
<span class=line>1/1 test "async fn pointer in a struct field"... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Builtin/%40atomicLoad class=dashAnchor></a><h3 id=atomicLoad>@atomicLoad</h3> <pre><code><span class=line><span class=tok-builtin>@atomicLoad</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, ptr: *<span class=tok-kw>const</span> T, <span class=tok-kw>comptime</span> ordering: builtin.AtomicOrder) T</span></code></pre> <p> This builtin function atomically dereferences a pointer and returns the value. </p> <p> <code><span class=line>T</span></code> must be a pointer, a <code><span class=line><span class=tok-type>bool</span></span></code>, a float, an integer or an enum. </p> <p>See also:</p><ul> <li><a href=#atomicStore>@atomicStore</a></li> <li><a href=#atomicRmw>@atomicRmw</a></li> <li><a href=#fence>@fence</a></li> <li><a href=#cmpxchgWeak>@cmpxchgWeak</a></li> <li><a href=#cmpxchgStrong>@cmpxchgStrong</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40atomicRmw class=dashAnchor></a><h3 id=atomicRmw>@atomicRmw</h3> <pre><code><span class=line><span class=tok-builtin>@atomicRmw</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, ptr: *T, <span class=tok-kw>comptime</span> op: builtin.AtomicRmwOp, operand: T, <span class=tok-kw>comptime</span> ordering: builtin.AtomicOrder) T</span></code></pre> <p> This builtin function atomically modifies memory and then returns the previous value. </p> <p> <code><span class=line>T</span></code> must be a pointer, a <code><span class=line><span class=tok-type>bool</span></span></code>, a float, an integer or an enum. </p> <p> Supported operations: </p> <ul> <li><code><span class=line>.Xchg</span></code> - stores the operand unmodified. Supports enums, integers and floats.</li> <li><code><span class=line>.Add</span></code> - for integers, twos complement wraparound addition. Also supports <a href=#Floats>Floats</a>.</li> <li><code><span class=line>.Sub</span></code> - for integers, twos complement wraparound subtraction. Also supports <a href=#Floats>Floats</a>.</li> <li><code><span class=line>.And</span></code> - bitwise and</li> <li><code><span class=line>.Nand</span></code> - bitwise nand</li> <li><code><span class=line>.Or</span></code> - bitwise or</li> <li><code><span class=line>.Xor</span></code> - bitwise xor</li> <li><code><span class=line>.Max</span></code> - stores the operand if it is larger. Supports integers and floats.</li> <li><code><span class=line>.Min</span></code> - stores the operand if it is smaller. Supports integers and floats.</li> </ul> <p>See also:</p><ul> <li><a href=#atomicStore>@atomicStore</a></li> <li><a href=#atomicLoad>@atomicLoad</a></li> <li><a href=#fence>@fence</a></li> <li><a href=#cmpxchgWeak>@cmpxchgWeak</a></li> <li><a href=#cmpxchgStrong>@cmpxchgStrong</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40atomicStore class=dashAnchor></a><h3 id=atomicStore>@atomicStore</h3> <pre><code><span class=line><span class=tok-builtin>@atomicStore</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, ptr: *T, value: T, <span class=tok-kw>comptime</span> ordering: builtin.AtomicOrder) <span class=tok-type>void</span></span></code></pre> <p> This builtin function atomically stores a value. </p> <p> <code><span class=line>T</span></code> must be a pointer, a <code><span class=line><span class=tok-type>bool</span></span></code>, a float, an integer or an enum. </p> <p>See also:</p><ul> <li><a href=#atomicLoad>@atomicLoad</a></li> <li><a href=#atomicRmw>@atomicRmw</a></li> <li><a href=#fence>@fence</a></li> <li><a href=#cmpxchgWeak>@cmpxchgWeak</a></li> <li><a href=#cmpxchgStrong>@cmpxchgStrong</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40bitCast class=dashAnchor></a><h3 id=bitCast>@bitCast</h3> <pre><code><span class=line><span class=tok-builtin>@bitCast</span>(<span class=tok-kw>comptime</span> DestType: <span class=tok-type>type</span>, value: <span class=tok-kw>anytype</span>) DestType</span></code></pre> <p> Converts a value of one type to another type. </p> <p> Asserts that <code><span class=line><span class=tok-builtin>@sizeOf</span>(<span class=tok-builtin>@TypeOf</span>(value)) == <span class=tok-builtin>@sizeOf</span>(DestType)</span></code>. </p> <p> Asserts that <code><span class=line><span class=tok-builtin>@typeInfo</span>(DestType) != .Pointer</span></code>. Use <code><span class=line><span class=tok-builtin>@ptrCast</span></span></code> or <code><span class=line><span class=tok-builtin>@intToPtr</span></span></code> if you need this. </p> <p> Can be used for these things for example: </p> <ul> <li>Convert <code><span class=line><span class=tok-type>f32</span></span></code> to <code><span class=line><span class=tok-type>u32</span></span></code> bits</li> <li>Convert <code><span class=line><span class=tok-type>i32</span></span></code> to <code><span class=line><span class=tok-type>u32</span></span></code> preserving twos complement</li> </ul> <p> Works at compile-time if <code><span class=line>value</span></code> is known at compile time. It's a compile error to bitcast a value of undefined layout; this means that, besides the restriction from types which possess dedicated casting builtins (enums, pointers, error sets), bare structs, error unions, slices, optionals, and any other type without a well-defined memory layout, also cannot be used in this operation. </p> <a name=//apple_ref/cpp/Builtin/%40bitOffsetOf class=dashAnchor></a><h3 id=bitOffsetOf>@bitOffsetOf</h3> <pre><code><span class=line><span class=tok-builtin>@bitOffsetOf</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, <span class=tok-kw>comptime</span> field_name: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) <span class=tok-type>comptime_int</span></span></code></pre> <p> Returns the bit offset of a field relative to its containing struct. </p> <p> For non <a href=#packed-struct>packed structs</a>, this will always be divisible by <code><span class=line><span class=tok-number>8</span></span></code>. For packed structs, non-byte-aligned fields will share a byte offset, but they will have different bit offsets. </p> <p>See also:</p><ul> <li><a href=#offsetOf>@offsetOf</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40boolToInt class=dashAnchor></a><h3 id=boolToInt>@boolToInt</h3> <pre><code><span class=line><span class=tok-builtin>@boolToInt</span>(value: <span class=tok-type>bool</span>) <span class=tok-type>u1</span></span></code></pre> <p> Converts <code><span class=line><span class=tok-null>true</span></span></code> to <code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>u1</span>, <span class=tok-number>1</span>)</span></code> and <code><span class=line><span class=tok-null>false</span></span></code> to <code><span class=line><span class=tok-builtin>@as</span>(<span class=tok-type>u1</span>, <span class=tok-number>0</span>)</span></code>. </p> <p> If the value is known at compile-time, the return type is <code><span class=line><span class=tok-type>comptime_int</span></span></code> instead of <code><span class=line><span class=tok-type>u1</span></span></code>. </p> <a name=//apple_ref/cpp/Builtin/%40bitSizeOf class=dashAnchor></a><h3 id=bitSizeOf>@bitSizeOf</h3> <pre><code><span class=line><span class=tok-builtin>@bitSizeOf</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>) <span class=tok-type>comptime_int</span></span></code></pre> <p> This function returns the number of bits it takes to store <code><span class=line>T</span></code> in memory if the type were a field in a packed struct/union. The result is a target-specific compile time constant. </p> <p> This function measures the size at runtime. For types that are disallowed at runtime, such as <code><span class=line><span class=tok-type>comptime_int</span></span></code> and <code><span class=line><span class=tok-type>type</span></span></code>, the result is <code><span class=line><span class=tok-number>0</span></span></code>. </p> <p>See also:</p><ul> <li><a href=#sizeOf>@sizeOf</a></li> <li><a href=#typeInfo>@typeInfo</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40breakpoint class=dashAnchor></a><h3 id=breakpoint>@breakpoint</h3> <pre><code><span class=line><span class=tok-builtin>@breakpoint</span>()</span></code></pre> <p> This function inserts a platform-specific debug trap instruction which causes debuggers to break there. </p> <p> This function is only valid within function scope. </p> <a name=//apple_ref/cpp/Builtin/%40mulAdd class=dashAnchor></a><h3 id=mulAdd>@mulAdd</h3> <pre><code><span class=line><span class=tok-builtin>@mulAdd</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, b: T, c: T) T</span></code></pre> <p> Fused multiply-add, similar to <code><span class=line>(a * b) + c</span></code>, except only rounds once, and is thus more accurate. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats. </p> <a name=//apple_ref/cpp/Builtin/%40byteSwap class=dashAnchor></a><h3 id=byteSwap>@byteSwap</h3> <pre><code><span class=line><span class=tok-builtin>@byteSwap</span>(operand: <span class=tok-kw>anytype</span>) T</span></code></pre> <p><code><span class=line><span class=tok-builtin>@TypeOf</span>(operand)</span></code> must be an integer type or an integer vector type with bit count evenly divisible by 8.</p> <p><code><span class=line>operand</span></code> may be an <a href=#Integers>integer</a> or <a href=#Vectors>vector</a>.</p> <p> Swaps the byte order of the integer. This converts a big endian integer to a little endian integer, and converts a little endian integer to a big endian integer. </p> <p> Note that for the purposes of memory layout with respect to endianness, the integer type should be related to the number of bytes reported by <a href=#sizeOf>@sizeOf</a> bytes. This is demonstrated with <code><span class=line><span class=tok-type>u24</span></span></code>. <code><span class=line><span class=tok-builtin>@sizeOf</span>(<span class=tok-type>u24</span>) == <span class=tok-number>4</span></span></code>, which means that a <code><span class=line><span class=tok-type>u24</span></span></code> stored in memory takes 4 bytes, and those 4 bytes are what are swapped on a little vs big endian system. On the other hand, if <code><span class=line>T</span></code> is specified to be <code><span class=line><span class=tok-type>u24</span></span></code>, then only 3 bytes are reversed. </p> <a name=//apple_ref/cpp/Builtin/%40bitReverse class=dashAnchor></a><h3 id=bitReverse>@bitReverse</h3> <pre><code><span class=line><span class=tok-builtin>@bitReverse</span>(integer: <span class=tok-kw>anytype</span>) T</span></code></pre> <p><code><span class=line><span class=tok-builtin>@TypeOf</span>(<span class=tok-kw>anytype</span>)</span></code> accepts any integer type or integer vector type.</p> <p> Reverses the bitpattern of an integer value, including the sign bit if applicable. </p> <p> For example 0b10110110 (<code><span class=line><span class=tok-type>u8</span> = <span class=tok-number>182</span></span></code>, <code><span class=line><span class=tok-type>i8</span> = -<span class=tok-number>74</span></span></code>) becomes 0b01101101 (<code><span class=line><span class=tok-type>u8</span> = <span class=tok-number>109</span></span></code>, <code><span class=line><span class=tok-type>i8</span> = <span class=tok-number>109</span></span></code>). </p> <a name=//apple_ref/cpp/Builtin/%40offsetOf class=dashAnchor></a><h3 id=offsetOf>@offsetOf</h3> <pre><code><span class=line><span class=tok-builtin>@offsetOf</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, <span class=tok-kw>comptime</span> field_name: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) <span class=tok-type>comptime_int</span></span></code></pre> <p> Returns the byte offset of a field relative to its containing struct. </p> <p>See also:</p><ul> <li><a href=#bitOffsetOf>@bitOffsetOf</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40call class=dashAnchor></a><h3 id=call>@call</h3> <pre><code><span class=line><span class=tok-builtin>@call</span>(options: std.builtin.CallOptions, function: <span class=tok-kw>anytype</span>, args: <span class=tok-kw>anytype</span>) <span class=tok-kw>anytype</span></span></code></pre> <p> Calls a function, in the same way that invoking an expression with parentheses does: </p> <figure><figcaption class=zig-cap><cite class=file>call.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> expect = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"noinline function call"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@call</span>(.{}, add, .{<span class=tok-number>3</span>, <span class=tok-number>9</span>}) == <span class=tok-number>12</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>add</span>(a: <span class=tok-type>i32</span>, b: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> a + b;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test call.zig</kbd></span>
<span class=line>1/1 test.noinline function call... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> <code><span class=line><span class=tok-builtin>@call</span></span></code> allows more flexibility than normal function call syntax does. The <code><span class=line>CallOptions</span></code> struct is reproduced here: </p> <figure><figcaption class=zig-cap><cite class=file>builtin.CallOptions struct</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> CallOptions = <span class=tok-kw>struct</span> {</span>
<span class=line>    modifier: Modifier = .auto,</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>/// Only valid when `Modifier` is `Modifier.async_kw`.</span></span>
<span class=line>    stack: ?[]<span class=tok-kw>align</span>(std.Target.stack_align) <span class=tok-type>u8</span> = <span class=tok-null>null</span>,</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>const</span> Modifier = <span class=tok-kw>enum</span> {</span>
<span class=line>        <span class=tok-comment>/// Equivalent to function call syntax.</span></span>
<span class=line>        auto,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>/// Equivalent to async keyword used with function call syntax.</span></span>
<span class=line>        async_kw,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>/// Prevents tail call optimization. This guarantees that the return</span></span>
<span class=line>        <span class=tok-comment>/// address will point to the callsite, as opposed to the callsite's</span></span>
<span class=line>        <span class=tok-comment>/// callsite. If the call is otherwise required to be tail-called</span></span>
<span class=line>        <span class=tok-comment>/// or inlined, a compile error is emitted instead.</span></span>
<span class=line>        never_tail,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>/// Guarantees that the call will not be inlined. If the call is</span></span>
<span class=line>        <span class=tok-comment>/// otherwise required to be inlined, a compile error is emitted instead.</span></span>
<span class=line>        never_inline,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>/// Asserts that the function call will not suspend. This allows a</span></span>
<span class=line>        <span class=tok-comment>/// non-async function to call an async function.</span></span>
<span class=line>        no_async,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>/// Guarantees that the call will be generated with tail call optimization.</span></span>
<span class=line>        <span class=tok-comment>/// If this is not possible, a compile error is emitted instead.</span></span>
<span class=line>        always_tail,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>/// Guarantees that the call will inlined at the callsite.</span></span>
<span class=line>        <span class=tok-comment>/// If this is not possible, a compile error is emitted instead.</span></span>
<span class=line>        always_inline,</span>
<span class=line></span>
<span class=line>        <span class=tok-comment>/// Evaluates the call at compile-time. If the call cannot be completed at</span></span>
<span class=line>        <span class=tok-comment>/// compile-time, a compile error is emitted instead.</span></span>
<span class=line>        compile_time,</span>
<span class=line>    };</span>
<span class=line>};</span></code></pre></figure> <a name=//apple_ref/cpp/Builtin/%40cDefine class=dashAnchor></a><h3 id=cDefine>@cDefine</h3> <pre><code><span class=line><span class=tok-builtin>@cDefine</span>(<span class=tok-kw>comptime</span> name: []<span class=tok-type>u8</span>, value)</span></code></pre> <p> This function can only occur inside <code><span class=line><span class=tok-builtin>@cImport</span></span></code>. </p> <p> This appends <code>#define $name $value</code> to the <code><span class=line><span class=tok-builtin>@cImport</span></span></code> temporary buffer. </p> <p> To define without a value, like this: </p> <pre><code class=c>#define _GNU_SOURCE</code></pre> <p> Use the void value, like this: </p> <pre><code><span class=line><span class=tok-builtin>@cDefine</span>(<span class=tok-str>"_GNU_SOURCE"</span>, {})</span></code></pre> <p>See also:</p><ul> <li><a href=#Import-from-C-Header-File>Import from C Header File</a></li> <li><a href=#cInclude>@cInclude</a></li> <li><a href=#cImport>@cImport</a></li> <li><a href=#cUndef>@cUndef</a></li> <li><a href=#void>void</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40cImport class=dashAnchor></a><h3 id=cImport>@cImport</h3> <pre><code><span class=line><span class=tok-builtin>@cImport</span>(expression) <span class=tok-type>type</span></span></code></pre> <p> This function parses C code and imports the functions, types, variables, and compatible macro definitions into a new empty struct type, and then returns that type. </p> <p> <code><span class=line>expression</span></code> is interpreted at compile time. The builtin functions <code><span class=line><span class=tok-builtin>@cInclude</span></span></code>, <code><span class=line><span class=tok-builtin>@cDefine</span></span></code>, and <code><span class=line><span class=tok-builtin>@cUndef</span></span></code> work within this expression, appending to a temporary buffer which is then parsed as C code. </p> <p> Usually you should only have one <code><span class=line><span class=tok-builtin>@cImport</span></span></code> in your entire application, because it saves the compiler from invoking clang multiple times, and prevents inline functions from being duplicated. </p> <p> Reasons for having multiple <code><span class=line><span class=tok-builtin>@cImport</span></span></code> expressions would be: </p> <ul> <li>To avoid a symbol collision, for example if foo.h and bar.h both <code>#define CONNECTION_COUNT</code></li> <li>To analyze the C code with different preprocessor defines</li> </ul> <p>See also:</p><ul> <li><a href=#Import-from-C-Header-File>Import from C Header File</a></li> <li><a href=#cInclude>@cInclude</a></li> <li><a href=#cDefine>@cDefine</a></li> <li><a href=#cUndef>@cUndef</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40cInclude class=dashAnchor></a><h3 id=cInclude>@cInclude</h3> <pre><code><span class=line><span class=tok-builtin>@cInclude</span>(<span class=tok-kw>comptime</span> path: []<span class=tok-type>u8</span>)</span></code></pre> <p> This function can only occur inside <code><span class=line><span class=tok-builtin>@cImport</span></span></code>. </p> <p> This appends <code>#include &lt;$path&gt;\n</code> to the <code><span class=line>c_import</span></code> temporary buffer. </p> <p>See also:</p><ul> <li><a href=#Import-from-C-Header-File>Import from C Header File</a></li> <li><a href=#cImport>@cImport</a></li> <li><a href=#cDefine>@cDefine</a></li> <li><a href=#cUndef>@cUndef</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40clz class=dashAnchor></a><h3 id=clz>@clz</h3> <pre><code><span class=line><span class=tok-builtin>@clz</span>(operand: <span class=tok-kw>anytype</span>)</span></code></pre> <p><code><span class=line><span class=tok-builtin>@TypeOf</span>(operand)</span></code> must be an integer type or an integer vector type.</p> <p><code><span class=line>operand</span></code> may be an <a href=#Integers>integer</a> or <a href=#Vectors>vector</a>.</p> <p> This function counts the number of most-significant (leading in a big-Endian sense) zeroes in an integer. </p> <p> If <code><span class=line>operand</span></code> is a <a href=#comptime>comptime</a>-known integer, the return type is <code><span class=line><span class=tok-type>comptime_int</span></span></code>. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type. </p> <p> If <code><span class=line>operand</span></code> is zero, <code><span class=line><span class=tok-builtin>@clz</span></span></code> returns the bit width of integer type <code><span class=line>T</span></code>. </p> <p>See also:</p><ul> <li><a href=#ctz>@ctz</a></li> <li><a href=#popCount>@popCount</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40cmpxchgStrong class=dashAnchor></a><h3 id=cmpxchgStrong>@cmpxchgStrong</h3> <pre><code><span class=line><span class=tok-builtin>@cmpxchgStrong</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T</span></code></pre> <p> This function performs a strong atomic compare exchange operation. It's the equivalent of this code, except atomic: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>cmpxchgStrongButNotAtomic</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, ptr: *T, expected_value: T, new_value: T) ?T {</span>
<span class=line>    <span class=tok-kw>const</span> old_value = ptr.*;</span>
<span class=line>    <span class=tok-kw>if</span> (old_value == expected_value) {</span>
<span class=line>        ptr.* = new_value;</span>
<span class=line>        <span class=tok-kw>return</span> <span class=tok-null>null</span>;</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        <span class=tok-kw>return</span> old_value;</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure> <p> If you are using cmpxchg in a loop, <a href=#cmpxchgWeak>@cmpxchgWeak</a> is the better choice, because it can be implemented more efficiently in machine instructions. </p> <p> <code><span class=line>T</span></code> must be a pointer, a <code><span class=line><span class=tok-type>bool</span></span></code>, a float, an integer or an enum. </p> <p><code><span class=line><span class=tok-builtin>@typeInfo</span>(<span class=tok-builtin>@TypeOf</span>(ptr)).Pointer.alignment</span></code> must be <code><span class=line>&gt;= <span class=tok-builtin>@sizeOf</span>(T).</span></code></p> <p>See also:</p><ul> <li><a href=#atomicStore>@atomicStore</a></li> <li><a href=#atomicLoad>@atomicLoad</a></li> <li><a href=#atomicRmw>@atomicRmw</a></li> <li><a href=#fence>@fence</a></li> <li><a href=#cmpxchgWeak>@cmpxchgWeak</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40cmpxchgWeak class=dashAnchor></a><h3 id=cmpxchgWeak>@cmpxchgWeak</h3> <pre><code><span class=line><span class=tok-builtin>@cmpxchgWeak</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T</span></code></pre> <p> This function performs a weak atomic compare exchange operation. It's the equivalent of this code, except atomic: </p> <figure><figcaption class=zig-cap><cite class=file>cmpxchgWeakButNotAtomic</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>cmpxchgWeakButNotAtomic</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, ptr: *T, expected_value: T, new_value: T) ?T {</span>
<span class=line>    <span class=tok-kw>const</span> old_value = ptr.*;</span>
<span class=line>    <span class=tok-kw>if</span> (old_value == expected_value <span class=tok-kw>and</span> usuallyTrueButSometimesFalse()) {</span>
<span class=line>        ptr.* = new_value;</span>
<span class=line>        <span class=tok-kw>return</span> <span class=tok-null>null</span>;</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        <span class=tok-kw>return</span> old_value;</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure> <p> If you are using cmpxchg in a loop, the sporadic failure will be no problem, and <code><span class=line>cmpxchgWeak</span></code> is the better choice, because it can be implemented more efficiently in machine instructions. However if you need a stronger guarantee, use <a href=#cmpxchgStrong>@cmpxchgStrong</a>. </p> <p> <code><span class=line>T</span></code> must be a pointer, a <code><span class=line><span class=tok-type>bool</span></span></code>, a float, an integer or an enum. </p> <p><code><span class=line><span class=tok-builtin>@typeInfo</span>(<span class=tok-builtin>@TypeOf</span>(ptr)).Pointer.alignment</span></code> must be <code><span class=line>&gt;= <span class=tok-builtin>@sizeOf</span>(T).</span></code></p> <p>See also:</p><ul> <li><a href=#atomicStore>@atomicStore</a></li> <li><a href=#atomicLoad>@atomicLoad</a></li> <li><a href=#atomicRmw>@atomicRmw</a></li> <li><a href=#fence>@fence</a></li> <li><a href=#cmpxchgStrong>@cmpxchgStrong</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40compileError class=dashAnchor></a><h3 id=compileError>@compileError</h3> <pre><code><span class=line><span class=tok-builtin>@compileError</span>(<span class=tok-kw>comptime</span> msg: []<span class=tok-type>u8</span>)</span></code></pre> <p> This function, when semantically analyzed, causes a compile error with the message <code><span class=line>msg</span></code>. </p> <p> There are several ways that code avoids being semantically checked, such as using <code><span class=line><span class=tok-kw>if</span></span></code> or <code><span class=line><span class=tok-kw>switch</span></span></code> with compile time constants, and <code><span class=line><span class=tok-kw>comptime</span></span></code> functions. </p> <a name=//apple_ref/cpp/Builtin/%40compileLog class=dashAnchor></a><h3 id=compileLog>@compileLog</h3> <pre><code><span class=line><span class=tok-builtin>@compileLog</span>(args: ...)</span></code></pre> <p> This function prints the arguments passed to it at compile-time. </p> <p> To prevent accidentally leaving compile log statements in a codebase, a compilation error is added to the build, pointing to the compile log statement. This error prevents code from being generated, but does not otherwise interfere with analysis. </p> <p> This function can be used to do "printf debugging" on compile-time executing code. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> num1 = blk: {</span>
<span class=line>    <span class=tok-kw>var</span> val1: <span class=tok-type>i32</span> = <span class=tok-number>99</span>;</span>
<span class=line>    <span class=tok-builtin>@compileLog</span>(<span class=tok-str>"comptime val1 = "</span>, val1);</span>
<span class=line>    val1 = val1 + <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>break</span> :blk val1;</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"main"</span> {</span>
<span class=line>    <span class=tok-builtin>@compileLog</span>(<span class=tok-str>"comptime in main"</span>);</span>
<span class=line></span>
<span class=line>    print(<span class=tok-str>"Runtime in main, num1 = {}.\n"</span>, .{num1});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:11:5: </span><span class=t31_1>error: </span><span class=t1_0>found compile log statement</span>
<span class=line></span>    @compileLog("comptime in main");</span>
<span class=line>    <span class=t32_1>^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:5:5: </span><span class=t36_1>note: </span><span class=t1_0>also here</span>
<span class=line></span>    @compileLog("comptime val1 = ", val1);</span>
<span class=line>    <span class=t32_1>^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class=line></span></span>
<span class=line>Compile Log Output:</span>
<span class=line>@as(*const [16:0]u8, "comptime in main")</span>
<span class=line>@as(*const [16:0]u8, "comptime val1 = "), @as(i32, 99)</span>
</samp></pre></figure> <p> If all <code><span class=line><span class=tok-builtin>@compileLog</span></span></code> calls are removed or not encountered by analysis, the program compiles successfully and the generated executable prints: </p> <figure><figcaption class=zig-cap><cite class=file>without_compileLog.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> num1 = blk: {</span>
<span class=line>    <span class=tok-kw>var</span> val1: <span class=tok-type>i32</span> = <span class=tok-number>99</span>;</span>
<span class=line>    val1 = val1 + <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>break</span> :blk val1;</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"main"</span> {</span>
<span class=line>    print(<span class=tok-str>"Runtime in main, num1 = {}.\n"</span>, .{num1});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test without_compileLog.zig</kbd></span>
<span class=line>1/1 test.main... Runtime in main, num1 = 100.</span>
<span class=line>OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Builtin/%40ctz class=dashAnchor></a><h3 id=ctz>@ctz</h3> <pre><code><span class=line><span class=tok-builtin>@ctz</span>(operand: <span class=tok-kw>anytype</span>)</span></code></pre> <p><code><span class=line><span class=tok-builtin>@TypeOf</span>(operand)</span></code> must be an integer type or an integer vector type.</p> <p><code><span class=line>operand</span></code> may be an <a href=#Integers>integer</a> or <a href=#Vectors>vector</a>.</p> <p> This function counts the number of least-significant (trailing in a big-Endian sense) zeroes in an integer. </p> <p> If <code><span class=line>operand</span></code> is a <a href=#comptime>comptime</a>-known integer, the return type is <code><span class=line><span class=tok-type>comptime_int</span></span></code>. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type. </p> <p> If <code><span class=line>operand</span></code> is zero, <code><span class=line><span class=tok-builtin>@ctz</span></span></code> returns the bit width of integer type <code><span class=line>T</span></code>. </p> <p>See also:</p><ul> <li><a href=#clz>@clz</a></li> <li><a href=#popCount>@popCount</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40cUndef class=dashAnchor></a><h3 id=cUndef>@cUndef</h3> <pre><code><span class=line><span class=tok-builtin>@cUndef</span>(<span class=tok-kw>comptime</span> name: []<span class=tok-type>u8</span>)</span></code></pre> <p> This function can only occur inside <code><span class=line><span class=tok-builtin>@cImport</span></span></code>. </p> <p> This appends <code>#undef $name</code> to the <code><span class=line><span class=tok-builtin>@cImport</span></span></code> temporary buffer. </p> <p>See also:</p><ul> <li><a href=#Import-from-C-Header-File>Import from C Header File</a></li> <li><a href=#cImport>@cImport</a></li> <li><a href=#cDefine>@cDefine</a></li> <li><a href=#cInclude>@cInclude</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40divExact class=dashAnchor></a><h3 id=divExact>@divExact</h3> <pre><code><span class=line><span class=tok-builtin>@divExact</span>(numerator: T, denominator: T) T</span></code></pre> <p> Exact division. Caller guarantees <code><span class=line>denominator != <span class=tok-number>0</span></span></code> and <code><span class=line><span class=tok-builtin>@divTrunc</span>(numerator, denominator) * denominator == numerator</span></code>. </p> <ul> <li><code><span class=line><span class=tok-builtin>@divExact</span>(<span class=tok-number>6</span>, <span class=tok-number>3</span>) == <span class=tok-number>2</span></span></code></li> <li><code><span class=line><span class=tok-builtin>@divExact</span>(a, b) * b == a</span></code></li> </ul> <p>For a function that returns a possible error code, use <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.divExact</span></code>.</p> <p>See also:</p><ul> <li><a href=#divTrunc>@divTrunc</a></li> <li><a href=#divFloor>@divFloor</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40divFloor class=dashAnchor></a><h3 id=divFloor>@divFloor</h3> <pre><code><span class=line><span class=tok-builtin>@divFloor</span>(numerator: T, denominator: T) T</span></code></pre> <p> Floored division. Rounds toward negative infinity. For unsigned integers it is the same as <code><span class=line>numerator / denominator</span></code>. Caller guarantees <code><span class=line>denominator != <span class=tok-number>0</span></span></code> and <code><span class=line>!(<span class=tok-builtin>@typeInfo</span>(T) == .Int <span class=tok-kw>and</span> T.is_signed <span class=tok-kw>and</span> numerator == std.math.minInt(T) <span class=tok-kw>and</span> denominator == -<span class=tok-number>1</span>)</span></code>. </p> <ul> <li><code><span class=line><span class=tok-builtin>@divFloor</span>(-<span class=tok-number>5</span>, <span class=tok-number>3</span>) == -<span class=tok-number>2</span></span></code></li> <li><code><span class=line>(<span class=tok-builtin>@divFloor</span>(a, b) * b) + <span class=tok-builtin>@mod</span>(a, b) == a</span></code></li> </ul> <p>For a function that returns a possible error code, use <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.divFloor</span></code>.</p> <p>See also:</p><ul> <li><a href=#divTrunc>@divTrunc</a></li> <li><a href=#divExact>@divExact</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40divTrunc class=dashAnchor></a><h3 id=divTrunc>@divTrunc</h3> <pre><code><span class=line><span class=tok-builtin>@divTrunc</span>(numerator: T, denominator: T) T</span></code></pre> <p> Truncated division. Rounds toward zero. For unsigned integers it is the same as <code><span class=line>numerator / denominator</span></code>. Caller guarantees <code><span class=line>denominator != <span class=tok-number>0</span></span></code> and <code><span class=line>!(<span class=tok-builtin>@typeInfo</span>(T) == .Int <span class=tok-kw>and</span> T.is_signed <span class=tok-kw>and</span> numerator == std.math.minInt(T) <span class=tok-kw>and</span> denominator == -<span class=tok-number>1</span>)</span></code>. </p> <ul> <li><code><span class=line><span class=tok-builtin>@divTrunc</span>(-<span class=tok-number>5</span>, <span class=tok-number>3</span>) == -<span class=tok-number>1</span></span></code></li> <li><code><span class=line>(<span class=tok-builtin>@divTrunc</span>(a, b) * b) + <span class=tok-builtin>@rem</span>(a, b) == a</span></code></li> </ul> <p>For a function that returns a possible error code, use <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.divTrunc</span></code>.</p> <p>See also:</p><ul> <li><a href=#divFloor>@divFloor</a></li> <li><a href=#divExact>@divExact</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40embedFile class=dashAnchor></a><h3 id=embedFile>@embedFile</h3> <pre><code><span class=line><span class=tok-builtin>@embedFile</span>(<span class=tok-kw>comptime</span> path: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) *<span class=tok-kw>const</span> [N:<span class=tok-number>0</span>]<span class=tok-type>u8</span></span></code></pre> <p> This function returns a compile time constant pointer to null-terminated, fixed-size array with length equal to the byte count of the file given by <code><span class=line>path</span></code>. The contents of the array are the contents of the file. This is equivalent to a <a href=#String-Literals-and-Unicode-Code-Point-Literals>string literal</a> with the file contents. </p> <p> <code><span class=line>path</span></code> is absolute or relative to the current file, just like <code><span class=line><span class=tok-builtin>@import</span></span></code>. </p> <p>See also:</p><ul> <li><a href=#import>@import</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40enumToInt class=dashAnchor></a><h3 id=enumToInt>@enumToInt</h3> <pre><code><span class=line><span class=tok-builtin>@enumToInt</span>(enum_or_tagged_union: <span class=tok-kw>anytype</span>) <span class=tok-kw>anytype</span></span></code></pre> <p> Converts an enumeration value into its integer tag type. When a tagged union is passed, the tag value is used as the enumeration value. </p> <p> If there is only one possible enum value, the result is a <code><span class=line><span class=tok-type>comptime_int</span></span></code> known at <a href=#comptime>comptime</a>. </p> <p>See also:</p><ul> <li><a href=#intToEnum>@intToEnum</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40errorName class=dashAnchor></a><h3 id=errorName>@errorName</h3> <pre><code><span class=line><span class=tok-builtin>@errorName</span>(err: <span class=tok-type>anyerror</span>) [:<span class=tok-number>0</span>]<span class=tok-kw>const</span> <span class=tok-type>u8</span></span></code></pre> <p> This function returns the string representation of an error. The string representation of <code><span class=line><span class=tok-kw>error</span>.OutOfMem</span></code> is <code><span class=line><span class=tok-str>"OutOfMem"</span></span></code>. </p> <p> If there are no calls to <code><span class=line><span class=tok-builtin>@errorName</span></span></code> in an entire application, or all calls have a compile-time known value for <code><span class=line>err</span></code>, then no error name table will be generated. </p> <a name=//apple_ref/cpp/Builtin/%40errorReturnTrace class=dashAnchor></a><h3 id=errorReturnTrace>@errorReturnTrace</h3> <pre><code><span class=line><span class=tok-builtin>@errorReturnTrace</span>() ?*builtin.StackTrace</span></code></pre> <p> If the binary is built with error return tracing, and this function is invoked in a function that calls a function with an error or error union return type, returns a stack trace object. Otherwise returns <a href=#null>null</a>. </p> <a name=//apple_ref/cpp/Builtin/%40errorToInt class=dashAnchor></a><h3 id=errorToInt>@errorToInt</h3> <pre><code><span class=line><span class=tok-builtin>@errorToInt</span>(err: <span class=tok-kw>anytype</span>) std.meta.Int(.unsigned, <span class=tok-builtin>@sizeOf</span>(<span class=tok-type>anyerror</span>) * <span class=tok-number>8</span>)</span></code></pre> <p> Supports the following types: </p> <ul> <li><a href=#The-Global-Error-Set>The Global Error Set</a></li> <li><a href=#Error-Set-Type>Error Set Type</a></li> <li><a href=#Error-Union-Type>Error Union Type</a></li> </ul> <p> Converts an error to the integer representation of an error. </p> <p> It is generally recommended to avoid this cast, as the integer representation of an error is not stable across source code changes. </p> <p>See also:</p><ul> <li><a href=#intToError>@intToError</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40errSetCast class=dashAnchor></a><h3 id=errSetCast>@errSetCast</h3> <pre><code><span class=line><span class=tok-builtin>@errSetCast</span>(<span class=tok-kw>comptime</span> T: DestType, value: <span class=tok-kw>anytype</span>) DestType</span></code></pre> <p> Converts an error value from one error set to another error set. Attempting to convert an error which is not in the destination error set results in safety-protected <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <a name=//apple_ref/cpp/Builtin/%40export class=dashAnchor></a><h3 id=export>@export</h3> <pre><code><span class=line><span class=tok-builtin>@export</span>(declaration, <span class=tok-kw>comptime</span> options: std.builtin.ExportOptions) <span class=tok-type>void</span></span></code></pre> <p> Creates a symbol in the output object file. </p> <p> <code>declaration</code> must be one of two things: </p> <ul> <li>An identifier (<code><span class=line>x</span></code>) identifying a <a href=#Functions>function</a> or a <a href=#Container-Level-Variables>variable</a>.</li> <li>Field access (<code><span class=line>x.y</span></code>) looking up a <a href=#Functions>function</a> or a <a href=#Container-Level-Variables>variable</a>.</li> </ul> <p> This builtin can be called from a <a href=#comptime>comptime</a> block to conditionally export symbols. When <code>declaration</code> is a function with the C calling convention and <code><span class=line>options.linkage</span></code> is <code><span class=line>Strong</span></code>, this is equivalent to the <code><span class=line><span class=tok-kw>export</span></span></code> keyword used on a function: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-builtin>@export</span>(internalName, .{ .name = <span class=tok-str>"foo"</span>, .linkage = .Strong });</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>internalName</span>() <span class=tok-kw>callconv</span>(.C) <span class=tok-type>void</span> {}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-obj test.zig</kbd></span>
</samp></pre></figure> <p>This is equivalent to:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>foo</span>() <span class=tok-type>void</span> {}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-obj test.zig</kbd></span>
</samp></pre></figure> <p>Note that even when using <code><span class=line><span class=tok-kw>export</span></span></code>, the <code><span class=line>@"foo"</span></code> syntax for <a href=#Identifiers>identifiers</a> can be used to choose any string for the symbol name:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>@"A function name that is a complete sentence."</span>() <span class=tok-type>void</span> {}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-obj test.zig</kbd></span>
</samp></pre></figure> <p> When looking at the resulting object, you can see the symbol is used verbatim: </p> <pre><code>00000000000001f0 T A function name that is a complete sentence.</code></pre> <p>See also:</p><ul> <li><a href=#Exporting-a-C-Library>Exporting a C Library</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40extern class=dashAnchor></a><h3 id=extern>@extern</h3> <pre><code><span class=line><span class=tok-builtin>@extern</span>(T: <span class=tok-type>type</span>, <span class=tok-kw>comptime</span> options: std.builtin.ExternOptions) *T</span></code></pre> <p> Creates a reference to an external symbol in the output object file. </p> <p>See also:</p><ul> <li><a href=#export>@export</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40fence class=dashAnchor></a><h3 id=fence>@fence</h3> <pre><code><span class=line><span class=tok-builtin>@fence</span>(order: AtomicOrder)</span></code></pre> <p> The <code><span class=line>fence</span></code> function is used to introduce happens-before edges between operations. </p> <p> <code><span class=line>AtomicOrder</span></code> can be found with <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).builtin.AtomicOrder</span></code>. </p> <p>See also:</p><ul> <li><a href=#atomicStore>@atomicStore</a></li> <li><a href=#atomicLoad>@atomicLoad</a></li> <li><a href=#atomicRmw>@atomicRmw</a></li> <li><a href=#cmpxchgWeak>@cmpxchgWeak</a></li> <li><a href=#cmpxchgStrong>@cmpxchgStrong</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40field class=dashAnchor></a><h3 id=field>@field</h3> <pre><code><span class=line><span class=tok-builtin>@field</span>(lhs: <span class=tok-kw>anytype</span>, <span class=tok-kw>comptime</span> field_name: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) (field)</span></code></pre> <p>Performs field access by a compile-time string. Works on both fields and declarations. </p> <figure><figcaption class=zig-cap><cite class=file>field_decl_access_by_string.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Point = <span class=tok-kw>struct</span> {</span>
<span class=line>    x: <span class=tok-type>u32</span>,</span>
<span class=line>    y: <span class=tok-type>u32</span>,</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>var</span> z: <span class=tok-type>u32</span> = <span class=tok-number>1</span>;</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"field access by string"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line>    <span class=tok-kw>var</span> p = Point{ .x = <span class=tok-number>0</span>, .y = <span class=tok-number>0</span> };</span>
<span class=line></span>
<span class=line>    <span class=tok-builtin>@field</span>(p, <span class=tok-str>"x"</span>) = <span class=tok-number>4</span>;</span>
<span class=line>    <span class=tok-builtin>@field</span>(p, <span class=tok-str>"y"</span>) = <span class=tok-builtin>@field</span>(p, <span class=tok-str>"x"</span>) + <span class=tok-number>1</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@field</span>(p, <span class=tok-str>"x"</span>) == <span class=tok-number>4</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@field</span>(p, <span class=tok-str>"y"</span>) == <span class=tok-number>5</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"decl access by string"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@field</span>(Point, <span class=tok-str>"z"</span>) == <span class=tok-number>1</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-builtin>@field</span>(Point, <span class=tok-str>"z"</span>) = <span class=tok-number>2</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@field</span>(Point, <span class=tok-str>"z"</span>) == <span class=tok-number>2</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test field_decl_access_by_string.zig</kbd></span>
<span class=line>1/2 test.field access by string... OK</span>
<span class=line>2/2 test.decl access by string... OK</span>
<span class=line>All 2 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Builtin/%40fieldParentPtr class=dashAnchor></a><h3 id=fieldParentPtr>@fieldParentPtr</h3> <pre><code><span class=line><span class=tok-builtin>@fieldParentPtr</span>(<span class=tok-kw>comptime</span> ParentType: <span class=tok-type>type</span>, <span class=tok-kw>comptime</span> field_name: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>,</span>
<span class=line>    field_ptr: *T) *ParentType</span></code></pre> <p> Given a pointer to a field, returns the base pointer of a struct. </p> <a name=//apple_ref/cpp/Builtin/%40floatCast class=dashAnchor></a><h3 id=floatCast>@floatCast</h3> <pre><code><span class=line><span class=tok-builtin>@floatCast</span>(<span class=tok-kw>comptime</span> DestType: <span class=tok-type>type</span>, value: <span class=tok-kw>anytype</span>) DestType</span></code></pre> <p> Convert from one float type to another. This cast is safe, but may cause the numeric value to lose precision. </p> <a name=//apple_ref/cpp/Builtin/%40floatToInt class=dashAnchor></a><h3 id=floatToInt>@floatToInt</h3> <pre><code><span class=line><span class=tok-builtin>@floatToInt</span>(<span class=tok-kw>comptime</span> DestType: <span class=tok-type>type</span>, float: <span class=tok-kw>anytype</span>) DestType</span></code></pre> <p> Converts the integer part of a floating point number to the destination type. </p> <p> If the integer part of the floating point number cannot fit in the destination type, it invokes safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <p>See also:</p><ul> <li><a href=#intToFloat>@intToFloat</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40frame class=dashAnchor></a><h3 id=frame>@frame</h3> <pre><code><span class=line><span class=tok-builtin>@frame</span>() *<span class=tok-builtin>@Frame</span>(func)</span></code></pre> <p> This function returns a pointer to the frame for a given function. This type can be <a href=#Type-Coercion>coerced</a> to <code><span class=line><span class=tok-kw>anyframe</span>-&gt;T</span></code> and to <code><span class=line><span class=tok-kw>anyframe</span></span></code>, where <code><span class=line>T</span></code> is the return type of the function in scope. </p> <p> This function does not mark a suspension point, but it does cause the function in scope to become an <a href=#Async-Functions>async function</a>. </p> <a name=//apple_ref/cpp/Builtin/%40Frame class=dashAnchor></a><h3 id=Frame>@Frame</h3> <pre><code><span class=line><span class=tok-builtin>@Frame</span>(func: <span class=tok-kw>anytype</span>) <span class=tok-type>type</span></span></code></pre> <p> This function returns the frame type of a function. This works for <a href=#Async-Functions>Async Functions</a> as well as any function without a specific calling convention. </p> <p> This type is suitable to be used as the return type of <a href=#Async-and-Await>async</a> which allows one to, for example, heap-allocate an async function frame: </p> <figure><figcaption class=zig-cap><cite class=file>heap_allocated_frame.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"heap allocated frame"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> frame = <span class=tok-kw>try</span> std.heap.page_allocator.create(<span class=tok-builtin>@Frame</span>(func));</span>
<span class=line>    frame.* = <span class=tok-kw>async</span> func();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>func</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>suspend</span> {}</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test heap_allocated_frame.zig -fstage1</kbd></span>
<span class=line>1/1 test "heap allocated frame"... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Builtin/%40frameAddress class=dashAnchor></a><h3 id=frameAddress>@frameAddress</h3> <pre><code><span class=line><span class=tok-builtin>@frameAddress</span>() <span class=tok-type>usize</span></span></code></pre> <p> This function returns the base pointer of the current stack frame. </p> <p> The implications of this are target-specific and not consistent across all platforms. The frame address may not be available in release mode due to aggressive optimizations. </p> <p> This function is only valid within function scope. </p> <a name=//apple_ref/cpp/Builtin/%40frameSize class=dashAnchor></a><h3 id=frameSize>@frameSize</h3> <pre><code><span class=line><span class=tok-builtin>@frameSize</span>(func: <span class=tok-kw>anytype</span>) <span class=tok-type>usize</span></span></code></pre> <p> This is the same as <code><span class=line><span class=tok-builtin>@sizeOf</span>(<span class=tok-builtin>@Frame</span>(func))</span></code>, where <code><span class=line>func</span></code> may be runtime-known. </p> <p> This function is typically used in conjunction with <a href=#asyncCall>@asyncCall</a>. </p> <a name=//apple_ref/cpp/Builtin/%40hasDecl class=dashAnchor></a><h3 id=hasDecl>@hasDecl</h3> <pre><code><span class=line><span class=tok-builtin>@hasDecl</span>(<span class=tok-kw>comptime</span> Container: <span class=tok-type>type</span>, <span class=tok-kw>comptime</span> name: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) <span class=tok-type>bool</span></span></code></pre> <p> Returns whether or not a <a href=#struct>struct</a>, <a href=#enum>enum</a>, or <a href=#union>union</a> has a declaration matching <code><span class=line>name</span></code>. </p> <figure><figcaption class=zig-cap><cite class=file>hasDecl.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>struct</span> {</span>
<span class=line>    nope: <span class=tok-type>i32</span>,</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>var</span> blah = <span class=tok-str>"xxx"</span>;</span>
<span class=line>    <span class=tok-kw>const</span> hi = <span class=tok-number>1</span>;</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"@hasDecl"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@hasDecl</span>(Foo, <span class=tok-str>"blah"</span>));</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Even though `hi` is private, @hasDecl returns true because this test is</span></span>
<span class=line>    <span class=tok-comment>// in the same file scope as Foo. It would return false if Foo was declared</span></span>
<span class=line>    <span class=tok-comment>// in a different file.</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(<span class=tok-builtin>@hasDecl</span>(Foo, <span class=tok-str>"hi"</span>));</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// @hasDecl is for declarations; not fields.</span></span>
<span class=line>    <span class=tok-kw>try</span> expect(!<span class=tok-builtin>@hasDecl</span>(Foo, <span class=tok-str>"nope"</span>));</span>
<span class=line>    <span class=tok-kw>try</span> expect(!<span class=tok-builtin>@hasDecl</span>(Foo, <span class=tok-str>"nope1234"</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test hasDecl.zig</kbd></span>
<span class=line>1/1 test.@hasDecl... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#hasField>@hasField</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40hasField class=dashAnchor></a><h3 id=hasField>@hasField</h3> <pre><code><span class=line><span class=tok-builtin>@hasField</span>(<span class=tok-kw>comptime</span> Container: <span class=tok-type>type</span>, <span class=tok-kw>comptime</span> name: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) <span class=tok-type>bool</span></span></code></pre> <p>Returns whether the field name of a struct, union, or enum exists.</p> <p> The result is a compile time constant. </p> <p> It does not include functions, variables, or constants. </p> <p>See also:</p><ul> <li><a href=#hasDecl>@hasDecl</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40import class=dashAnchor></a><h3 id=import>@import</h3> <pre><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-kw>comptime</span> path: []<span class=tok-type>u8</span>) <span class=tok-type>type</span></span></code></pre> <p> This function finds a zig file corresponding to <code><span class=line>path</span></code> and adds it to the build, if it is not already added. </p> <p> Zig source files are implicitly structs, with a name equal to the file's basename with the extension truncated. <code><span class=line><span class=tok-builtin>@import</span></span></code> returns the struct type corresponding to the file. </p> <p> Declarations which have the <code><span class=line><span class=tok-kw>pub</span></span></code> keyword may be referenced from a different source file than the one they are declared in. </p> <p> <code><span class=line>path</span></code> can be a relative path or it can be the name of a package. If it is a relative path, it is relative to the file that contains the <code><span class=line><span class=tok-builtin>@import</span></span></code> function call. </p> <p> The following packages are always available: </p> <ul> <li><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>)</span></code> - Zig Standard Library</li> <li><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>)</span></code> - Target-specific information. The command <code>zig build-exe --show-builtin</code> outputs the source to stdout for reference. </li> <li><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"root"</span>)</span></code> - Points to the root source file. This is usually <code>src/main.zig</code> but it depends on what file is chosen to be built. </li> </ul> <p>See also:</p><ul> <li><a href=#Compile-Variables>Compile Variables</a></li> <li><a href=#embedFile>@embedFile</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40intCast class=dashAnchor></a><h3 id=intCast>@intCast</h3> <pre><code><span class=line><span class=tok-builtin>@intCast</span>(<span class=tok-kw>comptime</span> DestType: <span class=tok-type>type</span>, int: <span class=tok-kw>anytype</span>) DestType</span></code></pre> <p> Converts an integer to another integer while keeping the same numerical value. Attempting to convert a number which is out of range of the destination type results in safety-protected <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"integer cast panic"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u16</span> = <span class=tok-number>0xabcd</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>u8</span> = <span class=tok-builtin>@intCast</span>(<span class=tok-type>u8</span>, a);</span>
<span class=line>    _ = b;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.integer cast panic... thread 1639190 panic: integer cast truncated bits</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:3:5</span>: <span class=t2_0>0x211586 in test.integer cast panic (test)</span></span>
<span class=line>    var b: u8 = @intCast(u8, a);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x212b98 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x211e7b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x211941 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>error: the following test command crashed:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <p> To truncate the significant bits of a number out of range of the destination type, use <a href=#truncate>@truncate</a>. </p> <p> If <code><span class=line>T</span></code> is <code><span class=line><span class=tok-type>comptime_int</span></span></code>, then this is semantically equivalent to <a href=#Type-Coercion>Type Coercion</a>. </p> <a name=//apple_ref/cpp/Builtin/%40intToEnum class=dashAnchor></a><h3 id=intToEnum>@intToEnum</h3> <pre><code><span class=line><span class=tok-builtin>@intToEnum</span>(<span class=tok-kw>comptime</span> DestType: <span class=tok-type>type</span>, integer: <span class=tok-kw>anytype</span>) DestType</span></code></pre> <p> Converts an integer into an <a href=#enum>enum</a> value. </p> <p> Attempting to convert an integer which represents no value in the chosen enum type invokes safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <p>See also:</p><ul> <li><a href=#enumToInt>@enumToInt</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40intToError class=dashAnchor></a><h3 id=intToError>@intToError</h3> <pre><code><span class=line><span class=tok-builtin>@intToError</span>(value: std.meta.Int(.unsigned, <span class=tok-builtin>@sizeOf</span>(<span class=tok-type>anyerror</span>) * <span class=tok-number>8</span>)) <span class=tok-type>anyerror</span></span></code></pre> <p> Converts from the integer representation of an error into <a href=#The-Global-Error-Set>The Global Error Set</a> type. </p> <p> It is generally recommended to avoid this cast, as the integer representation of an error is not stable across source code changes. </p> <p> Attempting to convert an integer that does not correspond to any error results in safety-protected <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <p>See also:</p><ul> <li><a href=#errorToInt>@errorToInt</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40intToFloat class=dashAnchor></a><h3 id=intToFloat>@intToFloat</h3> <pre><code><span class=line><span class=tok-builtin>@intToFloat</span>(<span class=tok-kw>comptime</span> DestType: <span class=tok-type>type</span>, int: <span class=tok-kw>anytype</span>) DestType</span></code></pre> <p> Converts an integer to the closest floating point representation. To convert the other way, use <a href=#floatToInt>@floatToInt</a>. This cast is always safe. </p> <a name=//apple_ref/cpp/Builtin/%40intToPtr class=dashAnchor></a><h3 id=intToPtr>@intToPtr</h3> <pre><code><span class=line><span class=tok-builtin>@intToPtr</span>(<span class=tok-kw>comptime</span> DestType: <span class=tok-type>type</span>, address: <span class=tok-type>usize</span>) DestType</span></code></pre> <p> Converts an integer to a <a href=#Pointers>pointer</a>. To convert the other way, use <a href=#ptrToInt>@ptrToInt</a>. Casting an address of 0 to a destination type which in not <a href=#Optional-Pointers>optional</a> and does not have the <code><span class=line><span class=tok-kw>allowzero</span></span></code> attribute will result in a <a href=#Pointer-Cast-Invalid-Null>Pointer Cast Invalid Null</a> panic when runtime safety checks are enabled. </p> <p> If the destination pointer type does not allow address zero and <code><span class=line>address</span></code> is zero, this invokes safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <a name=//apple_ref/cpp/Builtin/%40max class=dashAnchor></a><h3 id=max>@max</h3> <pre><code><span class=line><span class=tok-builtin>@max</span>(a: T, b: T) T</span></code></pre> <p> Returns the maximum value of <code><span class=line>a</span></code> and <code><span class=line>b</span></code>. This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise. </p> <p> NaNs are handled as follows: if one of the operands of a (pairwise) operation is NaN, the other operand is returned. If both operands are NaN, NaN is returned. </p> <p>See also:</p><ul> <li><a href=#min>@min</a></li> <li><a href=#Vectors>Vectors</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40memcpy class=dashAnchor></a><h3 id=memcpy>@memcpy</h3> <pre><code><span class=line><span class=tok-builtin>@memcpy</span>(<span class=tok-kw>noalias</span> dest: [*]<span class=tok-type>u8</span>, <span class=tok-kw>noalias</span> source: [*]<span class=tok-kw>const</span> <span class=tok-type>u8</span>, byte_count: <span class=tok-type>usize</span>)</span></code></pre> <p> This function copies bytes from one region of memory to another. <code><span class=line>dest</span></code> and <code><span class=line>source</span></code> are both pointers and must not overlap. </p> <p> This function is a low level intrinsic with no safety mechanisms. Most code should not use this function, instead using something like this: </p> <pre><code><span class=line><span class=tok-kw>for</span> (source[<span class=tok-number>0</span>..byte_count]) |b, i| dest[i] = b;</span></code></pre> <p> The optimizer is intelligent enough to turn the above snippet into a memcpy. </p> <p>There is also a standard library function for this:</p> <pre><code><span class=line><span class=tok-kw>const</span> mem = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).mem;</span>
<span class=line>mem.copy(<span class=tok-type>u8</span>, dest[<span class=tok-number>0</span>..byte_count], source[<span class=tok-number>0</span>..byte_count]);</span></code></pre> <a name=//apple_ref/cpp/Builtin/%40memset class=dashAnchor></a><h3 id=memset>@memset</h3> <pre><code><span class=line><span class=tok-builtin>@memset</span>(dest: [*]<span class=tok-type>u8</span>, c: <span class=tok-type>u8</span>, byte_count: <span class=tok-type>usize</span>)</span></code></pre> <p> This function sets a region of memory to <code><span class=line>c</span></code>. <code><span class=line>dest</span></code> is a pointer. </p> <p> This function is a low level intrinsic with no safety mechanisms. Most code should not use this function, instead using something like this: </p> <pre><code><span class=line><span class=tok-kw>for</span> (dest[<span class=tok-number>0</span>..byte_count]) |*b| b.* = c;</span></code></pre> <p> The optimizer is intelligent enough to turn the above snippet into a memset. </p> <p>There is also a standard library function for this:</p> <pre><code><span class=line><span class=tok-kw>const</span> mem = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).mem;</span>
<span class=line>mem.set(<span class=tok-type>u8</span>, dest, c);</span></code></pre> <a name=//apple_ref/cpp/Builtin/%40min class=dashAnchor></a><h3 id=min>@min</h3> <pre><code><span class=line><span class=tok-builtin>@min</span>(a: T, b: T) T</span></code></pre> <p> Returns the minimum value of <code><span class=line>a</span></code> and <code><span class=line>b</span></code>. This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise. </p> <p> NaNs are handled as follows: if one of the operands of a (pairwise) operation is NaN, the other operand is returned. If both operands are NaN, NaN is returned. </p> <p>See also:</p><ul> <li><a href=#max>@max</a></li> <li><a href=#Vectors>Vectors</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40wasmMemorySize class=dashAnchor></a><h3 id=wasmMemorySize>@wasmMemorySize</h3> <pre><code><span class=line><span class=tok-builtin>@wasmMemorySize</span>(index: <span class=tok-type>u32</span>) <span class=tok-type>u32</span></span></code></pre> <p> This function returns the size of the Wasm memory identified by <code><span class=line>index</span></code> as an unsigned value in units of Wasm pages. Note that each Wasm page is 64KB in size. </p> <p> This function is a low level intrinsic with no safety mechanisms usually useful for allocator designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use something like <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).heap.WasmPageAllocator</span></code>. </p> <p>See also:</p><ul> <li><a href=#wasmMemoryGrow>@wasmMemoryGrow</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40wasmMemoryGrow class=dashAnchor></a><h3 id=wasmMemoryGrow>@wasmMemoryGrow</h3> <pre><code><span class=line><span class=tok-builtin>@wasmMemoryGrow</span>(index: <span class=tok-type>u32</span>, delta: <span class=tok-type>u32</span>) <span class=tok-type>i32</span></span></code></pre> <p> This function increases the size of the Wasm memory identified by <code><span class=line>index</span></code> by <code><span class=line>delta</span></code> in units of unsigned number of Wasm pages. Note that each Wasm page is 64KB in size. On success, returns previous memory size; on failure, if the allocation fails, returns -1. </p> <p> This function is a low level intrinsic with no safety mechanisms usually useful for allocator designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use something like <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).heap.WasmPageAllocator</span></code>. </p> <figure><figcaption class=zig-cap><cite class=file>wasmMemoryGrow.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> native_arch = <span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>).target.cpu.arch;</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"@wasmMemoryGrow"</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (native_arch != .wasm32) <span class=tok-kw>return</span> <span class=tok-kw>error</span>.SkipZigTest;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> prev = <span class=tok-builtin>@wasmMemorySize</span>(<span class=tok-number>0</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(prev == <span class=tok-builtin>@wasmMemoryGrow</span>(<span class=tok-number>0</span>, <span class=tok-number>1</span>));</span>
<span class=line>    <span class=tok-kw>try</span> expect(prev + <span class=tok-number>1</span> == <span class=tok-builtin>@wasmMemorySize</span>(<span class=tok-number>0</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test wasmMemoryGrow.zig</kbd></span>
<span class=line>1/1 test.@wasmMemoryGrow... SKIP</span>
<span class=line>0 passed; 1 skipped; 0 failed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#wasmMemorySize>@wasmMemorySize</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40mod class=dashAnchor></a><h3 id=mod>@mod</h3> <pre><code><span class=line><span class=tok-builtin>@mod</span>(numerator: T, denominator: T) T</span></code></pre> <p> Modulus division. For unsigned integers this is the same as <code><span class=line>numerator % denominator</span></code>. Caller guarantees <code><span class=line>denominator &gt; <span class=tok-number>0</span></span></code>, otherwise the operation will result in a <a href=#Remainder-Division-by-Zero>Remainder Division by Zero</a> when runtime safety checks are enabled. </p> <ul> <li><code><span class=line><span class=tok-builtin>@mod</span>(-<span class=tok-number>5</span>, <span class=tok-number>3</span>) == <span class=tok-number>1</span></span></code></li> <li><code><span class=line>(<span class=tok-builtin>@divFloor</span>(a, b) * b) + <span class=tok-builtin>@mod</span>(a, b) == a</span></code></li> </ul> <p>For a function that returns an error code, see <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.mod</span></code>.</p> <p>See also:</p><ul> <li><a href=#rem>@rem</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40mulWithOverflow class=dashAnchor></a><h3 id=mulWithOverflow>@mulWithOverflow</h3> <pre><code><span class=line><span class=tok-builtin>@mulWithOverflow</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, b: T, result: *T) <span class=tok-type>bool</span></span></code></pre> <p> Performs <code><span class=line>result.* = a * b</span></code>. If overflow or underflow occurs, stores the overflowed bits in <code><span class=line>result</span></code> and returns <code><span class=line><span class=tok-null>true</span></span></code>. If no overflow or underflow occurs, returns <code><span class=line><span class=tok-null>false</span></span></code>. </p> <a name=//apple_ref/cpp/Builtin/%40panic class=dashAnchor></a><h3 id=panic>@panic</h3> <pre><code><span class=line><span class=tok-builtin>@panic</span>(message: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) <span class=tok-type>noreturn</span></span></code></pre> <p> Invokes the panic handler function. By default the panic handler function calls the public <code><span class=line>panic</span></code> function exposed in the root source file, or if there is not one specified, the <code><span class=line>std.builtin.default_panic</span></code> function from <code><span class=line>std/builtin.zig</span></code>. </p> <p>Generally it is better to use <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.panic</span></code>. However, <code><span class=line><span class=tok-builtin>@panic</span></span></code> can be useful for 2 scenarios: </p> <ul> <li>From library code, calling the programmer's panic function if they exposed one in the root source file.</li> <li>When mixing C and Zig code, calling the canonical panic implementation across multiple .o files.</li> </ul> <p>See also:</p><ul> <li><a href=#Root-Source-File>Root Source File</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40popCount class=dashAnchor></a><h3 id=popCount>@popCount</h3> <pre><code><span class=line><span class=tok-builtin>@popCount</span>(operand: <span class=tok-kw>anytype</span>)</span></code></pre> <p><code><span class=line><span class=tok-builtin>@TypeOf</span>(operand)</span></code> must be an integer type.</p> <p><code><span class=line>operand</span></code> may be an <a href=#Integers>integer</a> or <a href=#Vectors>vector</a>.</p> <p>Counts the number of bits set in an integer.</p> <p> If <code><span class=line>operand</span></code> is a <a href=#comptime>comptime</a>-known integer, the return type is <code><span class=line><span class=tok-type>comptime_int</span></span></code>. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type. </p> <p>See also:</p><ul> <li><a href=#ctz>@ctz</a></li> <li><a href=#clz>@clz</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40prefetch class=dashAnchor></a><h3 id=prefetch>@prefetch</h3> <pre><code><span class=line><span class=tok-builtin>@prefetch</span>(ptr: <span class=tok-kw>anytype</span>, <span class=tok-kw>comptime</span> options: std.builtin.PrefetchOptions)</span></code></pre> <p> This builtin tells the compiler to emit a prefetch instruction if supported by the target CPU. If the target CPU does not support the requested prefetch instruction, this builtin is a no-op. This function has no effect on the behavior of the program, only on the performance characteristics. </p> <p> The <code><span class=line>ptr</span></code> argument may be any pointer type and determines the memory address to prefetch. This function does not dereference the pointer, it is perfectly legal to pass a pointer to invalid memory to this function and no illegal behavior will result. </p> <p> The <code><span class=line>options</span></code> argument is the following struct: </p> <figure><figcaption class=zig-cap><cite class=file>builtin.zig</cite></figcaption><pre><code><span class=line><span class=tok-comment>/// This data structure is used by the Zig language code generation and</span></span>
<span class=line><span class=tok-comment>/// therefore must be kept in sync with the compiler implementation.</span></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> PrefetchOptions = <span class=tok-kw>struct</span> {</span>
<span class=line>    <span class=tok-comment>/// Whether the prefetch should prepare for a read or a write.</span></span>
<span class=line>    rw: Rw = .read,</span>
<span class=line>    <span class=tok-comment>/// 0 means no temporal locality. That is, the data can be immediately</span></span>
<span class=line>    <span class=tok-comment>/// dropped from the cache after it is accessed.</span></span>
<span class=line>    <span class=tok-comment>///</span></span>
<span class=line>    <span class=tok-comment>/// 3 means high temporal locality. That is, the data should be kept in</span></span>
<span class=line>    <span class=tok-comment>/// the cache as it is likely to be accessed again soon.</span></span>
<span class=line>    locality: <span class=tok-type>u2</span> = <span class=tok-number>3</span>,</span>
<span class=line>    <span class=tok-comment>/// The cache that the prefetch should be preformed on.</span></span>
<span class=line>    cache: Cache = .data,</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>const</span> Rw = <span class=tok-kw>enum</span> {</span>
<span class=line>        read,</span>
<span class=line>        write,</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>pub</span> <span class=tok-kw>const</span> Cache = <span class=tok-kw>enum</span> {</span>
<span class=line>        instruction,</span>
<span class=line>        data,</span>
<span class=line>    };</span>
<span class=line>};</span></code></pre></figure> <a name=//apple_ref/cpp/Builtin/%40ptrCast class=dashAnchor></a><h3 id=ptrCast>@ptrCast</h3> <pre><code><span class=line><span class=tok-builtin>@ptrCast</span>(<span class=tok-kw>comptime</span> DestType: <span class=tok-type>type</span>, value: <span class=tok-kw>anytype</span>) DestType</span></code></pre> <p> Converts a pointer of one type to a pointer of another type. </p> <p> <a href=#Optional-Pointers>Optional Pointers</a> are allowed. Casting an optional pointer which is <a href=#null>null</a> to a non-optional pointer invokes safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <a name=//apple_ref/cpp/Builtin/%40ptrToInt class=dashAnchor></a><h3 id=ptrToInt>@ptrToInt</h3> <pre><code><span class=line><span class=tok-builtin>@ptrToInt</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-type>usize</span></span></code></pre> <p> Converts <code><span class=line>value</span></code> to a <code><span class=line><span class=tok-type>usize</span></span></code> which is the address of the pointer. <code><span class=line>value</span></code> can be <code><span class=line>*T</span></code> or <code><span class=line>?*T</span></code>. </p> <p>To convert the other way, use <a href=#intToPtr>@intToPtr</a></p> <a name=//apple_ref/cpp/Builtin/%40rem class=dashAnchor></a><h3 id=rem>@rem</h3> <pre><code><span class=line><span class=tok-builtin>@rem</span>(numerator: T, denominator: T) T</span></code></pre> <p> Remainder division. For unsigned integers this is the same as <code><span class=line>numerator % denominator</span></code>. Caller guarantees <code><span class=line>denominator &gt; <span class=tok-number>0</span></span></code>, otherwise the operation will result in a <a href=#Remainder-Division-by-Zero>Remainder Division by Zero</a> when runtime safety checks are enabled. </p> <ul> <li><code><span class=line><span class=tok-builtin>@rem</span>(-<span class=tok-number>5</span>, <span class=tok-number>3</span>) == -<span class=tok-number>2</span></span></code></li> <li><code><span class=line>(<span class=tok-builtin>@divTrunc</span>(a, b) * b) + <span class=tok-builtin>@rem</span>(a, b) == a</span></code></li> </ul> <p>For a function that returns an error code, see <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.rem</span></code>.</p> <p>See also:</p><ul> <li><a href=#mod>@mod</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40returnAddress class=dashAnchor></a><h3 id=returnAddress>@returnAddress</h3> <pre><code><span class=line><span class=tok-builtin>@returnAddress</span>() <span class=tok-type>usize</span></span></code></pre> <p> This function returns the address of the next machine code instruction that will be executed when the current function returns. </p> <p> The implications of this are target-specific and not consistent across all platforms. </p> <p> This function is only valid within function scope. If the function gets inlined into a calling function, the returned address will apply to the calling function. </p> <a name=//apple_ref/cpp/Builtin/%40select class=dashAnchor></a><h3 id=select>@select</h3> <pre><code><span class=line><span class=tok-builtin>@select</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, pred: <span class=tok-builtin>@Vector</span>(len, <span class=tok-type>bool</span>), a: <span class=tok-builtin>@Vector</span>(len, T), b: <span class=tok-builtin>@Vector</span>(len, T)) <span class=tok-builtin>@Vector</span>(len, T)</span></code></pre> <p> Selects values element-wise from <code><span class=line>a</span></code> or <code><span class=line>b</span></code> based on <code><span class=line>pred</span></code>. If <code><span class=line>pred[i]</span></code> is <code><span class=line><span class=tok-null>true</span></span></code>, the corresponding element in the result will be <code><span class=line>a[i]</span></code> and otherwise <code><span class=line>b[i]</span></code>. </p> <p>See also:</p><ul> <li><a href=#Vectors>Vectors</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40setAlignStack class=dashAnchor></a><h3 id=setAlignStack>@setAlignStack</h3> <pre><code><span class=line><span class=tok-builtin>@setAlignStack</span>(<span class=tok-kw>comptime</span> alignment: <span class=tok-type>u29</span>)</span></code></pre> <p> Ensures that a function will have a stack alignment of at least <code><span class=line>alignment</span></code> bytes. </p> <a name=//apple_ref/cpp/Builtin/%40setCold class=dashAnchor></a><h3 id=setCold>@setCold</h3> <pre><code><span class=line><span class=tok-builtin>@setCold</span>(<span class=tok-kw>comptime</span> is_cold: <span class=tok-type>bool</span>)</span></code></pre> <p> Tells the optimizer that a function is rarely called. </p> <a name=//apple_ref/cpp/Builtin/%40setEvalBranchQuota class=dashAnchor></a><h3 id=setEvalBranchQuota>@setEvalBranchQuota</h3> <pre><code><span class=line><span class=tok-builtin>@setEvalBranchQuota</span>(<span class=tok-kw>comptime</span> new_quota: <span class=tok-type>u32</span>)</span></code></pre> <p> Changes the maximum number of backwards branches that compile-time code execution can use before giving up and making a compile error. </p> <p> If the <code><span class=line>new_quota</span></code> is smaller than the default quota (<code><span class=line><span class=tok-number>1000</span></span></code>) or a previously explicitly set quota, it is ignored. </p> <p> Example: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"foo"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-kw>var</span> i = <span class=tok-number>0</span>;</span>
<span class=line>        <span class=tok-kw>while</span> (i &lt; <span class=tok-number>1001</span>) : (i += <span class=tok-number>1</span>) {}</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:4:9: </span><span class=t31_1>error: </span><span class=t1_0>evaluation exceeded 1000 backwards branches</span>
<span class=line></span>        while (i &lt; 1001) : (i += 1) {}</span>
<span class=line>        <span class=t32_1>^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:4:9: </span><span class=t36_1>note: </span><span class=t1_0>use @setEvalBranchQuota() to raise the branch limit from 1000</span>
<span class=line></span></span>
</samp></pre></figure> <p>Now we use <code><span class=line><span class=tok-builtin>@setEvalBranchQuota</span></span></code>:</p> <figure><figcaption class=zig-cap><cite class=file>setEvalBranchQuota.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"foo"</span> {</span>
<span class=line>    <span class=tok-kw>comptime</span> {</span>
<span class=line>        <span class=tok-builtin>@setEvalBranchQuota</span>(<span class=tok-number>1001</span>);</span>
<span class=line>        <span class=tok-kw>var</span> i = <span class=tok-number>0</span>;</span>
<span class=line>        <span class=tok-kw>while</span> (i &lt; <span class=tok-number>1001</span>) : (i += <span class=tok-number>1</span>) {}</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test setEvalBranchQuota.zig</kbd></span>
<span class=line>1/1 test.foo... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#comptime>comptime</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40setFloatMode class=dashAnchor></a><h3 id=setFloatMode>@setFloatMode</h3> <pre><code><span class=line><span class=tok-builtin>@setFloatMode</span>(<span class=tok-kw>comptime</span> mode: <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).builtin.FloatMode)</span></code></pre> <p> Sets the floating point mode of the current scope. Possible values are: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> FloatMode = <span class=tok-kw>enum</span> {</span>
<span class=line>    Strict,</span>
<span class=line>    Optimized,</span>
<span class=line>};</span></code></pre></figure> <ul> <li> <code><span class=line>Strict</span></code> (default) - Floating point operations follow strict IEEE compliance. </li> <li> <code><span class=line>Optimized</span></code> - Floating point operations may do all of the following: <ul> <li>Assume the arguments and result are not NaN. Optimizations are required to retain defined behavior over NaNs, but the value of the result is undefined.</li> <li>Assume the arguments and result are not +/-Inf. Optimizations are required to retain defined behavior over +/-Inf, but the value of the result is undefined.</li> <li>Treat the sign of a zero argument or result as insignificant.</li> <li>Use the reciprocal of an argument rather than perform division.</li> <li>Perform floating-point contraction (e.g. fusing a multiply followed by an addition into a fused multiply-add).</li> <li>Perform algebraically equivalent transformations that may change results in floating point (e.g. reassociate).</li> </ul> This is equivalent to <code>-ffast-math</code> in GCC. </li> </ul> <p> The floating point mode is inherited by child scopes, and can be overridden in any scope. You can set the floating point mode in a struct or module scope by using a comptime block. </p> <p>See also:</p><ul> <li><a href=#Floating-Point-Operations>Floating Point Operations</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40setRuntimeSafety class=dashAnchor></a><h3 id=setRuntimeSafety>@setRuntimeSafety</h3> <pre><code><span class=line><span class=tok-builtin>@setRuntimeSafety</span>(<span class=tok-kw>comptime</span> safety_on: <span class=tok-type>bool</span>) <span class=tok-type>void</span></span></code></pre> <p> Sets whether runtime safety checks are enabled for the scope that contains the function call. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"@setRuntimeSafety"</span> {</span>
<span class=line>    <span class=tok-comment>// The builtin applies to the scope that it is called in. So here, integer overflow</span></span>
<span class=line>    <span class=tok-comment>// will not be caught in ReleaseFast and ReleaseSmall modes:</span></span>
<span class=line>    <span class=tok-comment>// var x: u8 = 255;</span></span>
<span class=line>    <span class=tok-comment>// x += 1; // undefined behavior in ReleaseFast/ReleaseSmall modes.</span></span>
<span class=line>    {</span>
<span class=line>        <span class=tok-comment>// However this block has safety enabled, so safety checks happen here,</span></span>
<span class=line>        <span class=tok-comment>// even in ReleaseFast and ReleaseSmall modes.</span></span>
<span class=line>        <span class=tok-builtin>@setRuntimeSafety</span>(<span class=tok-null>true</span>);</span>
<span class=line>        <span class=tok-kw>var</span> x: <span class=tok-type>u8</span> = <span class=tok-number>255</span>;</span>
<span class=line>        x += <span class=tok-number>1</span>;</span>
<span class=line></span>
<span class=line>        {</span>
<span class=line>            <span class=tok-comment>// The value can be overridden at any scope. So here integer overflow</span></span>
<span class=line>            <span class=tok-comment>// would not be caught in any build mode.</span></span>
<span class=line>            <span class=tok-builtin>@setRuntimeSafety</span>(<span class=tok-null>false</span>);</span>
<span class=line>            <span class=tok-comment>// var x: u8 = 255;</span></span>
<span class=line>            <span class=tok-comment>// x += 1; // undefined behavior in all build modes.</span></span>
<span class=line>        }</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig -OReleaseFast</kbd></span>
<span class=line>1/1 test.@setRuntimeSafety... thread 1639390 panic: integer overflow</span>
<span class=line>error: the following test command crashed:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/257de3d8ff44d3bf4dfe2177655d1c69/test</span>
</samp></pre></figure> <p>Note: it is <a href=https://github.com/ziglang/zig/issues/978>planned</a> to replace <code><span class=line><span class=tok-builtin>@setRuntimeSafety</span></span></code> with <code>@optimizeFor</code></p> <a name=//apple_ref/cpp/Builtin/%40shlExact class=dashAnchor></a><h3 id=shlExact>@shlExact</h3> <pre><code><span class=line><span class=tok-builtin>@shlExact</span>(value: T, shift_amt: Log2T) T</span></code></pre> <p> Performs the left shift operation (<code><span class=line>&lt;&lt;</span></code>). For unsigned integers, the result is <a href="#undefined">undefined</a> if any 1 bits are shifted out. For signed integers, the result is <a href="#undefined">undefined</a> if any bits that disagree with the resultant sign bit are shifted out. </p> <p> The type of <code><span class=line>shift_amt</span></code> is an unsigned integer with <code><span class=line>log2(<span class=tok-builtin>@typeInfo</span>(T).Int.bits)</span></code> bits. This is because <code><span class=line>shift_amt &gt;= <span class=tok-builtin>@typeInfo</span>(T).Int.bits</span></code> is undefined behavior. </p> <p>See also:</p><ul> <li><a href=#shrExact>@shrExact</a></li> <li><a href=#shlWithOverflow>@shlWithOverflow</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40shlWithOverflow class=dashAnchor></a><h3 id=shlWithOverflow>@shlWithOverflow</h3> <pre><code><span class=line><span class=tok-builtin>@shlWithOverflow</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, shift_amt: Log2T, result: *T) <span class=tok-type>bool</span></span></code></pre> <p> Performs <code><span class=line>result.* = a &lt;&lt; b</span></code>. If overflow or underflow occurs, stores the overflowed bits in <code><span class=line>result</span></code> and returns <code><span class=line><span class=tok-null>true</span></span></code>. If no overflow or underflow occurs, returns <code><span class=line><span class=tok-null>false</span></span></code>. </p> <p> The type of <code><span class=line>shift_amt</span></code> is an unsigned integer with <code><span class=line>log2(<span class=tok-builtin>@typeInfo</span>(T).Int.bits)</span></code> bits. This is because <code><span class=line>shift_amt &gt;= <span class=tok-builtin>@typeInfo</span>(T).Int.bits</span></code> is undefined behavior. </p> <p>See also:</p><ul> <li><a href=#shlExact>@shlExact</a></li> <li><a href=#shrExact>@shrExact</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40shrExact class=dashAnchor></a><h3 id=shrExact>@shrExact</h3> <pre><code><span class=line><span class=tok-builtin>@shrExact</span>(value: T, shift_amt: Log2T) T</span></code></pre> <p> Performs the right shift operation (<code><span class=line>&gt;&gt;</span></code>). Caller guarantees that the shift will not shift any 1 bits out. </p> <p> The type of <code><span class=line>shift_amt</span></code> is an unsigned integer with <code><span class=line>log2(<span class=tok-builtin>@typeInfo</span>(T).Int.bits)</span></code> bits. This is because <code><span class=line>shift_amt &gt;= <span class=tok-builtin>@typeInfo</span>(T).Int.bits</span></code> is undefined behavior. </p> <p>See also:</p><ul> <li><a href=#shlExact>@shlExact</a></li> <li><a href=#shlWithOverflow>@shlWithOverflow</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40shuffle class=dashAnchor></a><h3 id=shuffle>@shuffle</h3> <pre><code><span class=line><span class=tok-builtin>@shuffle</span>(<span class=tok-kw>comptime</span> E: <span class=tok-type>type</span>, a: <span class=tok-builtin>@Vector</span>(a_len, E), b: <span class=tok-builtin>@Vector</span>(b_len, E), <span class=tok-kw>comptime</span> mask: <span class=tok-builtin>@Vector</span>(mask_len, <span class=tok-type>i32</span>)) <span class=tok-builtin>@Vector</span>(mask_len, E)</span></code></pre> <p> Constructs a new <a href=#Vectors>vector</a> by selecting elements from <code><span class=line>a</span></code> and <code><span class=line>b</span></code> based on <code><span class=line>mask</span></code>. </p> <p> Each element in <code><span class=line>mask</span></code> selects an element from either <code><span class=line>a</span></code> or <code><span class=line>b</span></code>. Positive numbers select from <code><span class=line>a</span></code> starting at 0. Negative values select from <code><span class=line>b</span></code>, starting at <code><span class=line>-<span class=tok-number>1</span></span></code> and going down. It is recommended to use the <code><span class=line>~</span></code> operator for indexes from <code><span class=line>b</span></code> so that both indexes can start from <code><span class=line><span class=tok-number>0</span></span></code> (i.e. <code><span class=line>~<span class=tok-builtin>@as</span>(<span class=tok-type>i32</span>, <span class=tok-number>0</span>)</span></code> is <code><span class=line>-<span class=tok-number>1</span></span></code>). </p> <p> For each element of <code><span class=line>mask</span></code>, if it or the selected value from <code><span class=line>a</span></code> or <code><span class=line>b</span></code> is <code><span class=line><span class=tok-null>undefined</span></span></code>, then the resulting element is <code><span class=line><span class=tok-null>undefined</span></span></code>. </p> <p> <code><span class=line>a_len</span></code> and <code><span class=line>b_len</span></code> may differ in length. Out-of-bounds element indexes in <code><span class=line>mask</span></code> result in compile errors. </p> <p> If <code><span class=line>a</span></code> or <code><span class=line>b</span></code> is <code><span class=line><span class=tok-null>undefined</span></span></code>, it is equivalent to a vector of all <code><span class=line><span class=tok-null>undefined</span></span></code> with the same length as the other vector. If both vectors are <code><span class=line><span class=tok-null>undefined</span></span></code>, <code><span class=line><span class=tok-builtin>@shuffle</span></span></code> returns a vector with all elements <code><span class=line><span class=tok-null>undefined</span></span></code>. </p> <p> <code><span class=line>E</span></code> must be an <a href=#Integers>integer</a>, <a href=#Floats>float</a>, <a href=#Pointers>pointer</a>, or <code><span class=line><span class=tok-type>bool</span></span></code>. The mask may be any vector length, and its length determines the result length. </p> <figure><figcaption class=zig-cap><cite class=file>vector_shuffle.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"vector @shuffle"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> a = <span class=tok-builtin>@Vector</span>(<span class=tok-number>7</span>, <span class=tok-type>u8</span>){ <span class=tok-str>'o'</span>, <span class=tok-str>'l'</span>, <span class=tok-str>'h'</span>, <span class=tok-str>'e'</span>, <span class=tok-str>'r'</span>, <span class=tok-str>'z'</span>, <span class=tok-str>'w'</span> };</span>
<span class=line>    <span class=tok-kw>const</span> b = <span class=tok-builtin>@Vector</span>(<span class=tok-number>4</span>, <span class=tok-type>u8</span>){ <span class=tok-str>'w'</span>, <span class=tok-str>'d'</span>, <span class=tok-str>'!'</span>, <span class=tok-str>'x'</span> };</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// To shuffle within a single vector, pass undefined as the second argument.</span></span>
<span class=line>    <span class=tok-comment>// Notice that we can re-order, duplicate, or omit elements of the input vector</span></span>
<span class=line>    <span class=tok-kw>const</span> mask1 = <span class=tok-builtin>@Vector</span>(<span class=tok-number>5</span>, <span class=tok-type>i32</span>){ <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>1</span>, <span class=tok-number>1</span>, <span class=tok-number>0</span> };</span>
<span class=line>    <span class=tok-kw>const</span> res1: <span class=tok-builtin>@Vector</span>(<span class=tok-number>5</span>, <span class=tok-type>u8</span>) = <span class=tok-builtin>@shuffle</span>(<span class=tok-type>u8</span>, a, <span class=tok-null>undefined</span>, mask1);</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>u8</span>, &amp;<span class=tok-builtin>@as</span>([<span class=tok-number>5</span>]<span class=tok-type>u8</span>, res1), <span class=tok-str>"hello"</span>));</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Combining two vectors</span></span>
<span class=line>    <span class=tok-kw>const</span> mask2 = <span class=tok-builtin>@Vector</span>(<span class=tok-number>6</span>, <span class=tok-type>i32</span>){ -<span class=tok-number>1</span>, <span class=tok-number>0</span>, <span class=tok-number>4</span>, <span class=tok-number>1</span>, -<span class=tok-number>2</span>, -<span class=tok-number>3</span> };</span>
<span class=line>    <span class=tok-kw>const</span> res2: <span class=tok-builtin>@Vector</span>(<span class=tok-number>6</span>, <span class=tok-type>u8</span>) = <span class=tok-builtin>@shuffle</span>(<span class=tok-type>u8</span>, a, b, mask2);</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>u8</span>, &amp;<span class=tok-builtin>@as</span>([<span class=tok-number>6</span>]<span class=tok-type>u8</span>, res2), <span class=tok-str>"world!"</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test vector_shuffle.zig</kbd></span>
<span class=line>1/1 test.vector @shuffle... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Vectors>Vectors</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40sizeOf class=dashAnchor></a><h3 id=sizeOf>@sizeOf</h3> <pre><code><span class=line><span class=tok-builtin>@sizeOf</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>) <span class=tok-type>comptime_int</span></span></code></pre> <p> This function returns the number of bytes it takes to store <code><span class=line>T</span></code> in memory. The result is a target-specific compile time constant. </p> <p> This size may contain padding bytes. If there were two consecutive T in memory, this would be the offset in bytes between element at index 0 and the element at index 1. For <a href=#Integers>integer</a>, consider whether you want to use <code><span class=line><span class=tok-builtin>@sizeOf</span>(T)</span></code> or <code><span class=line><span class=tok-builtin>@typeInfo</span>(T).Int.bits</span></code>. </p> <p> This function measures the size at runtime. For types that are disallowed at runtime, such as <code><span class=line><span class=tok-type>comptime_int</span></span></code> and <code><span class=line><span class=tok-type>type</span></span></code>, the result is <code><span class=line><span class=tok-number>0</span></span></code>. </p> <p>See also:</p><ul> <li><a href=#bitSizeOf>@bitSizeOf</a></li> <li><a href=#typeInfo>@typeInfo</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40splat class=dashAnchor></a><h3 id=splat>@splat</h3> <pre><code><span class=line><span class=tok-builtin>@splat</span>(<span class=tok-kw>comptime</span> len: <span class=tok-type>u32</span>, scalar: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@Vector</span>(len, <span class=tok-builtin>@TypeOf</span>(scalar))</span></code></pre> <p> Produces a vector of length <code><span class=line>len</span></code> where each element is the value <code><span class=line>scalar</span></code>: </p> <figure><figcaption class=zig-cap><cite class=file>vector_splat.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"vector @splat"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> scalar: <span class=tok-type>u32</span> = <span class=tok-number>5</span>;</span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-builtin>@splat</span>(<span class=tok-number>4</span>, scalar);</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(result) == <span class=tok-builtin>@Vector</span>(<span class=tok-number>4</span>, <span class=tok-type>u32</span>));</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>u32</span>, &amp;<span class=tok-builtin>@as</span>([<span class=tok-number>4</span>]<span class=tok-type>u32</span>, result), &amp;[_]<span class=tok-type>u32</span>{ <span class=tok-number>5</span>, <span class=tok-number>5</span>, <span class=tok-number>5</span>, <span class=tok-number>5</span> }));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test vector_splat.zig</kbd></span>
<span class=line>1/1 test.vector @splat... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> <code><span class=line>scalar</span></code> must be an <a href=#Integers>integer</a>, <a href=#Primitive-Types>bool</a>, <a href=#Floats>float</a>, or <a href=#Pointers>pointer</a>. </p> <p>See also:</p><ul> <li><a href=#Vectors>Vectors</a></li> <li><a href=#shuffle>@shuffle</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40reduce class=dashAnchor></a><h3 id=reduce>@reduce</h3> <pre><code><span class=line><span class=tok-builtin>@reduce</span>(<span class=tok-kw>comptime</span> op: std.builtin.ReduceOp, value: <span class=tok-kw>anytype</span>) E</span></code></pre> <p> Transforms a <a href=#Vectors>vector</a> into a scalar value (of type <code>E</code>) by performing a sequential horizontal reduction of its elements using the specified operator <code><span class=line>op</span></code>. </p> <p> Not every operator is available for every vector element type: </p> <ul> <li>Every operator is available for <a href=#Integers>integer</a> vectors.</li> <li><code><span class=line>.And</span></code>, <code><span class=line>.Or</span></code>, <code><span class=line>.Xor</span></code> are additionally available for <code><span class=line><span class=tok-type>bool</span></span></code> vectors,</li> <li><code><span class=line>.Min</span></code>, <code><span class=line>.Max</span></code>, <code><span class=line>.Add</span></code>, <code><span class=line>.Mul</span></code> are additionally available for <a href=#Floats>floating point</a> vectors,</li> </ul> <p> Note that <code><span class=line>.Add</span></code> and <code><span class=line>.Mul</span></code> reductions on integral types are wrapping; when applied on floating point types the operation associativity is preserved, unless the float mode is set to <code><span class=line>Optimized</span></code>. </p> <figure><figcaption class=zig-cap><cite class=file>vector_reduce.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"vector @reduce"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> value = <span class=tok-builtin>@Vector</span>(<span class=tok-number>4</span>, <span class=tok-type>i32</span>){ <span class=tok-number>1</span>, -<span class=tok-number>1</span>, <span class=tok-number>1</span>, -<span class=tok-number>1</span> };</span>
<span class=line>    <span class=tok-kw>const</span> result = value &gt; <span class=tok-builtin>@splat</span>(<span class=tok-number>4</span>, <span class=tok-builtin>@as</span>(<span class=tok-type>i32</span>, <span class=tok-number>0</span>));</span>
<span class=line>    <span class=tok-comment>// result is { true, false, true, false };</span></span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(result) == <span class=tok-builtin>@Vector</span>(<span class=tok-number>4</span>, <span class=tok-type>bool</span>));</span>
<span class=line>    <span class=tok-kw>const</span> is_all_true = <span class=tok-builtin>@reduce</span>(.And, result);</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(<span class=tok-builtin>@TypeOf</span>(is_all_true) == <span class=tok-type>bool</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(is_all_true == <span class=tok-null>false</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test vector_reduce.zig</kbd></span>
<span class=line>1/1 test.vector @reduce... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Vectors>Vectors</a></li> <li><a href=#setFloatMode>@setFloatMode</a></li> </ul> <a name=//apple_ref/cpp/Builtin/%40src class=dashAnchor></a><h3 id=src>@src</h3> <pre><code><span class=line><span class=tok-builtin>@src</span>() std.builtin.SourceLocation</span></code></pre> <p> Returns a <code><span class=line>SourceLocation</span></code> struct representing the function's name and location in the source code. This must be called in a function. </p> <figure><figcaption class=zig-cap><cite class=file>source_location.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"@src"</span> {</span>
<span class=line>    <span class=tok-kw>try</span> doTheTest();</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>doTheTest</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> src = <span class=tok-builtin>@src</span>();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> expect(src.line == <span class=tok-number>9</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(src.column == <span class=tok-number>17</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.endsWith(<span class=tok-type>u8</span>, src.fn_name, <span class=tok-str>"doTheTest"</span>));</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.endsWith(<span class=tok-type>u8</span>, src.file, <span class=tok-str>"source_location.zig"</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test source_location.zig</kbd></span>
<span class=line>1/1 test.@src... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Builtin/%40sqrt class=dashAnchor></a><h3 id=sqrt>@sqrt</h3> <pre><code><span class=line><span class=tok-builtin>@sqrt</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Performs the square root of a floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40sin class=dashAnchor></a><h3 id=sin>@sin</h3> <pre><code><span class=line><span class=tok-builtin>@sin</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Sine trigonometric function on a floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40cos class=dashAnchor></a><h3 id=cos>@cos</h3> <pre><code><span class=line><span class=tok-builtin>@cos</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Cosine trigonometric function on a floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40tan class=dashAnchor></a><h3 id=tan>@tan</h3> <pre><code><span class=line><span class=tok-builtin>@tan</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Tangent trigonometric function on a floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40exp class=dashAnchor></a><h3 id=exp>@exp</h3> <pre><code><span class=line><span class=tok-builtin>@exp</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Base-e exponential function on a floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40exp2 class=dashAnchor></a><h3 id=exp2>@exp2</h3> <pre><code><span class=line><span class=tok-builtin>@exp2</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Base-2 exponential function on a floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40log class=dashAnchor></a><h3 id=log>@log</h3> <pre><code><span class=line><span class=tok-builtin>@log</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Returns the natural logarithm of a floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40log2 class=dashAnchor></a><h3 id=log2>@log2</h3> <pre><code><span class=line><span class=tok-builtin>@log2</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Returns the logarithm to the base 2 of a floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40log10 class=dashAnchor></a><h3 id=log10>@log10</h3> <pre><code><span class=line><span class=tok-builtin>@log10</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Returns the logarithm to the base 10 of a floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40fabs class=dashAnchor></a><h3 id=fabs>@fabs</h3> <pre><code><span class=line><span class=tok-builtin>@fabs</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Returns the absolute value of a floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40floor class=dashAnchor></a><h3 id=floor>@floor</h3> <pre><code><span class=line><span class=tok-builtin>@floor</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Returns the largest integral value not greater than the given floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40ceil class=dashAnchor></a><h3 id=ceil>@ceil</h3> <pre><code><span class=line><span class=tok-builtin>@ceil</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Returns the smallest integral value not less than the given floating point number. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40trunc class=dashAnchor></a><h3 id=trunc>@trunc</h3> <pre><code><span class=line><span class=tok-builtin>@trunc</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Rounds the given floating point number to an integer, towards zero. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40round class=dashAnchor></a><h3 id=round>@round</h3> <pre><code><span class=line><span class=tok-builtin>@round</span>(value: <span class=tok-kw>anytype</span>) <span class=tok-builtin>@TypeOf</span>(value)</span></code></pre> <p> Rounds the given floating point number to an integer, away from zero. Uses a dedicated hardware instruction when available. </p> <p> Supports <a href=#Floats>Floats</a> and <a href=#Vectors>Vectors</a> of floats, with the caveat that <a href=https://github.com/ziglang/zig/issues/4026>some float operations are not yet implemented for all float types</a>. </p> <a name=//apple_ref/cpp/Builtin/%40subWithOverflow class=dashAnchor></a><h3 id=subWithOverflow>@subWithOverflow</h3> <pre><code><span class=line><span class=tok-builtin>@subWithOverflow</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, a: T, b: T, result: *T) <span class=tok-type>bool</span></span></code></pre> <p> Performs <code><span class=line>result.* = a - b</span></code>. If overflow or underflow occurs, stores the overflowed bits in <code><span class=line>result</span></code> and returns <code><span class=line><span class=tok-null>true</span></span></code>. If no overflow or underflow occurs, returns <code><span class=line><span class=tok-null>false</span></span></code>. </p> <a name=//apple_ref/cpp/Builtin/%40tagName class=dashAnchor></a><h3 id=tagName>@tagName</h3> <pre><code><span class=line><span class=tok-builtin>@tagName</span>(value: <span class=tok-kw>anytype</span>) [:<span class=tok-number>0</span>]<span class=tok-kw>const</span> <span class=tok-type>u8</span></span></code></pre> <p> Converts an enum value or union value to a string literal representing the name.</p><p>If the enum is non-exhaustive and the tag value does not map to a name, it invokes safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <a name=//apple_ref/cpp/Builtin/%40This class=dashAnchor></a><h3 id=This>@This</h3> <pre><code><span class=line><span class=tok-builtin>@This</span>() <span class=tok-type>type</span></span></code></pre> <p> Returns the innermost struct, enum, or union that this function call is inside. This can be useful for an anonymous struct that needs to refer to itself: </p> <figure><figcaption class=zig-cap><cite class=file>this_innermost.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"@This()"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> items = [_]<span class=tok-type>i32</span>{ <span class=tok-number>1</span>, <span class=tok-number>2</span>, <span class=tok-number>3</span>, <span class=tok-number>4</span> };</span>
<span class=line>    <span class=tok-kw>const</span> list = List(<span class=tok-type>i32</span>){ .items = items[<span class=tok-number>0</span>..] };</span>
<span class=line>    <span class=tok-kw>try</span> expect(list.length() == <span class=tok-number>4</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>List</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>) <span class=tok-type>type</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>struct</span> {</span>
<span class=line>        <span class=tok-kw>const</span> Self = <span class=tok-builtin>@This</span>();</span>
<span class=line></span>
<span class=line>        items: []T,</span>
<span class=line></span>
<span class=line>        <span class=tok-kw>fn</span> <span class=tok-fn>length</span>(self: Self) <span class=tok-type>usize</span> {</span>
<span class=line>            <span class=tok-kw>return</span> self.items.len;</span>
<span class=line>        }</span>
<span class=line>    };</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test this_innermost.zig</kbd></span>
<span class=line>1/1 test.@This()... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> When <code><span class=line><span class=tok-builtin>@This</span>()</span></code> is used at file scope, it returns a reference to the struct that corresponds to the current file. </p> <a name=//apple_ref/cpp/Builtin/%40truncate class=dashAnchor></a><h3 id=truncate>@truncate</h3> <pre><code><span class=line><span class=tok-builtin>@truncate</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, integer: <span class=tok-kw>anytype</span>) T</span></code></pre> <p> This function truncates bits from an integer type, resulting in a smaller or same-sized integer type. </p> <p> This function always truncates the significant bits of the integer, regardless of endianness on the target platform. </p> <p> Calling <code><span class=line><span class=tok-builtin>@truncate</span></span></code> on a number out of range of the destination type is well defined and working code: </p> <figure><figcaption class=zig-cap><cite class=file>truncate.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"integer truncation"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u16</span> = <span class=tok-number>0xabcd</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>u8</span> = <span class=tok-builtin>@truncate</span>(<span class=tok-type>u8</span>, a);</span>
<span class=line>    <span class=tok-kw>try</span> expect(b == <span class=tok-number>0xcd</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test truncate.zig</kbd></span>
<span class=line>1/1 test.integer truncation... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Use <a href=#intCast>@intCast</a> to convert numbers guaranteed to fit the destination type. </p> <a name=//apple_ref/cpp/Builtin/%40Type class=dashAnchor></a><h3 id=Type>@Type</h3> <pre><code><span class=line><span class=tok-builtin>@Type</span>(<span class=tok-kw>comptime</span> info: std.builtin.Type) <span class=tok-type>type</span></span></code></pre> <p> This function is the inverse of <a href=#typeInfo>@typeInfo</a>. It reifies type information into a <code><span class=line><span class=tok-type>type</span></span></code>. </p> <p> It is available for the following types: </p> <ul> <li><code><span class=line><span class=tok-type>type</span></span></code></li> <li><code><span class=line><span class=tok-type>noreturn</span></span></code></li> <li><code><span class=line><span class=tok-type>void</span></span></code></li> <li><code><span class=line><span class=tok-type>bool</span></span></code></li> <li><a href=#Integers>Integers</a> - The maximum bit count for an integer type is <code><span class=line><span class=tok-number>65535</span></span></code>.</li> <li><a href=#Floats>Floats</a></li> <li><a href=#Pointers>Pointers</a></li> <li><code><span class=line><span class=tok-type>comptime_int</span></span></code></li> <li><code><span class=line><span class=tok-type>comptime_float</span></span></code></li> <li><code><span class=line><span class=tok-builtin>@TypeOf</span>(<span class=tok-null>undefined</span>)</span></code></li> <li><code><span class=line><span class=tok-builtin>@TypeOf</span>(<span class=tok-null>null</span>)</span></code></li> <li><a href=#Arrays>Arrays</a></li> <li><a href=#Optionals>Optionals</a></li> <li><a href=#Error-Set-Type>Error Set Type</a></li> <li><a href=#Error-Union-Type>Error Union Type</a></li> <li><a href=#Vectors>Vectors</a></li> <li><a href=#opaque>opaque</a></li> <li><a href=#Frame>@Frame</a></li> <li><code><span class=line><span class=tok-kw>anyframe</span></span></code></li> <li><a href=#struct>struct</a></li> <li><a href=#enum>enum</a></li> <li><a href=#Enum-Literals>Enum Literals</a></li> <li><a href=#union>union</a></li> </ul> <p> For these types, <code><span class=line><span class=tok-builtin>@Type</span></span></code> is not available: </p> <ul> <li><a href=#Functions>Functions</a></li> <li>BoundFn</li> </ul> <a name=//apple_ref/cpp/Builtin/%40typeInfo class=dashAnchor></a><h3 id=typeInfo>@typeInfo</h3> <pre><code><span class=line><span class=tok-builtin>@typeInfo</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>) std.builtin.Type</span></code></pre> <p> Provides type reflection. </p> <p> Type information of <a href=#struct>structs</a>, <a href=#union>unions</a>, <a href=#enum>enums</a>, and <a href=#Error-Set-Type>error sets</a> has fields which are guaranteed to be in the same order as appearance in the source file. </p> <p> Type information of <a href=#struct>structs</a>, <a href=#union>unions</a>, <a href=#enum>enums</a>, and <a href=#opaque>opaques</a> has declarations, which are also guaranteed to be in the same order as appearance in the source file. </p> <a name=//apple_ref/cpp/Builtin/%40typeName class=dashAnchor></a><h3 id=typeName>@typeName</h3> <pre><code><span class=line><span class=tok-builtin>@typeName</span>(T: <span class=tok-type>type</span>) *<span class=tok-kw>const</span> [N:<span class=tok-number>0</span>]<span class=tok-type>u8</span></span></code></pre> <p> This function returns the string representation of a type, as an array. It is equivalent to a string literal of the type name. The returned type name is fully qualified with the parent namespace included as part of the type name with a series of dots. </p> <a name=//apple_ref/cpp/Builtin/%40TypeOf class=dashAnchor></a><h3 id=TypeOf>@TypeOf</h3> <pre><code><span class=line><span class=tok-builtin>@TypeOf</span>(...) <span class=tok-type>type</span></span></code></pre> <p> <code><span class=line><span class=tok-builtin>@TypeOf</span></span></code> is a special builtin function that takes any (nonzero) number of expressions as parameters and returns the type of the result, using <a href=#Peer-Type-Resolution>Peer Type Resolution</a>. </p> <p> The expressions are evaluated, however they are guaranteed to have no <em>runtime</em> side-effects: </p> <figure><figcaption class=zig-cap><cite class=file>no_runtime_side_effects.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"no runtime side effects"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> data: <span class=tok-type>i32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>const</span> T = <span class=tok-builtin>@TypeOf</span>(foo(<span class=tok-type>i32</span>, &amp;data));</span>
<span class=line>    <span class=tok-kw>comptime</span> <span class=tok-kw>try</span> expect(T == <span class=tok-type>i32</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(data == <span class=tok-number>0</span>);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, ptr: *T) T {</span>
<span class=line>    ptr.* += <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>return</span> ptr.*;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test no_runtime_side_effects.zig</kbd></span>
<span class=line>1/1 test.no runtime side effects... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Builtin/%40unionInit class=dashAnchor></a><h3 id=unionInit>@unionInit</h3> <pre><code><span class=line><span class=tok-builtin>@unionInit</span>(<span class=tok-kw>comptime</span> Union: <span class=tok-type>type</span>, <span class=tok-kw>comptime</span> active_field_name: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>, init_expr) Union</span></code></pre> <p> This is the same thing as <a href=#union>union</a> initialization syntax, except that the field name is a <a href=#comptime>comptime</a>-known value rather than an identifier token. </p> <p> <code><span class=line><span class=tok-builtin>@unionInit</span></span></code> forwards its <a href=#Result-Location-Semantics>result location</a> to <code><span class=line>init_expr</span></code>. </p> <a name=//apple_ref/cpp/Builtin/%40Vector class=dashAnchor></a><h3 id=Vector>@Vector</h3> <pre><code><span class=line><span class=tok-builtin>@Vector</span>(len: <span class=tok-type>comptime_int</span>, Element: <span class=tok-type>type</span>) <span class=tok-type>type</span></span></code></pre> <p>Creates <a href=#Vectors>Vectors</a>.</p> <a name=//apple_ref/cpp/Guide/Build%20Mode class=dashAnchor></a><h2 id=Build-Mode>Build Mode</h2> <p> Zig has four build modes: </p> <ul> <li><a href=#Debug>Debug</a> (default)</li> <li><a href=#ReleaseFast>ReleaseFast</a></li> <li><a href=#ReleaseSafe>ReleaseSafe</a></li> <li><a href=#ReleaseSmall>ReleaseSmall</a></li> </ul> <p> To add standard build options to a <code class=file>build.zig</code> file: </p> <figure><figcaption class=zig-cap><cite class=file>build.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Builder = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).build.Builder;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>build</span>(b: *Builder) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> exe = b.addExecutable(<span class=tok-str>"example"</span>, <span class=tok-str>"example.zig"</span>);</span>
<span class=line>    exe.setBuildMode(b.standardReleaseOptions());</span>
<span class=line>    b.default_step.dependOn(&amp;exe.step);</span>
<span class=line>}</span></code></pre></figure> <p> This causes these options to be available: </p> <dl> <dt><kbd>-Drelease-safe=[bool]</kbd></dt><dd>Optimizations on and safety on</dd> <dt><kbd>-Drelease-fast=[bool]</kbd></dt><dd>Optimizations on and safety off</dd> <dt><kbd>-Drelease-small=[bool]</kbd></dt><dd>Size optimizations on and safety off</dd> </dl> <a name=//apple_ref/cpp/Guide/Debug class=dashAnchor></a><h3 id=Debug>Debug</h3> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe example.zig</kbd></span>
</samp></pre></figure> <ul> <li>Fast compilation speed</li> <li>Safety checks enabled</li> <li>Slow runtime performance</li> <li>Large binary size</li> <li>No reproducible build requirement</li> </ul> <a name=//apple_ref/cpp/Guide/ReleaseFast class=dashAnchor></a><h3 id=ReleaseFast>ReleaseFast</h3> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe example.zig -O ReleaseFast</kbd></span>
</samp></pre></figure> <ul> <li>Fast runtime performance</li> <li>Safety checks disabled</li> <li>Slow compilation speed</li> <li>Large binary size</li> <li>Reproducible build</li> </ul> <a name=//apple_ref/cpp/Guide/ReleaseSafe class=dashAnchor></a><h3 id=ReleaseSafe>ReleaseSafe</h3> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe example.zig -O ReleaseSafe</kbd></span>
</samp></pre></figure> <ul> <li>Medium runtime performance</li> <li>Safety checks enabled</li> <li>Slow compilation speed</li> <li>Large binary size</li> <li>Reproducible build</li> </ul> <a name=//apple_ref/cpp/Guide/ReleaseSmall class=dashAnchor></a><h3 id=ReleaseSmall>ReleaseSmall</h3> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe example.zig -O ReleaseSmall</kbd></span>
</samp></pre></figure> <ul> <li>Medium runtime performance</li> <li>Safety checks disabled</li> <li>Slow compilation speed</li> <li>Small binary size</li> <li>Reproducible build</li> </ul> <p>See also:</p><ul> <li><a href=#Compile-Variables>Compile Variables</a></li> <li><a href=#Zig-Build-System>Zig Build System</a></li> <li><a href=#Undefined-Behavior>Undefined Behavior</a></li> </ul> <a name=//apple_ref/cpp/Guide/Single%20Threaded%20Builds class=dashAnchor></a><h2 id=Single-Threaded-Builds>Single Threaded Builds</h2> <p>Zig has a compile option <kbd>--single-threaded</kbd> which has the following effects:</p> <ul> <li>All <a href=#Thread-Local-Variables>Thread Local Variables</a> are treated as regular <a href=#Container-Level-Variables>Container Level Variables</a>.</li> <li>The overhead of <a href=#Async-Functions>Async Functions</a> becomes equivalent to function call overhead.</li> <li>The <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>).single_threaded</span></code> becomes <code><span class=line><span class=tok-null>true</span></span></code> and therefore various userland APIs which read this variable become more efficient. For example <code><span class=line>std.Mutex</span></code> becomes an empty data structure and all of its functions become no-ops.</li> </ul> <a name=//apple_ref/cpp/Guide/Undefined%20Behavior class=dashAnchor></a><h2 id=Undefined-Behavior>Undefined Behavior</h2> <p> Zig has many instances of undefined behavior. If undefined behavior is detected at compile-time, Zig emits a compile error and refuses to continue. Most undefined behavior that cannot be detected at compile-time can be detected at runtime. In these cases, Zig has safety checks. Safety checks can be disabled on a per-block basis with <a href=#setRuntimeSafety>@setRuntimeSafety</a>. The <a href=#ReleaseFast>ReleaseFast</a> and <a href=#ReleaseSmall>ReleaseSmall</a> build modes disable all safety checks (except where overridden by <a href=#setRuntimeSafety>@setRuntimeSafety</a>) in order to facilitate optimizations. </p> <p> When a safety check fails, Zig crashes with a stack trace, like this: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>test</span> <span class=tok-str>"safety check"</span> {</span>
<span class=line>    <span class=tok-kw>unreachable</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line>1/1 test.safety check... thread 1639714 panic: reached unreachable code</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:2:5</span>: <span class=t2_0>0x211565 in test.safety check (test)</span></span>
<span class=line>    unreachable;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/test_runner.zig:63:28</span>: <span class=t2_0>0x212b68 in main (test)</span></span>
<span class=line>        } else test_fn.func();</span>
<span class=line>                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x211e4b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x211911 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>error: the following test command crashed:</span>
<span class=line>/home/andy/tmp/zig/zig-cache/o/c8cfbb273b267e28462c38d7de2721ed/test</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Reaching%20Unreachable%20Code class=dashAnchor></a><h3 id=Reaching-Unreachable-Code>Reaching Unreachable Code</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    assert(<span class=tok-null>false</span>);</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>assert</span>(ok: <span class=tok-type>bool</span>) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>if</span> (!ok) <span class=tok-kw>unreachable</span>; <span class=tok-comment>// assertion failure</span></span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:5:14: </span><span class=t31_1>error: </span><span class=t1_0>reached unreachable code</span>
<span class=line></span>    if (!ok) unreachable; // assertion failure</span>
<span class=line>             <span class=t32_1>^~~~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:2:11: </span><span class=t36_1>note: </span><span class=t1_0>called from here</span>
<span class=line></span>    assert(false);</span>
<span class=line>    <span class=t32_1>~~~~~~^~~~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    std.debug.assert(<span class=tok-null>false</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1639774 panic: reached unreachable code</span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/debug.zig:278:14</span>: <span class=t2_0>0x211720 in assert (test)</span></span>
<span class=line>    if (!ok) unreachable; // assertion failure</span>
<span class=line>             <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:4:21</span>: <span class=t2_0>0x20fffa in main (test)</span></span>
<span class=line>    std.debug.assert(false);</span>
<span class=line>                    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f6bb in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f181 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Index%20out%20of%20Bounds class=dashAnchor></a><h3 id=Index-out-of-Bounds>Index out of Bounds</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> array: [<span class=tok-number>5</span>]<span class=tok-type>u8</span> = <span class=tok-str>"hello"</span>.*;</span>
<span class=line>    <span class=tok-kw>const</span> garbage = array[<span class=tok-number>5</span>];</span>
<span class=line>    _ = garbage;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:3:27: </span><span class=t31_1>error: </span><span class=t1_0>index 5 outside array of length 5</span>
<span class=line></span>    const garbage = array[5];</span>
<span class=line>                          <span class=t32_1>^</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x = foo(<span class=tok-str>"hello"</span>);</span>
<span class=line>    _ = x;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(x: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) <span class=tok-type>u8</span> {</span>
<span class=line>    <span class=tok-kw>return</span> x[<span class=tok-number>5</span>];</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1639834 panic: index out of bounds: index 5, len 5</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:7:5</span>: <span class=t2_0>0x2119b9 in foo (test)</span></span>
<span class=line>    return x[5];</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:2:16</span>: <span class=t2_0>0x21000b in main (test)</span></span>
<span class=line>    var x = foo("hello");</span>
<span class=line>               <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f6bb in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f181 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Cast%20Negative%20Number%20to%20Unsigned%20Integer class=dashAnchor></a><h3 id=Cast-Negative-Number-to-Unsigned-Integer>Cast Negative Number to Unsigned Integer</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>var</span> value: <span class=tok-type>i32</span> = -<span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>const</span> unsigned = <span class=tok-builtin>@intCast</span>(<span class=tok-type>u32</span>, value);</span>
<span class=line>    _ = unsigned;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:3:36: </span><span class=t31_1>error: </span><span class=t1_0>type 'u32' cannot represent integer value '-1'</span>
<span class=line></span>    const unsigned = @intCast(u32, value);</span>
<span class=line>                                   <span class=t32_1>^~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> value: <span class=tok-type>i32</span> = -<span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>var</span> unsigned = <span class=tok-builtin>@intCast</span>(<span class=tok-type>u32</span>, value);</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{unsigned});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1639895 panic: attempt to cast negative value to unsigned integer</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:5:5</span>: <span class=t2_0>0x21020d in main (test)</span></span>
<span class=line>    var unsigned = @intCast(u32, value);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f89b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f361 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <p> To obtain the maximum value of an unsigned integer, use <code><span class=line>std.math.maxInt</span></code>. </p> <a name=//apple_ref/cpp/Guide/Cast%20Truncates%20Data class=dashAnchor></a><h3 id=Cast-Truncates-Data>Cast Truncates Data</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> spartan_count: <span class=tok-type>u16</span> = <span class=tok-number>300</span>;</span>
<span class=line>    <span class=tok-kw>const</span> byte = <span class=tok-builtin>@intCast</span>(<span class=tok-type>u8</span>, spartan_count);</span>
<span class=line>    _ = byte;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:3:31: </span><span class=t31_1>error: </span><span class=t1_0>type 'u8' cannot represent integer value '300'</span>
<span class=line></span>    const byte = @intCast(u8, spartan_count);</span>
<span class=line>                              <span class=t32_1>^~~~~~~~~~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> spartan_count: <span class=tok-type>u16</span> = <span class=tok-number>300</span>;</span>
<span class=line>    <span class=tok-kw>const</span> byte = <span class=tok-builtin>@intCast</span>(<span class=tok-type>u8</span>, spartan_count);</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{byte});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1639955 panic: integer cast truncated bits</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:5:5</span>: <span class=t2_0>0x2101c6 in main (test)</span></span>
<span class=line>    const byte = @intCast(u8, spartan_count);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f84b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f311 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <p> To truncate bits, use <a href=#truncate>@truncate</a>. </p> <a name=//apple_ref/cpp/Guide/Integer%20Overflow class=dashAnchor></a><h3 id=Integer-Overflow>Integer Overflow</h3> <a name=//apple_ref/cpp/Guide/Default%20Operations class=dashAnchor></a><h4 id=Default-Operations>Default Operations</h4> <p>The following operators can cause integer overflow:</p> <ul> <li><code><span class=line>+</span></code> (addition)</li> <li><code><span class=line>-</span></code> (subtraction)</li> <li><code><span class=line>-</span></code> (negation)</li> <li><code><span class=line>*</span></code> (multiplication)</li> <li><code><span class=line>/</span></code> (division)</li> <li><a href=#divTrunc>@divTrunc</a> (division)</li> <li><a href=#divFloor>@divFloor</a> (division)</li> <li><a href=#divExact>@divExact</a> (division)</li> </ul> <p>Example with addition at compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>var</span> byte: <span class=tok-type>u8</span> = <span class=tok-number>255</span>;</span>
<span class=line>    byte += <span class=tok-number>1</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:3:10: </span><span class=t31_1>error: </span><span class=t1_0>overflow of integer type 'u8' with value '256'</span>
<span class=line></span>    byte += 1;</span>
<span class=line>    <span class=t32_1>~~~~~^~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> byte: <span class=tok-type>u8</span> = <span class=tok-number>255</span>;</span>
<span class=line>    byte += <span class=tok-number>1</span>;</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{byte});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640016 panic: integer overflow</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:5:5</span>: <span class=t2_0>0x2101b4 in main (test)</span></span>
<span class=line>    byte += 1;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f83b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f301 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Standard%20Library%20Math%20Functions class=dashAnchor></a><h4 id=Standard-Library-Math-Functions>Standard Library Math Functions</h4> <p>These functions provided by the standard library return possible errors.</p> <ul> <li><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.add</span></code></li> <li><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.sub</span></code></li> <li><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.mul</span></code></li> <li><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.divTrunc</span></code></li> <li><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.divFloor</span></code></li> <li><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.divExact</span></code></li> <li><code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math.shl</span></code></li> </ul> <p>Example of catching an overflow for addition:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> math = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).math;</span>
<span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> byte: <span class=tok-type>u8</span> = <span class=tok-number>255</span>;</span>
<span class=line></span>
<span class=line>    byte = <span class=tok-kw>if</span> (math.add(<span class=tok-type>u8</span>, byte, <span class=tok-number>1</span>)) |result| result <span class=tok-kw>else</span> |err| {</span>
<span class=line>        print(<span class=tok-str>"unable to add one: {s}\n"</span>, .{<span class=tok-builtin>@errorName</span>(err)});</span>
<span class=line>        <span class=tok-kw>return</span> err;</span>
<span class=line>    };</span>
<span class=line></span>
<span class=line>    print(<span class=tok-str>"result: {}\n"</span>, .{byte});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>unable to add one: Overflow</span>
<span class=line>error: Overflow</span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/math.zig:484:5</span>: <span class=t2_0>0x210023 in add__anon_2890 (test)</span></span>
<span class=line>    return if (@addWithOverflow(T, a, b, &amp;answer)) error.Overflow else answer;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:8:9</span>: <span class=t2_0>0x20ff3d in main (test)</span></span>
<span class=line>        return err;</span>
<span class=line>        <span class=t32_1>^</span></span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Builtin%20Overflow%20Functions class=dashAnchor></a><h4 id=Builtin-Overflow-Functions>Builtin Overflow Functions</h4> <p> These builtins return a <code><span class=line><span class=tok-type>bool</span></span></code> of whether or not overflow occurred, as well as returning the overflowed bits: </p> <ul> <li><a href=#addWithOverflow>@addWithOverflow</a></li> <li><a href=#subWithOverflow>@subWithOverflow</a></li> <li><a href=#mulWithOverflow>@mulWithOverflow</a></li> <li><a href=#shlWithOverflow>@shlWithOverflow</a></li> </ul> <p> Example of <a href=#addWithOverflow>@addWithOverflow</a>: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> byte: <span class=tok-type>u8</span> = <span class=tok-number>255</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> result: <span class=tok-type>u8</span> = <span class=tok-null>undefined</span>;</span>
<span class=line>    <span class=tok-kw>if</span> (<span class=tok-builtin>@addWithOverflow</span>(<span class=tok-type>u8</span>, byte, <span class=tok-number>10</span>, &amp;result)) {</span>
<span class=line>        print(<span class=tok-str>"overflowed result: {}\n"</span>, .{result});</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        print(<span class=tok-str>"result: {}\n"</span>, .{result});</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>overflowed result: 9</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Wrapping%20Operations class=dashAnchor></a><h4 id=Wrapping-Operations>Wrapping Operations</h4> <p> These operations have guaranteed wraparound semantics. </p> <ul> <li><code><span class=line>+%</span></code> (wraparound addition)</li> <li><code><span class=line>-%</span></code> (wraparound subtraction)</li> <li><code><span class=line>-%</span></code> (wraparound negation)</li> <li><code><span class=line>*%</span></code> (wraparound multiplication)</li> </ul> <figure><figcaption class=zig-cap><cite class=file>wraparound_semantics.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line><span class=tok-kw>const</span> minInt = std.math.minInt;</span>
<span class=line><span class=tok-kw>const</span> maxInt = std.math.maxInt;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"wraparound addition and subtraction"</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x: <span class=tok-type>i32</span> = maxInt(<span class=tok-type>i32</span>);</span>
<span class=line>    <span class=tok-kw>const</span> min_val = x +% <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(min_val == minInt(<span class=tok-type>i32</span>));</span>
<span class=line>    <span class=tok-kw>const</span> max_val = min_val -% <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>try</span> expect(max_val == maxInt(<span class=tok-type>i32</span>));</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test wraparound_semantics.zig</kbd></span>
<span class=line>1/1 test.wraparound addition and subtraction... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Exact%20Left%20Shift%20Overflow class=dashAnchor></a><h3 id=Exact-Left-Shift-Overflow>Exact Left Shift Overflow</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x = <span class=tok-builtin>@shlExact</span>(<span class=tok-builtin>@as</span>(<span class=tok-type>u8</span>, <span class=tok-number>0b01010101</span>), <span class=tok-number>2</span>);</span>
<span class=line>    _ = x;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig -fstage1</kbd></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:2:15: </span><span class=t31_1>error: </span><span class=t0_1>operation caused overflow</span></span>
<span class=line>    const x = @shlExact(@as(u8, 0b01010101), 2);</span>
<span class=line>              <span class=t32_1>^</span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>u8</span> = <span class=tok-number>0b01010101</span>;</span>
<span class=line>    <span class=tok-kw>var</span> y = <span class=tok-builtin>@shlExact</span>(x, <span class=tok-number>2</span>);</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{y});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640181 panic: left shift overflowed bits</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:5:5</span>: <span class=t2_0>0x2101ca in main (test)</span></span>
<span class=line>    var y = @shlExact(x, 2);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f84b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f311 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Exact%20Right%20Shift%20Overflow class=dashAnchor></a><h3 id=Exact-Right-Shift-Overflow>Exact Right Shift Overflow</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x = <span class=tok-builtin>@shrExact</span>(<span class=tok-builtin>@as</span>(<span class=tok-type>u8</span>, <span class=tok-number>0b10101010</span>), <span class=tok-number>2</span>);</span>
<span class=line>    _ = x;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig -fstage1</kbd></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:2:15: </span><span class=t31_1>error: </span><span class=t0_1>exact shift shifted out 1 bits</span></span>
<span class=line>    const x = @shrExact(@as(u8, 0b10101010), 2);</span>
<span class=line>              <span class=t32_1>^</span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> x: <span class=tok-type>u8</span> = <span class=tok-number>0b10101010</span>;</span>
<span class=line>    <span class=tok-kw>var</span> y = <span class=tok-builtin>@shrExact</span>(x, <span class=tok-number>2</span>);</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{y});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640241 panic: right shift overflowed bits</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:5:5</span>: <span class=t2_0>0x2101c1 in main (test)</span></span>
<span class=line>    var y = @shrExact(x, 2);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f84b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f311 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Division%20by%20Zero class=dashAnchor></a><h3 id=Division-by-Zero>Division by Zero</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> a: <span class=tok-type>i32</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>const</span> b: <span class=tok-type>i32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>const</span> c = a / b;</span>
<span class=line>    _ = c;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:4:19: </span><span class=t31_1>error: </span><span class=t1_0>division by zero here causes undefined behavior</span>
<span class=line></span>    const c = a / b;</span>
<span class=line>                  <span class=t32_1>^</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u32</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>u32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>var</span> c = a / b;</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{c});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640302 panic: division by zero</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:6:5</span>: <span class=t2_0>0x2101ea in main (test)</span></span>
<span class=line>    var c = a / b;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f86b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f331 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Remainder%20Division%20by%20Zero class=dashAnchor></a><h3 id=Remainder-Division-by-Zero>Remainder Division by Zero</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> a: <span class=tok-type>i32</span> = <span class=tok-number>10</span>;</span>
<span class=line>    <span class=tok-kw>const</span> b: <span class=tok-type>i32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>const</span> c = a % b;</span>
<span class=line>    _ = c;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:4:19: </span><span class=t31_1>error: </span><span class=t1_0>division by zero here causes undefined behavior</span>
<span class=line></span>    const c = a % b;</span>
<span class=line>                  <span class=t32_1>^</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u32</span> = <span class=tok-number>10</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>u32</span> = <span class=tok-number>0</span>;</span>
<span class=line>    <span class=tok-kw>var</span> c = a % b;</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{c});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640362 panic: division by zero</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:6:5</span>: <span class=t2_0>0x2101ea in main (test)</span></span>
<span class=line>    var c = a % b;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f86b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f331 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Exact%20Division%20Remainder class=dashAnchor></a><h3 id=Exact-Division-Remainder>Exact Division Remainder</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> a: <span class=tok-type>u32</span> = <span class=tok-number>10</span>;</span>
<span class=line>    <span class=tok-kw>const</span> b: <span class=tok-type>u32</span> = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>const</span> c = <span class=tok-builtin>@divExact</span>(a, b);</span>
<span class=line>    _ = c;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig -fstage1</kbd></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:4:15: </span><span class=t31_1>error: </span><span class=t0_1>exact division had a remainder</span></span>
<span class=line>    const c = @divExact(a, b);</span>
<span class=line>              <span class=t32_1>^</span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u32</span> = <span class=tok-number>10</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>u32</span> = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>var</span> c = <span class=tok-builtin>@divExact</span>(a, b);</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{c});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640422 panic: exact division produced remainder</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:6:5</span>: <span class=t2_0>0x210259 in main (test)</span></span>
<span class=line>    var c = @divExact(a, b);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f89b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f361 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Attempt%20to%20Unwrap%20Null class=dashAnchor></a><h3 id=Attempt-to-Unwrap-Null>Attempt to Unwrap Null</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> optional_number: ?<span class=tok-type>i32</span> = <span class=tok-null>null</span>;</span>
<span class=line>    <span class=tok-kw>const</span> number = optional_number.?;</span>
<span class=line>    _ = number;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:3:35: </span><span class=t31_1>error: </span><span class=t1_0>unable to unwrap null</span>
<span class=line></span>    const number = optional_number.?;</span>
<span class=line>                   <span class=t32_1>~~~~~~~~~~~~~~~^~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> optional_number: ?<span class=tok-type>i32</span> = <span class=tok-null>null</span>;</span>
<span class=line>    <span class=tok-kw>var</span> number = optional_number.?;</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{number});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640482 panic: attempt to use null value</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:5:5</span>: <span class=t2_0>0x2102a5 in main (test)</span></span>
<span class=line>    var number = optional_number.?;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f92b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f3f1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <p>One way to avoid this crash is to test for null instead of assuming non-null, with the <code><span class=line><span class=tok-kw>if</span></span></code> expression:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> optional_number: ?<span class=tok-type>i32</span> = <span class=tok-null>null</span>;</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>if</span> (optional_number) |number| {</span>
<span class=line>        print(<span class=tok-str>"got number: {}\n"</span>, .{number});</span>
<span class=line>    } <span class=tok-kw>else</span> {</span>
<span class=line>        print(<span class=tok-str>"it's null\n"</span>, .{});</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>it's null</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Optionals>Optionals</a></li> </ul> <a name=//apple_ref/cpp/Guide/Attempt%20to%20Unwrap%20Error class=dashAnchor></a><h3 id=Attempt-to-Unwrap-Error>Attempt to Unwrap Error</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> number = getNumberOrFail() <span class=tok-kw>catch</span> <span class=tok-kw>unreachable</span>;</span>
<span class=line>    _ = number;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>getNumberOrFail</span>() !<span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>error</span>.UnableToReturnNumber;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:2:44: </span><span class=t31_1>error: </span><span class=t1_0>caught unexpected error 'UnableToReturnNumber'</span>
<span class=line></span>    const number = getNumberOrFail() catch unreachable;</span>
<span class=line>                                           <span class=t32_1>^~~~~~~~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> number = getNumberOrFail() <span class=tok-kw>catch</span> <span class=tok-kw>unreachable</span>;</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{number});</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>getNumberOrFail</span>() !<span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>error</span>.UnableToReturnNumber;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640577 panic: attempt to unwrap error: UnableToReturnNumber</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:9:5</span>: <span class=t2_0>0x211c5f in getNumberOrFail (test)</span></span>
<span class=line>    return error.UnableToReturnNumber;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:4:44</span>: <span class=t2_0>0x2102b1 in main (test)</span></span>
<span class=line>    const number = getNumberOrFail() catch unreachable;</span>
<span class=line>                                           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f92b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f3f1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <p>One way to avoid this crash is to test for an error instead of assuming a successful result, with the <code><span class=line><span class=tok-kw>if</span></span></code> expression:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> print = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).debug.print;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> result = getNumberOrFail();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>if</span> (result) |number| {</span>
<span class=line>        print(<span class=tok-str>"got number: {}\n"</span>, .{number});</span>
<span class=line>    } <span class=tok-kw>else</span> |err| {</span>
<span class=line>        print(<span class=tok-str>"got error: {s}\n"</span>, .{<span class=tok-builtin>@errorName</span>(err)});</span>
<span class=line>    }</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>getNumberOrFail</span>() !<span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>error</span>.UnableToReturnNumber;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>got error: UnableToReturnNumber</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Errors>Errors</a></li> </ul> <a name=//apple_ref/cpp/Guide/Invalid%20Error%20Code class=dashAnchor></a><h3 id=Invalid-Error-Code>Invalid Error Code</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> err = <span class=tok-kw>error</span>.AnError;</span>
<span class=line>    <span class=tok-kw>const</span> number = <span class=tok-builtin>@errorToInt</span>(err) + <span class=tok-number>10</span>;</span>
<span class=line>    <span class=tok-kw>const</span> invalid_err = <span class=tok-builtin>@intToError</span>(number);</span>
<span class=line>    _ = invalid_err;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:4:37: </span><span class=t31_1>error: </span><span class=t1_0>integer value '11' represents no error</span>
<span class=line></span>    const invalid_err = @intToError(number);</span>
<span class=line>                                    <span class=t32_1>^~~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> err = <span class=tok-kw>error</span>.AnError;</span>
<span class=line>    <span class=tok-kw>var</span> number = <span class=tok-builtin>@errorToInt</span>(err) + <span class=tok-number>500</span>;</span>
<span class=line>    <span class=tok-kw>var</span> invalid_err = <span class=tok-builtin>@intToError</span>(number);</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{invalid_err});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640673 panic: invalid error code</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:6:5</span>: <span class=t2_0>0x21016a in main (test)</span></span>
<span class=line>    var invalid_err = @intToError(number);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f7db in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f2a1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Invalid%20Enum%20Cast class=dashAnchor></a><h3 id=Invalid-Enum-Cast>Invalid Enum Cast</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>enum</span> {</span>
<span class=line>    a,</span>
<span class=line>    b,</span>
<span class=line>    c,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> a: <span class=tok-type>u2</span> = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>const</span> b = <span class=tok-builtin>@intToEnum</span>(Foo, a);</span>
<span class=line>    _ = b;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:8:15: </span><span class=t31_1>error: </span><span class=t1_0>enum 'test.Foo' has no tag with value '3'</span>
<span class=line></span>    const b = @intToEnum(Foo, a);</span>
<span class=line>              <span class=t32_1>^~~~~~~~~~~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:1:13: </span><span class=t36_1>note: </span><span class=t1_0>enum declared here</span>
<span class=line></span>const Foo = enum {</span>
<span class=line>            <span class=t32_1>^~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>enum</span> {</span>
<span class=line>    a,</span>
<span class=line>    b,</span>
<span class=line>    c,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>u2</span> = <span class=tok-number>3</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b = <span class=tok-builtin>@intToEnum</span>(Foo, a);</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {s}\n"</span>, .{<span class=tok-builtin>@tagName</span>(b)});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640733 panic: invalid enum value</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:11:5</span>: <span class=t2_0>0x2101a3 in main (test)</span></span>
<span class=line>    var b = @intToEnum(Foo, a);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f82b in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f2f1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Invalid%20Error%20Set%20Cast class=dashAnchor></a><h3 id=Invalid-Error-Set-Cast>Invalid Error Set Cast</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Set1 = <span class=tok-kw>error</span>{</span>
<span class=line>    A,</span>
<span class=line>    B,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> Set2 = <span class=tok-kw>error</span>{</span>
<span class=line>    A,</span>
<span class=line>    C,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    _ = <span class=tok-builtin>@errSetCast</span>(Set2, Set1.B);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:10:9: </span><span class=t31_1>error: </span><span class=t1_0>'error.B' not a member of error set 'error{A,C}'</span>
<span class=line></span>    _ = @errSetCast(Set2, Set1.B);</span>
<span class=line>        <span class=t32_1>^~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:5:14: </span><span class=t36_1>note: </span><span class=t1_0>error set declared here</span>
<span class=line></span>const Set2 = error{</span>
<span class=line>             <span class=t32_1>^~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Set1 = <span class=tok-kw>error</span>{</span>
<span class=line>    A,</span>
<span class=line>    B,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> Set2 = <span class=tok-kw>error</span>{</span>
<span class=line>    A,</span>
<span class=line>    C,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    foo(Set1.B);</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(set1: Set1) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> x = <span class=tok-builtin>@errSetCast</span>(Set2, set1);</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{x});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640793 panic: invalid error code</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:15:5</span>: <span class=t2_0>0x211b0d in foo (test)</span></span>
<span class=line>    const x = @errSetCast(Set2, set1);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:12:8</span>: <span class=t2_0>0x21013d in main (test)</span></span>
<span class=line>    foo(Set1.B);</span>
<span class=line>       <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f7fb in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f2c1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Incorrect%20Pointer%20Alignment class=dashAnchor></a><h3 id=Incorrect-Pointer-Alignment>Incorrect Pointer Alignment</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> ptr = <span class=tok-builtin>@intToPtr</span>(*<span class=tok-kw>align</span>(<span class=tok-number>1</span>) <span class=tok-type>i32</span>, <span class=tok-number>0x1</span>);</span>
<span class=line>    <span class=tok-kw>const</span> aligned = <span class=tok-builtin>@alignCast</span>(<span class=tok-number>4</span>, ptr);</span>
<span class=line>    _ = aligned;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:3:35: </span><span class=t31_1>error: </span><span class=t1_0>pointer address 0x1 is not aligned to 4 bytes</span>
<span class=line></span>    const aligned = @alignCast(4, ptr);</span>
<span class=line>                                  <span class=t32_1>^~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> mem = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).mem;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> array <span class=tok-kw>align</span>(<span class=tok-number>4</span>) = [_]<span class=tok-type>u32</span>{ <span class=tok-number>0x11111111</span>, <span class=tok-number>0x11111111</span> };</span>
<span class=line>    <span class=tok-kw>const</span> bytes = mem.sliceAsBytes(array[<span class=tok-number>0</span>..]);</span>
<span class=line>    <span class=tok-kw>if</span> (foo(bytes) != <span class=tok-number>0x11111111</span>) <span class=tok-kw>return</span> <span class=tok-kw>error</span>.Wrong;</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(bytes: []<span class=tok-type>u8</span>) <span class=tok-type>u32</span> {</span>
<span class=line>    <span class=tok-kw>const</span> slice4 = bytes[<span class=tok-number>1</span>..<span class=tok-number>5</span>];</span>
<span class=line>    <span class=tok-kw>const</span> int_slice = mem.bytesAsSlice(<span class=tok-type>u32</span>, <span class=tok-builtin>@alignCast</span>(<span class=tok-number>4</span>, slice4));</span>
<span class=line>    <span class=tok-kw>return</span> int_slice[<span class=tok-number>0</span>];</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640853 panic: incorrect alignment</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:9:39</span>: <span class=t2_0>0x20fdcf in foo (test)</span></span>
<span class=line>    const int_slice = mem.bytesAsSlice(u32, @alignCast(4, slice4));</span>
<span class=line>                                      <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:5:12</span>: <span class=t2_0>0x20fd17 in main (test)</span></span>
<span class=line>    if (foo(bytes) != 0x11111111) return error.Wrong;</span>
<span class=line>           <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:606:37</span>: <span class=t2_0>0x20f850 in posixCallMainAndExit (test)</span></span>
<span class=line>            const result = root.main() catch |err| {</span>
<span class=line>                                    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f2c1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Wrong%20Union%20Field%20Access class=dashAnchor></a><h3 id=Wrong-Union-Field-Access>Wrong Union Field Access</h3> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>var</span> f = Foo{ .int = <span class=tok-number>42</span> };</span>
<span class=line>    f.float = <span class=tok-number>12.34</span>;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>union</span> {</span>
<span class=line>    float: <span class=tok-type>f32</span>,</span>
<span class=line>    int: <span class=tok-type>u32</span>,</span>
<span class=line>};</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:3:6: </span><span class=t31_1>error: </span><span class=t1_0>access of union field 'float' while field 'int' is active</span>
<span class=line></span>    f.float = 12.34;</span>
<span class=line>    <span class=t32_1>~^~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:6:13: </span><span class=t36_1>note: </span><span class=t1_0>union declared here</span>
<span class=line></span>const Foo = union {</span>
<span class=line>            <span class=t32_1>^~~~~</span>
<span class=line></span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>union</span> {</span>
<span class=line>    float: <span class=tok-type>f32</span>,</span>
<span class=line>    int: <span class=tok-type>u32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> f = Foo{ .int = <span class=tok-number>42</span> };</span>
<span class=line>    bar(&amp;f);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bar</span>(f: *Foo) <span class=tok-type>void</span> {</span>
<span class=line>    f.float = <span class=tok-number>12.34</span>;</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{f.float});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1640913 panic: access of inactive union field</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:14:5</span>: <span class=t2_0>0x2276f4 in bar (test)</span></span>
<span class=line>    f.float = 12.34;</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:10:8</span>: <span class=t2_0>0x225d2c in main (test)</span></span>
<span class=line>    bar(&amp;f);</span>
<span class=line>       <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x2253db in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x224ea1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <p> This safety is not available for <code><span class=line><span class=tok-kw>extern</span></span></code> or <code><span class=line><span class=tok-kw>packed</span></span></code> unions. </p> <p> To change the active field of a union, assign the entire union, like this: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>union</span> {</span>
<span class=line>    float: <span class=tok-type>f32</span>,</span>
<span class=line>    int: <span class=tok-type>u32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> f = Foo{ .int = <span class=tok-number>42</span> };</span>
<span class=line>    bar(&amp;f);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bar</span>(f: *Foo) <span class=tok-type>void</span> {</span>
<span class=line>    f.* = Foo{ .float = <span class=tok-number>12.34</span> };</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{f.float});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>value: 1.23400001e+01</span>
</samp></pre></figure> <p> To change the active field of a union when a meaningful value for the field is not known, use <a href="#undefined">undefined</a>, like this: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> Foo = <span class=tok-kw>union</span> {</span>
<span class=line>    float: <span class=tok-type>f32</span>,</span>
<span class=line>    int: <span class=tok-type>u32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> f = Foo{ .int = <span class=tok-number>42</span> };</span>
<span class=line>    f = Foo{ .float = <span class=tok-null>undefined</span> };</span>
<span class=line>    bar(&amp;f);</span>
<span class=line>    std.debug.print(<span class=tok-str>"value: {}\n"</span>, .{f.float});</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>bar</span>(f: *Foo) <span class=tok-type>void</span> {</span>
<span class=line>    f.float = <span class=tok-number>12.34</span>;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>value: 1.23400001e+01</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#union>union</a></li> <li><a href=#extern-union>extern union</a></li> </ul> <a name=//apple_ref/cpp/Guide/Out%20of%20Bounds%20Float%20to%20Integer%20Cast class=dashAnchor></a><h3 id=Out-of-Bounds-Float-to-Integer-Cast>Out of Bounds Float to Integer Cast</h3> <p>TODO</p> <a name=//apple_ref/cpp/Guide/Pointer%20Cast%20Invalid%20Null class=dashAnchor></a><h3 id=Pointer-Cast-Invalid-Null>Pointer Cast Invalid Null</h3> <p> This happens when casting a pointer with the address 0 to a pointer which may not have the address 0. For example, <a href=#C-Pointers>C Pointers</a>, <a href=#Optional-Pointers>Optional Pointers</a>, and <a href=#allowzero>allowzero</a> pointers allow address zero, but normal <a href=#Pointers>Pointers</a> do not. </p> <p>At compile-time:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>comptime</span> {</span>
<span class=line>    <span class=tok-kw>const</span> opt_ptr: ?*<span class=tok-type>i32</span> = <span class=tok-null>null</span>;</span>
<span class=line>    <span class=tok-kw>const</span> ptr = <span class=tok-builtin>@ptrCast</span>(*<span class=tok-type>i32</span>, opt_ptr);</span>
<span class=line>    _ = ptr;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig -fstage1</kbd></span>
<span class=line><span class=t0_1>./docgen_tmp/test.zig:3:17: </span><span class=t31_1>error: </span><span class=t0_1>null pointer casted to type '*i32'</span></span>
<span class=line>    const ptr = @ptrCast(*i32, opt_ptr);</span>
<span class=line>                <span class=t32_1>^</span></span>
</samp></pre></figure> <p>At runtime:</p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> opt_ptr: ?*<span class=tok-type>i32</span> = <span class=tok-null>null</span>;</span>
<span class=line>    <span class=tok-kw>var</span> ptr = <span class=tok-builtin>@ptrCast</span>(*<span class=tok-type>i32</span>, opt_ptr);</span>
<span class=line>    _ = ptr;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>thread 1641043 panic: cast causes pointer to be null</span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:3:5</span>: <span class=t2_0>0x210061 in main (test)</span></span>
<span class=line>    var ptr = @ptrCast(*i32, opt_ptr);</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:596:22</span>: <span class=t2_0>0x20f6eb in posixCallMainAndExit (test)</span></span>
<span class=line>            root.main();</span>
<span class=line>                     <span class=t32_1>^</span></span>
<span class=line><span class=t1_0>/home/andy/tmp/zig/lib/std/start.zig:368:5</span>: <span class=t2_0>0x20f1b1 in _start (test)</span></span>
<span class=line>    @call(.{ .modifier = .never_inline }, posixCallMainAndExit, .{});</span>
<span class=line>    <span class=t32_1>^</span></span>
<span class=line>(process terminated by signal)</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Memory class=dashAnchor></a><h2 id=Memory>Memory</h2> <p> The Zig language performs no memory management on behalf of the programmer. This is why Zig has no runtime, and why Zig code works seamlessly in so many environments, including real-time software, operating system kernels, embedded devices, and low latency servers. As a consequence, Zig programmers must always be able to answer the question: </p> <p><a href=#Where-are-the-bytes>Where are the bytes?</a></p> <p> Like Zig, the C programming language has manual memory management. However, unlike Zig, C has a default allocator - <code>malloc</code>, <code>realloc</code>, and <code>free</code>. When linking against libc, Zig exposes this allocator with <code><span class=line>std.heap.c_allocator</span></code>. However, by convention, there is no default allocator in Zig. Instead, functions which need to allocate accept an <code><span class=line>Allocator</span></code> parameter. Likewise, data structures such as <code><span class=line>std.ArrayList</span></code> accept an <code><span class=line>Allocator</span></code> parameter in their initialization functions: </p> <figure><figcaption class=zig-cap><cite class=file>allocator.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> Allocator = std.mem.Allocator;</span>
<span class=line><span class=tok-kw>const</span> expect = std.testing.expect;</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"using an allocator"</span> {</span>
<span class=line>    <span class=tok-kw>var</span> buffer: [<span class=tok-number>100</span>]<span class=tok-type>u8</span> = <span class=tok-null>undefined</span>;</span>
<span class=line>    <span class=tok-kw>var</span> fba = std.heap.FixedBufferAllocator.init(&amp;buffer);</span>
<span class=line>    <span class=tok-kw>const</span> allocator = fba.allocator();</span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>try</span> concat(allocator, <span class=tok-str>"foo"</span>, <span class=tok-str>"bar"</span>);</span>
<span class=line>    <span class=tok-kw>try</span> expect(std.mem.eql(<span class=tok-type>u8</span>, <span class=tok-str>"foobar"</span>, result));</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>concat</span>(allocator: Allocator, a: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>, b: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) ![]<span class=tok-type>u8</span> {</span>
<span class=line>    <span class=tok-kw>const</span> result = <span class=tok-kw>try</span> allocator.alloc(<span class=tok-type>u8</span>, a.len + b.len);</span>
<span class=line>    std.mem.copy(<span class=tok-type>u8</span>, result, a);</span>
<span class=line>    std.mem.copy(<span class=tok-type>u8</span>, result[a.len..], b);</span>
<span class=line>    <span class=tok-kw>return</span> result;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test allocator.zig</kbd></span>
<span class=line>1/1 test.using an allocator... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> In the above example, 100 bytes of stack memory are used to initialize a <code><span class=line>FixedBufferAllocator</span></code>, which is then passed to a function. As a convenience there is a global <code><span class=line>FixedBufferAllocator</span></code> available for quick tests at <code><span class=line>std.testing.allocator</span></code>, which will also perform basic leak detection. </p> <p> Zig has a general purpose allocator available to be imported with <code><span class=line>std.heap.GeneralPurposeAllocator</span></code>. However, it is still recommended to follow the <a href=#Choosing-an-Allocator>Choosing an Allocator</a> guide. </p> <a name=//apple_ref/cpp/Guide/Choosing%20an%20Allocator class=dashAnchor></a><h3 id=Choosing-an-Allocator>Choosing an Allocator</h3> <p>What allocator to use depends on a number of factors. Here is a flow chart to help you decide: </p> <ol> <li> Are you making a library? In this case, best to accept an <code><span class=line>Allocator</span></code> as a parameter and allow your library's users to decide what allocator to use. </li> <li>Are you linking libc? In this case, <code><span class=line>std.heap.c_allocator</span></code> is likely the right choice, at least for your main allocator.</li> <li> Is the maximum number of bytes that you will need bounded by a number known at <a href=#comptime>comptime</a>? In this case, use <code><span class=line>std.heap.FixedBufferAllocator</span></code> or <code><span class=line>std.heap.ThreadSafeFixedBufferAllocator</span></code> depending on whether you need thread-safety or not. </li> <li> Is your program a command line application which runs from start to end without any fundamental cyclical pattern (such as a video game main loop, or a web server request handler), such that it would make sense to free everything at once at the end? In this case, it is recommended to follow this pattern: <figure><figcaption class=zig-cap><cite class=file>cli_allocation.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);</span>
<span class=line>    <span class=tok-kw>defer</span> arena.deinit();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> allocator = arena.allocator();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> ptr = <span class=tok-kw>try</span> allocator.create(<span class=tok-type>i32</span>);</span>
<span class=line>    std.debug.print(<span class=tok-str>"ptr={*}\n"</span>, .{ptr});</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe cli_allocation.zig</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./cli_allocation</kbd></span>
<span class=line>ptr=i32@7f194545d018</span>
</samp></pre></figure> When using this kind of allocator, there is no need to free anything manually. Everything gets freed at once with the call to <code><span class=line>arena.deinit()</span></code>. </li> <li> Are the allocations part of a cyclical pattern such as a video game main loop, or a web server request handler? If the allocations can all be freed at once, at the end of the cycle, for example once the video game frame has been fully rendered, or the web server request has been served, then <code><span class=line>std.heap.ArenaAllocator</span></code> is a great candidate. As demonstrated in the previous bullet point, this allows you to free entire arenas at once. Note also that if an upper bound of memory can be established, then <code><span class=line>std.heap.FixedBufferAllocator</span></code> can be used as a further optimization. </li> <li> Are you writing a test, and you want to make sure <code><span class=line><span class=tok-kw>error</span>.OutOfMemory</span></code> is handled correctly? In this case, use <code><span class=line>std.testing.FailingAllocator</span></code>. </li> <li> Are you writing a test? In this case, use <code><span class=line>std.testing.allocator</span></code>. </li> <li> Finally, if none of the above apply, you need a general purpose allocator. Zig's general purpose allocator is available as a function that takes a <a href=#comptime>comptime</a> <a href=#struct>struct</a> of configuration options and returns a type. Generally, you will set up one <code><span class=line>std.heap.GeneralPurposeAllocator</span></code> in your main function, and then pass it or sub-allocators around to various parts of your application. </li> <li> You can also consider <a href=#Implementing-an-Allocator>Implementing an Allocator</a>. </li> </ol> <a name=//apple_ref/cpp/Guide/Where%20are%20the%20bytes%3F class=dashAnchor></a><h3 id=Where-are-the-bytes>Where are the bytes?</h3> <p>String literals such as <code><span class=line><span class=tok-str>"foo"</span></span></code> are in the global constant data section. This is why it is an error to pass a string literal to a mutable slice, like this: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(s: []<span class=tok-type>u8</span>) <span class=tok-type>void</span> {</span>
<span class=line>    _ = s;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"string literal to mutable slice"</span> {</span>
<span class=line>    foo(<span class=tok-str>"hello"</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test test.zig</kbd></span>
<span class=line><span class=t1_0>docgen_tmp/test.zig:6:9: </span><span class=t31_1>error: </span><span class=t1_0>expected type '[]u8', found '*const [5:0]u8'</span>
<span class=line></span>    foo("hello");</span>
<span class=line>        <span class=t32_1>^~~~~~~</span>
<span class=line></span><span class=t1_0>docgen_tmp/test.zig:6:9: </span><span class=t36_1>note: </span><span class=t1_0>cast discards const qualifier</span>
<span class=line></span></span>
</samp></pre></figure> <p>However if you make the slice constant, then it works:</p> <figure><figcaption class=zig-cap><cite class=file>strlit.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>fn</span> <span class=tok-fn>foo</span>(s: []<span class=tok-kw>const</span> <span class=tok-type>u8</span>) <span class=tok-type>void</span> {</span>
<span class=line>    _ = s;</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>test</span> <span class=tok-str>"string literal to constant slice"</span> {</span>
<span class=line>    foo(<span class=tok-str>"hello"</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig test strlit.zig</kbd></span>
<span class=line>1/1 test.string literal to constant slice... OK</span>
<span class=line>All 1 tests passed.</span>
</samp></pre></figure> <p> Just like string literals, <code><span class=line><span class=tok-kw>const</span></span></code> declarations, when the value is known at <a href=#comptime>comptime</a>, are stored in the global constant data section. Also <a href=#Compile-Time-Variables>Compile Time Variables</a> are stored in the global constant data section. </p> <p> <code><span class=line><span class=tok-kw>var</span></span></code> declarations inside functions are stored in the function's stack frame. Once a function returns, any <a href=#Pointers>Pointers</a> to variables in the function's stack frame become invalid references, and dereferencing them becomes unchecked <a href=#Undefined-Behavior>Undefined Behavior</a>. </p> <p> <code><span class=line><span class=tok-kw>var</span></span></code> declarations at the top level or in <a href=#struct>struct</a> declarations are stored in the global data section. </p> <p> The location of memory allocated with <code><span class=line>allocator.alloc</span></code> or <code><span class=line>allocator.create</span></code> is determined by the allocator's implementation. </p> <p>TODO: thread local variables</p> <a name=//apple_ref/cpp/Guide/Implementing%20an%20Allocator class=dashAnchor></a><h3 id=Implementing-an-Allocator>Implementing an Allocator</h3> <p>Zig programmers can implement their own allocators by fulfilling the Allocator interface. In order to do this one must read carefully the documentation comments in std/mem.zig and then supply a <code><span class=line>allocFn</span></code> and a <code><span class=line>resizeFn</span></code>. </p> <p> There are many example allocators to look at for inspiration. Look at std/heap.zig and <code><span class=line>std.heap.GeneralPurposeAllocator</span></code>. </p> <a name=//apple_ref/cpp/Guide/Heap%20Allocation%20Failure class=dashAnchor></a><h3 id=Heap-Allocation-Failure>Heap Allocation Failure</h3> <p> Many programming languages choose to handle the possibility of heap allocation failure by unconditionally crashing. By convention, Zig programmers do not consider this to be a satisfactory solution. Instead, <code><span class=line><span class=tok-kw>error</span>.OutOfMemory</span></code> represents heap allocation failure, and Zig libraries return this error code whenever heap allocation failure prevented an operation from completing successfully. </p> <p> Some have argued that because some operating systems such as Linux have memory overcommit enabled by default, it is pointless to handle heap allocation failure. There are many problems with this reasoning: </p> <ul> <li>Only some operating systems have an overcommit feature. <ul> <li>Linux has it enabled by default, but it is configurable.</li> <li>Windows does not overcommit.</li> <li>Embedded systems do not have overcommit.</li> <li>Hobby operating systems may or may not have overcommit.</li> </ul> </li> <li> For real-time systems, not only is there no overcommit, but typically the maximum amount of memory per application is determined ahead of time. </li> <li> When writing a library, one of the main goals is code reuse. By making code handle allocation failure correctly, a library becomes eligible to be reused in more contexts. </li> <li> Although some software has grown to depend on overcommit being enabled, its existence is the source of countless user experience disasters. When a system with overcommit enabled, such as Linux on default settings, comes close to memory exhaustion, the system locks up and becomes unusable. At this point, the OOM Killer selects an application to kill based on heuristics. This non-deterministic decision often results in an important process being killed, and often fails to return the system back to working order. </li> </ul> <a name=//apple_ref/cpp/Guide/Recursion class=dashAnchor></a><h3 id=Recursion>Recursion</h3> <p> Recursion is a fundamental tool in modeling software. However it has an often-overlooked problem: unbounded memory allocation. </p> <p> Recursion is an area of active experimentation in Zig and so the documentation here is not final. You can read a <a href=https://ziglang.org/download/0.3.0/release-notes.html#recursion>summary of recursion status in the 0.3.0 release notes</a>. </p> <p> The short summary is that currently recursion works normally as you would expect. Although Zig code is not yet protected from stack overflow, it is planned that a future version of Zig will provide such protection, with some degree of cooperation from Zig code required. </p> <a name=//apple_ref/cpp/Guide/Lifetime%20and%20Ownership class=dashAnchor></a><h3 id=Lifetime-and-Ownership>Lifetime and Ownership</h3> <p> It is the Zig programmer's responsibility to ensure that a <a href=#Pointers>pointer</a> is not accessed when the memory pointed to is no longer available. Note that a <a href=#Slices>slice</a> is a form of pointer, in that it references other memory. </p> <p> In order to prevent bugs, there are some helpful conventions to follow when dealing with pointers. In general, when a function returns a pointer, the documentation for the function should explain who "owns" the pointer. This concept helps the programmer decide when it is appropriate, if ever, to free the pointer. </p> <p> For example, the function's documentation may say "caller owns the returned memory", in which case the code that calls the function must have a plan for when to free that memory. Probably in this situation, the function will accept an <code><span class=line>Allocator</span></code> parameter. </p> <p> Sometimes the lifetime of a pointer may be more complicated. For example, the <code><span class=line>std.ArrayList(T).items</span></code> slice has a lifetime that remains valid until the next time the list is resized, such as by appending new elements. </p> <p> The API documentation for functions and data structures should take great care to explain the ownership and lifetime semantics of pointers. Ownership determines whose responsibility it is to free the memory referenced by the pointer, and lifetime determines the point at which the memory becomes inaccessible (lest <a href=#Undefined-Behavior>Undefined Behavior</a> occur). </p> <a name=//apple_ref/cpp/Guide/Compile%20Variables class=dashAnchor></a><h2 id=Compile-Variables>Compile Variables</h2> <p> Compile variables are accessible by importing the <code><span class=line><span class=tok-str>"builtin"</span></span></code> package, which the compiler makes available to every Zig source file. It contains compile-time constants such as the current target, endianness, and release mode. </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> builtin = <span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>);</span>
<span class=line><span class=tok-kw>const</span> separator = <span class=tok-kw>if</span> (builtin.os.tag == .windows) <span class=tok-str>'\\'</span> <span class=tok-kw>else</span> <span class=tok-str>'/'</span>;</span></code></pre></figure> <p> Example of what is imported with <code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>)</span></code>: </p> <figure><figcaption class=zig-cap><cite>@import("builtin")</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-comment>/// Zig version. When writing code that supports multiple versions of Zig, prefer</span></span>
<span class=line><span class=tok-comment>/// feature detection (i.e. with `@hasDecl` or `@hasField`) over version checks.</span></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> zig_version = std.SemanticVersion.parse(<span class=tok-str>"0.10.0"</span>) <span class=tok-kw>catch</span> <span class=tok-kw>unreachable</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> zig_backend = std.builtin.CompilerBackend.stage2_x86_64;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> output_mode = std.builtin.OutputMode.Obj;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> link_mode = std.builtin.LinkMode.Static;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> is_test = <span class=tok-null>false</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> single_threaded = <span class=tok-null>false</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> abi = std.Target.Abi.gnu;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> cpu: std.Target.Cpu = .{</span>
<span class=line>    .arch = .x86_64,</span>
<span class=line>    .model = &amp;std.Target.x86.cpu.skylake,</span>
<span class=line>    .features = std.Target.x86.featureSet(&amp;[_]std.Target.x86.Feature{</span>
<span class=line>        .@"64bit",</span>
<span class=line>        .adx,</span>
<span class=line>        .aes,</span>
<span class=line>        .avx,</span>
<span class=line>        .avx2,</span>
<span class=line>        .bmi,</span>
<span class=line>        .bmi2,</span>
<span class=line>        .clflushopt,</span>
<span class=line>        .cmov,</span>
<span class=line>        .crc32,</span>
<span class=line>        .cx16,</span>
<span class=line>        .cx8,</span>
<span class=line>        .ermsb,</span>
<span class=line>        .f16c,</span>
<span class=line>        .false_deps_popcnt,</span>
<span class=line>        .fast_15bytenop,</span>
<span class=line>        .fast_gather,</span>
<span class=line>        .fast_scalar_fsqrt,</span>
<span class=line>        .fast_shld_rotate,</span>
<span class=line>        .fast_variable_crosslane_shuffle,</span>
<span class=line>        .fast_variable_perlane_shuffle,</span>
<span class=line>        .fast_vector_fsqrt,</span>
<span class=line>        .fma,</span>
<span class=line>        .fsgsbase,</span>
<span class=line>        .fxsr,</span>
<span class=line>        .idivq_to_divl,</span>
<span class=line>        .invpcid,</span>
<span class=line>        .lzcnt,</span>
<span class=line>        .macrofusion,</span>
<span class=line>        .mmx,</span>
<span class=line>        .movbe,</span>
<span class=line>        .nopl,</span>
<span class=line>        .pclmul,</span>
<span class=line>        .popcnt,</span>
<span class=line>        .prfchw,</span>
<span class=line>        .rdrnd,</span>
<span class=line>        .rdseed,</span>
<span class=line>        .sahf,</span>
<span class=line>        .sgx,</span>
<span class=line>        .slow_3ops_lea,</span>
<span class=line>        .sse,</span>
<span class=line>        .sse2,</span>
<span class=line>        .sse3,</span>
<span class=line>        .sse4_1,</span>
<span class=line>        .sse4_2,</span>
<span class=line>        .ssse3,</span>
<span class=line>        .vzeroupper,</span>
<span class=line>        .x87,</span>
<span class=line>        .xsave,</span>
<span class=line>        .xsavec,</span>
<span class=line>        .xsaveopt,</span>
<span class=line>        .xsaves,</span>
<span class=line>    }),</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> os = std.Target.Os{</span>
<span class=line>    .tag = .linux,</span>
<span class=line>    .version_range = .{ .linux = .{</span>
<span class=line>        .range = .{</span>
<span class=line>            .min = .{</span>
<span class=line>                .major = <span class=tok-number>5</span>,</span>
<span class=line>                .minor = <span class=tok-number>15</span>,</span>
<span class=line>                .patch = <span class=tok-number>63</span>,</span>
<span class=line>            },</span>
<span class=line>            .max = .{</span>
<span class=line>                .major = <span class=tok-number>5</span>,</span>
<span class=line>                .minor = <span class=tok-number>15</span>,</span>
<span class=line>                .patch = <span class=tok-number>63</span>,</span>
<span class=line>            },</span>
<span class=line>        },</span>
<span class=line>        .glibc = .{</span>
<span class=line>            .major = <span class=tok-number>2</span>,</span>
<span class=line>            .minor = <span class=tok-number>34</span>,</span>
<span class=line>            .patch = <span class=tok-number>0</span>,</span>
<span class=line>        },</span>
<span class=line>    }},</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> target = std.Target{</span>
<span class=line>    .cpu = cpu,</span>
<span class=line>    .os = os,</span>
<span class=line>    .abi = abi,</span>
<span class=line>    .ofmt = object_format,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> object_format = std.Target.ObjectFormat.elf;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> mode = std.builtin.Mode.Debug;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> link_libc = <span class=tok-null>false</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> link_libcpp = <span class=tok-null>false</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> have_error_return_tracing = <span class=tok-null>true</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> valgrind_support = <span class=tok-null>true</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> sanitize_thread = <span class=tok-null>false</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> position_independent_code = <span class=tok-null>false</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> position_independent_executable = <span class=tok-null>false</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> strip_debug_info = <span class=tok-null>false</span>;</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> code_model = std.builtin.CodeModel.default;</span></code></pre></figure> <p>See also:</p><ul> <li><a href=#Build-Mode>Build Mode</a></li> </ul> <a name=//apple_ref/cpp/Guide/Root%20Source%20File class=dashAnchor></a><h2 id=Root-Source-File>Root Source File</h2> <p>TODO: explain how root source file finds other files</p> <p>TODO: pub fn main</p> <p>TODO: pub fn panic</p> <p>TODO: if linking with libc you can use export fn main</p> <p>TODO: order independent top level declarations</p> <p>TODO: lazy analysis</p> <p>TODO: using comptime { _ = @import() }</p> <a name=//apple_ref/cpp/Guide/Zig%20Build%20System class=dashAnchor></a><h2 id=Zig-Build-System>Zig Build System</h2> <p> The Zig Build System provides a cross-platform, dependency-free way to declare the logic required to build a project. With this system, the logic to build a project is written in a build.zig file, using the Zig Build System API to declare and configure build artifacts and other tasks. </p> <p> Some examples of tasks the build system can help with: </p> <ul> <li>Creating build artifacts by executing the Zig compiler. This includes building Zig source code as well as C and C++ source code.</li> <li>Capturing user-configured options and using those options to configure the build.</li> <li>Surfacing build configuration as <a href=#comptime>comptime</a> values by providing a file that can be <a href=#import>imported</a> by Zig code.</li> <li>Caching build artifacts to avoid unnecessarily repeating steps.</li> <li>Executing build artifacts or system-installed tools.</li> <li>Running tests and verifying the output of executing a build artifact matches the expected value.</li> <li>Running <code>zig fmt</code> on a codebase or a subset of it.</li> <li>Custom tasks.</li> </ul> <p> To use the build system, run <kbd>zig build --help</kbd> to see a command-line usage help menu. This will include project-specific options that were declared in the build.zig script. </p> <a name=//apple_ref/cpp/Guide/Building%20an%20Executable class=dashAnchor></a><h3 id=Building-an-Executable>Building an Executable</h3> <p>This <code class=file>build.zig</code> file is automatically generated by <kbd>zig init-exe</kbd>.</p> <figure><figcaption class=zig-cap><cite class=file>build.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Builder = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).build.Builder;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>build</span>(b: *Builder) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-comment>// Standard target options allows the person running `zig build` to choose</span></span>
<span class=line>    <span class=tok-comment>// what target to build for. Here we do not override the defaults, which</span></span>
<span class=line>    <span class=tok-comment>// means any target is allowed, and the default is native. Other options</span></span>
<span class=line>    <span class=tok-comment>// for restricting supported target set are available.</span></span>
<span class=line>    <span class=tok-kw>const</span> target = b.standardTargetOptions(.{});</span>
<span class=line></span>
<span class=line>    <span class=tok-comment>// Standard release options allow the person running `zig build` to select</span></span>
<span class=line>    <span class=tok-comment>// between Debug, ReleaseSafe, ReleaseFast, and ReleaseSmall.</span></span>
<span class=line>    <span class=tok-kw>const</span> mode = b.standardReleaseOptions();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> exe = b.addExecutable(<span class=tok-str>"example"</span>, <span class=tok-str>"src/main.zig"</span>);</span>
<span class=line>    exe.setTarget(target);</span>
<span class=line>    exe.setBuildMode(mode);</span>
<span class=line>    exe.install();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> run_cmd = exe.run();</span>
<span class=line>    run_cmd.step.dependOn(b.getInstallStep());</span>
<span class=line>    <span class=tok-kw>if</span> (b.args) |args| {</span>
<span class=line>        run_cmd.addArgs(args);</span>
<span class=line>    }</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> run_step = b.step(<span class=tok-str>"run"</span>, <span class=tok-str>"Run the app"</span>);</span>
<span class=line>    run_step.dependOn(&amp;run_cmd.step);</span>
<span class=line>}</span></code></pre></figure> <a name=//apple_ref/cpp/Guide/Building%20a%20Library class=dashAnchor></a><h3 id=Building-a-Library>Building a Library</h3> <p>This <code class=file>build.zig</code> file is automatically generated by <kbd>zig init-lib</kbd>.</p> <figure><figcaption class=zig-cap><cite class=file>build.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Builder = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).build.Builder;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>build</span>(b: *Builder) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> mode = b.standardReleaseOptions();</span>
<span class=line>    <span class=tok-kw>const</span> lib = b.addStaticLibrary(<span class=tok-str>"example"</span>, <span class=tok-str>"src/main.zig"</span>);</span>
<span class=line>    lib.setBuildMode(mode);</span>
<span class=line>    lib.install();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> main_tests = b.addTest(<span class=tok-str>"src/main.zig"</span>);</span>
<span class=line>    main_tests.setBuildMode(mode);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> test_step = b.step(<span class=tok-str>"test"</span>, <span class=tok-str>"Run library tests"</span>);</span>
<span class=line>    test_step.dependOn(&amp;main_tests.step);</span>
<span class=line>}</span></code></pre></figure> <a name=//apple_ref/cpp/Guide/Compiling%20C%20Source%20Code class=dashAnchor></a><h3 id=Compiling-C-Source-Code>Compiling C Source Code</h3> <pre><code><span class=line>lib.addCSourceFile(<span class=tok-str>"src/lib.c"</span>, &amp;[_][]<span class=tok-kw>const</span> <span class=tok-type>u8</span>{</span>
<span class=line>    <span class=tok-str>"-Wall"</span>,</span>
<span class=line>    <span class=tok-str>"-Wextra"</span>,</span>
<span class=line>    <span class=tok-str>"-Werror"</span>,</span>
<span class=line>});</span></code></pre> <a name=//apple_ref/cpp/Guide/C class=dashAnchor></a><h2 id=C>C</h2> <p> Although Zig is independent of C, and, unlike most other languages, does not depend on libc, Zig acknowledges the importance of interacting with existing C code. </p> <p> There are a few ways that Zig facilitates C interop. </p> <a name=//apple_ref/cpp/Guide/C%20Type%20Primitives class=dashAnchor></a><h3 id=C-Type-Primitives>C Type Primitives</h3> <p> These have guaranteed C ABI compatibility and can be used like any other type. </p> <ul> <li><code><span class=line><span class=tok-type>c_short</span></span></code></li> <li><code><span class=line><span class=tok-type>c_ushort</span></span></code></li> <li><code><span class=line><span class=tok-type>c_int</span></span></code></li> <li><code><span class=line><span class=tok-type>c_uint</span></span></code></li> <li><code><span class=line><span class=tok-type>c_long</span></span></code></li> <li><code><span class=line><span class=tok-type>c_ulong</span></span></code></li> <li><code><span class=line><span class=tok-type>c_longlong</span></span></code></li> <li><code><span class=line><span class=tok-type>c_ulonglong</span></span></code></li> <li><code><span class=line><span class=tok-type>c_longdouble</span></span></code></li> </ul> <p> To interop with the C <code><span class=line><span class=tok-type>void</span></span></code> type, use <code><span class=line><span class=tok-type>anyopaque</span></span></code>. </p> <p>See also:</p><ul> <li><a href=#Primitive-Types>Primitive Types</a></li> </ul> <a name=//apple_ref/cpp/Guide/Import%20from%20C%20Header%20File class=dashAnchor></a><h3 id=Import-from-C-Header-File>Import from C Header File</h3> <p> The <code><span class=line><span class=tok-builtin>@cImport</span></span></code> builtin function can be used to directly import symbols from <code class=file>.h</code> files: </p> <figure><figcaption class=zig-cap><cite class=file>test.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> c = <span class=tok-builtin>@cImport</span>({</span>
<span class=line>    <span class=tok-comment>// See https://github.com/ziglang/zig/issues/515</span></span>
<span class=line>    <span class=tok-builtin>@cDefine</span>(<span class=tok-str>"_NO_CRT_STDIO_INLINE"</span>, <span class=tok-str>"1"</span>);</span>
<span class=line>    <span class=tok-builtin>@cInclude</span>(<span class=tok-str>"stdio.h"</span>);</span>
<span class=line>});</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    _ = c.printf(<span class=tok-str>"hello\n"</span>);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe test.zig -lc</kbd></span>
<span class=line></span>
<span class=line>$ <kbd>./test</kbd></span>
<span class=line>hello</span>
</samp></pre></figure> <p> The <code><span class=line><span class=tok-builtin>@cImport</span></span></code> function takes an expression as a parameter. This expression is evaluated at compile-time and is used to control preprocessor directives and include multiple <code class=file>.h</code> files: </p> <figure><figcaption class=zig-cap><cite class=file>@cImport Expression</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> builtin = <span class=tok-builtin>@import</span>(<span class=tok-str>"builtin"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> c = <span class=tok-builtin>@cImport</span>({</span>
<span class=line>    <span class=tok-builtin>@cDefine</span>(<span class=tok-str>"NDEBUG"</span>, builtin.mode == .ReleaseFast);</span>
<span class=line>    <span class=tok-kw>if</span> (something) {</span>
<span class=line>        <span class=tok-builtin>@cDefine</span>(<span class=tok-str>"_GNU_SOURCE"</span>, {});</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-builtin>@cInclude</span>(<span class=tok-str>"stdlib.h"</span>);</span>
<span class=line>    <span class=tok-kw>if</span> (something) {</span>
<span class=line>        <span class=tok-builtin>@cUndef</span>(<span class=tok-str>"_GNU_SOURCE"</span>);</span>
<span class=line>    }</span>
<span class=line>    <span class=tok-builtin>@cInclude</span>(<span class=tok-str>"soundio.h"</span>);</span>
<span class=line>});</span></code></pre></figure> <p>See also:</p><ul> <li><a href=#cImport>@cImport</a></li> <li><a href=#cInclude>@cInclude</a></li> <li><a href=#cDefine>@cDefine</a></li> <li><a href=#cUndef>@cUndef</a></li> <li><a href=#import>@import</a></li> </ul> <a name=//apple_ref/cpp/Guide/C%20Translation%20CLI class=dashAnchor></a><h3 id=C-Translation-CLI>C Translation CLI</h3> Zig's C translation capability is available as a CLI tool via <kbd>zig translate-c</kbd>. It requires a single filename as an argument. It may also take a set of optional flags that are forwarded to clang. It writes the translated file to stdout. <a name=//apple_ref/cpp/Guide/Command%20line%20flags class=dashAnchor></a><h4 id=Command-line-flags>Command line flags</h4> <ul> <li> <kbd>-I</kbd>: Specify a search directory for include files. May be used multiple times. Equivalent to <a href=https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-i-dir> clang's <kbd>-I</kbd> flag</a>. The current directory is <em>not</em> included by default; use <kbd>-I.</kbd> to include it. </li> <li> <kbd>-D</kbd>: Define a preprocessor macro. Equivalent to <a href=https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html#cmdoption-clang-d-macro> clang's <kbd>-D</kbd> flag</a>. </li> <li> <kbd>-cflags [flags] --</kbd>: Pass arbitrary additional <a href=https://releases.llvm.org/12.0.0/tools/clang/docs/ClangCommandLineReference.html>command line flags</a> to clang. Note: the list of flags must end with <kbd>--</kbd> </li> <li> <kbd>-target</kbd>: The <a href=#Targets>target triple</a> for the translated Zig code. If no target is specified, the current host target will be used. </li> </ul> <a name=//apple_ref/cpp/Guide/Using%20-target%20and%20-cflags class=dashAnchor></a><h4 id=Using--target-and--cflags>Using -target and -cflags</h4> <p> <strong>Important!</strong> When translating C code with <kbd>zig translate-c</kbd>, you <strong>must</strong> use the same <kbd>-target</kbd> triple that you will use when compiling the translated code. In addition, you <strong>must</strong> ensure that the <kbd>-cflags</kbd> used, if any, match the cflags used by code on the target system. Using the incorrect <kbd>-target</kbd> or <kbd>-cflags</kbd> could result in clang or Zig parse failures, or subtle ABI incompatibilities when linking with C code. </p> <figure><figcaption class=c-cap><cite class=file>varytarget.h</cite></figcaption><pre><code><span class=line>long FOO = __LONG_MAX__;</span></code></pre></figure> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig translate-c -target &lt;em&gt;thumb-freestanding-gnueabihf&lt;/em&gt; varytarget.h|grep FOO</kbd></span>
<span class=line>pub export var FOO: c_long = &lt;em&gt;2147483647&lt;/em&gt;;</span>
<span class=line>$ <kbd>zig translate-c -target &lt;em&gt;x86_64-macos-gnu&lt;/em&gt; varytarget.h|grep FOO</kbd></span>
<span class=line>pub export var FOO: c_long = &lt;em&gt;9223372036854775807&lt;/em&gt;;</span>
</samp></pre></figure> <figure><figcaption class=c-cap><cite class=file>varycflags.h</cite></figcaption><pre><code><span class=line>enum FOO { BAR };</span>
<span class=line>int do_something(enum FOO foo);</span></code></pre></figure> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig translate-c varycflags.h|grep -B1 do_something</kbd></span>
<span class=line>pub const enum_FOO = &lt;em&gt;c_uint&lt;/em&gt;;</span>
<span class=line>pub extern fn do_something(foo: enum_FOO) c_int;</span>
<span class=line>$ <kbd>zig translate-c &lt;em&gt;-cflags -fshort-enums --&lt;/em&gt; varycflags.h|grep -B1 do_something</kbd></span>
<span class=line>pub const enum_FOO = &lt;em&gt;u8&lt;/em&gt;;</span>
<span class=line>pub extern fn do_something(foo: enum_FOO) c_int;</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Builtin/%40cImport%20vs%20translate-c class=dashAnchor></a><h4 id=cImport-vs-translate-c>@cImport vs translate-c</h4> <p><code><span class=line><span class=tok-builtin>@cImport</span></span></code> and <kbd>zig translate-c</kbd> use the same underlying C translation functionality, so on a technical level they are equivalent. In practice, <code><span class=line><span class=tok-builtin>@cImport</span></span></code> is useful as a way to quickly and easily access numeric constants, typedefs, and record types without needing any extra setup. If you need to pass <a href=#Using--target-and--cflags>cflags</a> to clang, or if you would like to edit the translated code, it is recommended to use <kbd>zig translate-c</kbd> and save the results to a file. Common reasons for editing the generated code include: changing <code><span class=line><span class=tok-kw>anytype</span></span></code> parameters in function-like macros to more specific types; changing <code><span class=line>[*c]T</span></code> pointers to <code><span class=line>[*]T</span></code> or <code><span class=line>*T</span></code> pointers for improved type safety; and <a href=#setRuntimeSafety>enabling or disabling runtime safety</a> within specific functions. </p> <p>See also:</p><ul> <li><a href=#Targets>Targets</a></li> <li><a href=#C-Type-Primitives>C Type Primitives</a></li> <li><a href=#Pointers>Pointers</a></li> <li><a href=#C-Pointers>C Pointers</a></li> <li><a href=#Import-from-C-Header-File>Import from C Header File</a></li> <li><a href=#cInclude>@cInclude</a></li> <li><a href=#cImport>@cImport</a></li> <li><a href=#setRuntimeSafety>@setRuntimeSafety</a></li> </ul> <a name=//apple_ref/cpp/Guide/C%20Translation%20Caching class=dashAnchor></a><h3 id=C-Translation-Caching>C Translation Caching</h3> <p> The C translation feature (whether used via <kbd>zig translate-c</kbd> or <code><span class=line><span class=tok-builtin>@cImport</span></span></code>) integrates with the Zig caching system. Subsequent runs with the same source file, target, and cflags will use the cache instead of repeatedly translating the same code. </p> <p> To see where the cached files are stored when compiling code that uses <code><span class=line><span class=tok-builtin>@cImport</span></span></code>, use the <kbd>--verbose-cimport</kbd> flag: </p> <figure><figcaption class=zig-cap><cite class=file>verbose.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> c = <span class=tok-builtin>@cImport</span>({</span>
<span class=line>    <span class=tok-builtin>@cDefine</span>(<span class=tok-str>"_NO_CRT_STDIO_INLINE"</span>, <span class=tok-str>"1"</span>);</span>
<span class=line>    <span class=tok-builtin>@cInclude</span>(<span class=tok-str>"stdio.h"</span>);</span>
<span class=line>});</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() <span class=tok-type>void</span> {</span>
<span class=line>    _ = c;</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe verbose.zig -lc --verbose-cimport</kbd></span>
<span class=line>info(compilation): C import source: /home/andy/tmp/zig/zig-cache/o/cd114e4d3850624b07b7b72b5e2cbf37/cimport.h</span>
<span class=line>info(compilation): C import .d file: /home/andy/tmp/zig/zig-cache/o/cd114e4d3850624b07b7b72b5e2cbf37/cimport.h.d</span>
<span class=line>info(compilation): C import output: /home/andy/tmp/zig/zig-cache/o/2784723e01325f6c34947cb967b09978/cimport.zig</span>
<span class=line></span>
<span class=line>$ <kbd>./verbose</kbd></span>
</samp></pre></figure> <p> <code class=file>cimport.h</code> contains the file to translate (constructed from calls to <code><span class=line><span class=tok-builtin>@cInclude</span></span></code>, <code><span class=line><span class=tok-builtin>@cDefine</span></span></code>, and <code><span class=line><span class=tok-builtin>@cUndef</span></span></code>), <code class=file>cimport.h.d</code> is the list of file dependencies, and <code class=file>cimport.zig</code> contains the translated output. </p> <p>See also:</p><ul> <li><a href=#Import-from-C-Header-File>Import from C Header File</a></li> <li><a href=#C-Translation-CLI>C Translation CLI</a></li> <li><a href=#cInclude>@cInclude</a></li> <li><a href=#cImport>@cImport</a></li> </ul> <a name=//apple_ref/cpp/Guide/Translation%20failures class=dashAnchor></a><h3 id=Translation-failures>Translation failures</h3> <p> Some C constructs cannot be translated to Zig - for example, <em>goto</em>, structs with bitfields, and token-pasting macros. Zig employs <em>demotion</em> to allow translation to continue in the face of non-translatable entities. </p> <p> Demotion comes in three varieties - <a href=#opaque>opaque</a>, <em>extern</em>, and <code><span class=line><span class=tok-builtin>@compileError</span></span></code>. C structs and unions that cannot be translated correctly will be translated as <code><span class=line><span class=tok-kw>opaque</span>{}</span></code>. Functions that contain opaque types or code constructs that cannot be translated will be demoted to <code><span class=line><span class=tok-kw>extern</span></span></code> declarations. Thus, non-translatable types can still be used as pointers, and non-translatable functions can be called so long as the linker is aware of the compiled function. </p> <p> <code><span class=line><span class=tok-builtin>@compileError</span></span></code> is used when top-level definitions (global variables, function prototypes, macros) cannot be translated or demoted. Since Zig uses lazy analysis for top-level declarations, untranslatable entities will not cause a compile error in your code unless you actually use them. </p> <p>See also:</p><ul> <li><a href=#opaque>opaque</a></li> <li><a href=#extern>extern</a></li> <li><a href=#compileError>@compileError</a></li> </ul> <a name=//apple_ref/cpp/Guide/C%20Macros class=dashAnchor></a><h3 id=C-Macros>C Macros</h3> <p> C Translation makes a best-effort attempt to translate function-like macros into equivalent Zig functions. Since C macros operate at the level of lexical tokens, not all C macros can be translated to Zig. Macros that cannot be translated will be demoted to <code><span class=line><span class=tok-builtin>@compileError</span></span></code>. Note that C code which <em>uses</em> macros will be translated without any additional issues (since Zig operates on the pre-processed source with macros expanded). It is merely the macros themselves which may not be translatable to Zig. </p> <p>Consider the following example:</p> <figure><figcaption class=c-cap><cite class=file>macro.c</cite></figcaption><pre><code><span class=line>#define MAKELOCAL(NAME, INIT) int NAME = INIT</span>
<span class=line>int foo(void) {</span>
<span class=line>   MAKELOCAL(a, 1);</span>
<span class=line>   MAKELOCAL(b, 2);</span>
<span class=line>   return a + b;</span>
<span class=line>}</span></code></pre></figure> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig translate-c macro.c &gt; macro.zig</kbd></span>
</samp></pre></figure> <figure><figcaption class=zig-cap><cite class=file>macro.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>pub</span> <span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>foo</span>() <span class=tok-type>c_int</span> {</span>
<span class=line>    <span class=tok-kw>var</span> a: <span class=tok-type>c_int</span> = <span class=tok-number>1</span>;</span>
<span class=line>    <span class=tok-kw>var</span> b: <span class=tok-type>c_int</span> = <span class=tok-number>2</span>;</span>
<span class=line>    <span class=tok-kw>return</span> a + b;</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>const</span> MAKELOCAL = <span class=tok-builtin>@compileError</span>(<span class=tok-str>"unable to translate C expr: unexpected token .Equal"</span>); <span class=tok-comment>// macro.c:1:9</span></span></code></pre></figure> <p>Note that <code><span class=line>foo</span></code> was translated correctly despite using a non-translatable macro. <code><span class=line>MAKELOCAL</span></code> was demoted to <code><span class=line><span class=tok-builtin>@compileError</span></span></code> since it cannot be expressed as a Zig function; this simply means that you cannot directly use <code><span class=line>MAKELOCAL</span></code> from Zig. </p> <p>See also:</p><ul> <li><a href=#compileError>@compileError</a></li> </ul> <a name=//apple_ref/cpp/Guide/C%20Pointers class=dashAnchor></a><h3 id=C-Pointers>C Pointers</h3> <p> This type is to be avoided whenever possible. The only valid reason for using a C pointer is in auto-generated code from translating C code. </p> <p> When importing C header files, it is ambiguous whether pointers should be translated as single-item pointers (<code><span class=line>*T</span></code>) or many-item pointers (<code><span class=line>[*]T</span></code>). C pointers are a compromise so that Zig code can utilize translated header files directly. </p> <p><code><span class=line>[*c]T</span></code> - C pointer.</p> <ul> <li>Supports all the syntax of the other two pointer types.</li> <li>Coerces to other pointer types, as well as <a href=#Optional-Pointers>Optional Pointers</a>. When a C pointer is coerced to a non-optional pointer, safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a> occurs if the address is 0. </li> <li>Allows address 0. On non-freestanding targets, dereferencing address 0 is safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a>. Optional C pointers introduce another bit to keep track of null, just like <code><span class=line>?<span class=tok-type>usize</span></span></code>. Note that creating an optional C pointer is unnecessary as one can use normal <a href=#Optional-Pointers>Optional Pointers</a>. </li> <li>Supports <a href=#Type-Coercion>Type Coercion</a> to and from integers.</li> <li>Supports comparison with integers.</li> <li>Does not support Zig-only pointer attributes such as alignment. Use normal <a href=#Pointers>Pointers</a> please!</li> </ul> <p>When a C pointer is pointing to a single struct (not an array), dereference the C pointer to access the struct's fields or member data. That syntax looks like this: </p> <p><code><span class=line>ptr_to_struct.*.struct_member</span></code></p> <p>This is comparable to doing <code><span class=line>-&gt;</span></code> in C.</p> <p> When a C pointer is pointing to an array of structs, the syntax reverts to this:</p> <p><code><span class=line>ptr_to_struct_array[index].struct_member</span></code></p> <a name=//apple_ref/cpp/Guide/Exporting%20a%20C%20Library class=dashAnchor></a><h3 id=Exporting-a-C-Library>Exporting a C Library</h3> <p> One of the primary use cases for Zig is exporting a library with the C ABI for other programming languages to call into. The <code><span class=line><span class=tok-kw>export</span></span></code> keyword in front of functions, variables, and types causes them to be part of the library API: </p> <figure><figcaption class=zig-cap><cite class=file>mathtest.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>add</span>(a: <span class=tok-type>i32</span>, b: <span class=tok-type>i32</span>) <span class=tok-type>i32</span> {</span>
<span class=line>    <span class=tok-kw>return</span> a + b;</span>
<span class=line>}</span></code></pre></figure> <p>To make a static library:</p> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-lib mathtest.zig</kbd></span>
</samp></pre></figure> <p>To make a shared library:</p> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-lib mathtest.zig -dynamic</kbd></span>
</samp></pre></figure> <p>Here is an example with the <a href=#Zig-Build-System>Zig Build System</a>:</p> <figure><figcaption class=c-cap><cite class=file>test.c</cite></figcaption><pre><code><span class=line>// This header is generated by zig from mathtest.zig</span>
<span class=line>#include "mathtest.h"</span>
<span class=line>#include &lt;stdio.h&gt;</span>
<span class=line></span>
<span class=line>int main(int argc, char **argv) {</span>
<span class=line>    int32_t result = add(42, 1337);</span>
<span class=line>    printf("%d\n", result);</span>
<span class=line>    return 0;</span>
<span class=line>}</span></code></pre></figure> <figure><figcaption class=zig-cap><cite class=file>build.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Builder = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).build.Builder;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>build</span>(b: *Builder) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> lib = b.addSharedLibrary(<span class=tok-str>"mathtest"</span>, <span class=tok-str>"mathtest.zig"</span>, b.version(<span class=tok-number>1</span>, <span class=tok-number>0</span>, <span class=tok-number>0</span>));</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> exe = b.addExecutable(<span class=tok-str>"test"</span>, <span class=tok-null>null</span>);</span>
<span class=line>    exe.addCSourceFile(<span class=tok-str>"test.c"</span>, &amp;[_][]<span class=tok-kw>const</span> <span class=tok-type>u8</span>{<span class=tok-str>"-std=c99"</span>});</span>
<span class=line>    exe.linkLibrary(lib);</span>
<span class=line>    exe.linkSystemLibrary(<span class=tok-str>"c"</span>);</span>
<span class=line></span>
<span class=line>    b.default_step.dependOn(&amp;exe.step);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> run_cmd = exe.run();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> test_step = b.step(<span class=tok-str>"test"</span>, <span class=tok-str>"Test the program"</span>);</span>
<span class=line>    test_step.dependOn(&amp;run_cmd.step);</span>
<span class=line>}</span></code></pre></figure> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build test</kbd></span>
<span class=line>1379</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#export>export</a></li> </ul> <a name=//apple_ref/cpp/Guide/Mixing%20Object%20Files class=dashAnchor></a><h3 id=Mixing-Object-Files>Mixing Object Files</h3> <p> You can mix Zig object files with any other object files that respect the C ABI. Example: </p> <figure><figcaption class=zig-cap><cite class=file>base64.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> base64 = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).base64;</span>
<span class=line></span>
<span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>decode_base_64</span>(</span>
<span class=line>    dest_ptr: [*]<span class=tok-type>u8</span>,</span>
<span class=line>    dest_len: <span class=tok-type>usize</span>,</span>
<span class=line>    source_ptr: [*]<span class=tok-kw>const</span> <span class=tok-type>u8</span>,</span>
<span class=line>    source_len: <span class=tok-type>usize</span>,</span>
<span class=line>) <span class=tok-type>usize</span> {</span>
<span class=line>    <span class=tok-kw>const</span> src = source_ptr[<span class=tok-number>0</span>..source_len];</span>
<span class=line>    <span class=tok-kw>const</span> dest = dest_ptr[<span class=tok-number>0</span>..dest_len];</span>
<span class=line>    <span class=tok-kw>const</span> base64_decoder = base64.standard.Decoder;</span>
<span class=line>    <span class=tok-kw>const</span> decoded_size = base64_decoder.calcSizeForSlice(src) <span class=tok-kw>catch</span> <span class=tok-kw>unreachable</span>;</span>
<span class=line>    base64_decoder.decode(dest[<span class=tok-number>0</span>..decoded_size], src) <span class=tok-kw>catch</span> <span class=tok-kw>unreachable</span>;</span>
<span class=line>    <span class=tok-kw>return</span> decoded_size;</span>
<span class=line>}</span></code></pre></figure> <figure><figcaption class=c-cap><cite class=file>test.c</cite></figcaption><pre><code><span class=line>// This header is generated by zig from base64.zig</span>
<span class=line>#include "base64.h"</span>
<span class=line></span>
<span class=line>#include &lt;string.h&gt;</span>
<span class=line>#include &lt;stdio.h&gt;</span>
<span class=line></span>
<span class=line>int main(int argc, char **argv) {</span>
<span class=line>    const char *encoded = "YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz";</span>
<span class=line>    char buf[200];</span>
<span class=line></span>
<span class=line>    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));</span>
<span class=line>    buf[len] = 0;</span>
<span class=line>    puts(buf);</span>
<span class=line></span>
<span class=line>    return 0;</span>
<span class=line>}</span></code></pre></figure> <figure><figcaption class=zig-cap><cite class=file>build.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> Builder = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>).build.Builder;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>build</span>(b: *Builder) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>const</span> obj = b.addObject(<span class=tok-str>"base64"</span>, <span class=tok-str>"base64.zig"</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>const</span> exe = b.addExecutable(<span class=tok-str>"test"</span>, <span class=tok-null>null</span>);</span>
<span class=line>    exe.addCSourceFile(<span class=tok-str>"test.c"</span>, &amp;[_][]<span class=tok-kw>const</span> <span class=tok-type>u8</span>{<span class=tok-str>"-std=c99"</span>});</span>
<span class=line>    exe.addObject(obj);</span>
<span class=line>    exe.linkSystemLibrary(<span class=tok-str>"c"</span>);</span>
<span class=line>    exe.install();</span>
<span class=line>}</span></code></pre></figure> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build</kbd></span>
<span class=line>$ <kbd>./zig-out/bin/test</kbd></span>
<span class=line>all your base are belong to us</span>
</samp></pre></figure> <p>See also:</p><ul> <li><a href=#Targets>Targets</a></li> <li><a href=#Zig-Build-System>Zig Build System</a></li> </ul> <a name=//apple_ref/cpp/Guide/WebAssembly class=dashAnchor></a><h2 id=WebAssembly>WebAssembly</h2> <p>Zig supports building for WebAssembly out of the box.</p> <a name=//apple_ref/cpp/Guide/Freestanding class=dashAnchor></a><h3 id=Freestanding>Freestanding</h3> <p>For host environments like the web browser and nodejs, build as a dynamic library using the freestanding OS target. Here's an example of running Zig code compiled to WebAssembly with nodejs.</p> <figure><figcaption class=zig-cap><cite class=file>math.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>extern</span> <span class=tok-kw>fn</span> <span class=tok-fn>print</span>(<span class=tok-type>i32</span>) <span class=tok-type>void</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>export</span> <span class=tok-kw>fn</span> <span class=tok-fn>add</span>(a: <span class=tok-type>i32</span>, b: <span class=tok-type>i32</span>) <span class=tok-type>void</span> {</span>
<span class=line>    print(a + b);</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-lib math.zig -target wasm32-freestanding -dynamic</kbd></span>
</samp></pre></figure> <figure><figcaption class=javascript-cap><cite class=file>test.js</cite></figcaption><pre><code><span class=line>const fs = require('fs');</span>
<span class=line>const source = fs.readFileSync("./math.wasm");</span>
<span class=line>const typedArray = new Uint8Array(source);</span>
<span class=line></span>
<span class=line>WebAssembly.instantiate(typedArray, {</span>
<span class=line>  env: {</span>
<span class=line>    print: (result) =&gt; { console.log(`The result is ${result}`); }</span>
<span class=line>  }}).then(result =&gt; {</span>
<span class=line>  const add = result.instance.exports.add;</span>
<span class=line>  add(1, 2);</span>
<span class=line>});</span></code></pre></figure> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>node test.js</kbd></span>
<span class=line>The result is 3</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/WASI class=dashAnchor></a><h3 id=WASI>WASI</h3> <p>Zig's support for WebAssembly System Interface (WASI) is under active development. Example of using the standard library and reading command line arguments:</p> <figure><figcaption class=zig-cap><cite class=file>args.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};</span>
<span class=line>    <span class=tok-kw>const</span> gpa = general_purpose_allocator.allocator();</span>
<span class=line>    <span class=tok-kw>const</span> args = <span class=tok-kw>try</span> std.process.argsAlloc(gpa);</span>
<span class=line>    <span class=tok-kw>defer</span> std.process.argsFree(gpa, args);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>for</span> (args) |arg, i| {</span>
<span class=line>        std.debug.print(<span class=tok-str>"{}: {s}\n"</span>, .{ i, arg });</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe args.zig -target wasm32-wasi</kbd></span>
</samp></pre></figure> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>wasmtime args.wasm 123 hello</kbd></span>
<span class=line>0: args.wasm</span>
<span class=line>1: 123</span>
<span class=line>2: hello</span>
</samp></pre></figure> <p>A more interesting example would be extracting the list of preopens from the runtime. This is now supported in the standard library via <code><span class=line>std.fs.wasi.PreopenList</span></code>:</p> <figure><figcaption class=zig-cap><cite class=file>preopens.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> std = <span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>);</span>
<span class=line><span class=tok-kw>const</span> PreopenList = std.fs.wasi.PreopenList;</span>
<span class=line></span>
<span class=line><span class=tok-kw>pub</span> <span class=tok-kw>fn</span> <span class=tok-fn>main</span>() !<span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};</span>
<span class=line>    <span class=tok-kw>const</span> gpa = general_purpose_allocator.allocator();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>var</span> preopens = PreopenList.init(gpa);</span>
<span class=line>    <span class=tok-kw>defer</span> preopens.deinit();</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>try</span> preopens.populate(<span class=tok-null>null</span>);</span>
<span class=line></span>
<span class=line>    <span class=tok-kw>for</span> (preopens.asSlice()) |preopen, i| {</span>
<span class=line>        std.debug.print(<span class=tok-str>"{}: {}\n"</span>, .{ i, preopen });</span>
<span class=line>    }</span>
<span class=line>}</span></code></pre></figure><figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig build-exe preopens.zig -target wasm32-wasi</kbd></span>
</samp></pre></figure> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>wasmtime --dir=. preopens.wasm</kbd></span>
<span class=line>0: Preopen{ .fd = 3, .type = PreopenType{ .Dir = '.' } }</span>
</samp></pre></figure> <a name=//apple_ref/cpp/Guide/Targets class=dashAnchor></a><h2 id=Targets>Targets</h2> <p> Zig supports generating code for all targets that LLVM supports. Here is what it looks like to execute <code>zig targets</code> on a Linux x86_64 computer: </p> <figure><figcaption class=shell-cap>Shell</figcaption><pre><samp><span class=line>$ <kbd>zig targets</kbd></span>
<span class=line>Architectures:</span>
<span class=line>  arm</span>
<span class=line>    v8_4a</span>
<span class=line>    v8_3a</span>
<span class=line>    v8_2a</span>
<span class=line>    v8_1a</span>
<span class=line>    v8</span>
<span class=line>    v8r</span>
<span class=line>    v8m_baseline</span>
<span class=line>    v8m_mainline</span>
<span class=line>    v7</span>
<span class=line>    v7em</span>
<span class=line>    v7m</span>
<span class=line>    v7s</span>
<span class=line>    v7k</span>
<span class=line>    v7ve</span>
<span class=line>    v6</span>
<span class=line>    v6m</span>
<span class=line>    v6k</span>
<span class=line>    v6t2</span>
<span class=line>    v5</span>
<span class=line>    v5te</span>
<span class=line>    v4t</span>
<span class=line>  armeb</span>
<span class=line>    v8_4a</span>
<span class=line>    v8_3a</span>
<span class=line>    v8_2a</span>
<span class=line>    v8_1a</span>
<span class=line>    v8</span>
<span class=line>    v8r</span>
<span class=line>    v8m_baseline</span>
<span class=line>    v8m_mainline</span>
<span class=line>    v7</span>
<span class=line>    v7em</span>
<span class=line>    v7m</span>
<span class=line>    v7s</span>
<span class=line>    v7k</span>
<span class=line>    v7ve</span>
<span class=line>    v6</span>
<span class=line>    v6m</span>
<span class=line>    v6k</span>
<span class=line>    v6t2</span>
<span class=line>    v5</span>
<span class=line>    v5te</span>
<span class=line>    v4t</span>
<span class=line>  aarch64</span>
<span class=line>    v8_4a</span>
<span class=line>    v8_3a</span>
<span class=line>    v8_2a</span>
<span class=line>    v8_1a</span>
<span class=line>    v8</span>
<span class=line>    v8r</span>
<span class=line>    v8m_baseline</span>
<span class=line>    v8m_mainline</span>
<span class=line>  aarch64_be</span>
<span class=line>    v8_4a</span>
<span class=line>    v8_3a</span>
<span class=line>    v8_2a</span>
<span class=line>    v8_1a</span>
<span class=line>    v8</span>
<span class=line>    v8r</span>
<span class=line>    v8m_baseline</span>
<span class=line>    v8m_mainline</span>
<span class=line>  avr</span>
<span class=line>  bpfel</span>
<span class=line>  bpfeb</span>
<span class=line>  hexagon</span>
<span class=line>  mips</span>
<span class=line>  mipsel</span>
<span class=line>  mips64</span>
<span class=line>  mips64el</span>
<span class=line>  msp430</span>
<span class=line>  powerpc</span>
<span class=line>  powerpc64</span>
<span class=line>  powerpc64le</span>
<span class=line>  r600</span>
<span class=line>  amdgcn</span>
<span class=line>  riscv32</span>
<span class=line>  riscv64</span>
<span class=line>  sparc</span>
<span class=line>  sparc64</span>
<span class=line>  sparcel</span>
<span class=line>  s390x</span>
<span class=line>  thumb</span>
<span class=line>    v8_4a</span>
<span class=line>    v8_3a</span>
<span class=line>    v8_2a</span>
<span class=line>    v8_1a</span>
<span class=line>    v8</span>
<span class=line>    v8r</span>
<span class=line>    v8m_baseline</span>
<span class=line>    v8m_mainline</span>
<span class=line>    v7</span>
<span class=line>    v7em</span>
<span class=line>    v7m</span>
<span class=line>    v7s</span>
<span class=line>    v7k</span>
<span class=line>    v7ve</span>
<span class=line>    v6</span>
<span class=line>    v6m</span>
<span class=line>    v6k</span>
<span class=line>    v6t2</span>
<span class=line>    v5</span>
<span class=line>    v5te</span>
<span class=line>    v4t</span>
<span class=line>  thumbeb</span>
<span class=line>    v8_4a</span>
<span class=line>    v8_3a</span>
<span class=line>    v8_2a</span>
<span class=line>    v8_1a</span>
<span class=line>    v8</span>
<span class=line>    v8r</span>
<span class=line>    v8m_baseline</span>
<span class=line>    v8m_mainline</span>
<span class=line>    v7</span>
<span class=line>    v7em</span>
<span class=line>    v7m</span>
<span class=line>    v7s</span>
<span class=line>    v7k</span>
<span class=line>    v7ve</span>
<span class=line>    v6</span>
<span class=line>    v6m</span>
<span class=line>    v6k</span>
<span class=line>    v6t2</span>
<span class=line>    v5</span>
<span class=line>    v5te</span>
<span class=line>    v4t</span>
<span class=line>  i386</span>
<span class=line>  x86_64 (native)</span>
<span class=line>  xcore</span>
<span class=line>  nvptx</span>
<span class=line>  nvptx64</span>
<span class=line>  lanai</span>
<span class=line>  wasm32</span>
<span class=line>  wasm64</span>
<span class=line></span>
<span class=line>Operating Systems:</span>
<span class=line>  freestanding</span>
<span class=line>  ananas</span>
<span class=line>  cloudabi</span>
<span class=line>  dragonfly</span>
<span class=line>  freebsd</span>
<span class=line>  fuchsia</span>
<span class=line>  ios</span>
<span class=line>  kfreebsd</span>
<span class=line>  linux (native)</span>
<span class=line>  lv2</span>
<span class=line>  macos</span>
<span class=line>  netbsd</span>
<span class=line>  openbsd</span>
<span class=line>  solaris</span>
<span class=line>  windows</span>
<span class=line>  haiku</span>
<span class=line>  minix</span>
<span class=line>  rtems</span>
<span class=line>  nacl</span>
<span class=line>  cnk</span>
<span class=line>  aix</span>
<span class=line>  cuda</span>
<span class=line>  nvcl</span>
<span class=line>  amdhsa</span>
<span class=line>  ps4</span>
<span class=line>  elfiamcu</span>
<span class=line>  tvos</span>
<span class=line>  wasi</span>
<span class=line>  watchos</span>
<span class=line>  mesa3d</span>
<span class=line>  contiki</span>
<span class=line>  amdpal</span>
<span class=line>  zen</span>
<span class=line>  uefi</span>
<span class=line></span>
<span class=line>C ABIs:</span>
<span class=line>  none</span>
<span class=line>  gnu (native)</span>
<span class=line>  gnuabin32</span>
<span class=line>  gnuabi64</span>
<span class=line>  gnueabi</span>
<span class=line>  gnueabihf</span>
<span class=line>  gnux32</span>
<span class=line>  code16</span>
<span class=line>  eabi</span>
<span class=line>  eabihf</span>
<span class=line>  android</span>
<span class=line>  musl</span>
<span class=line>  musleabi</span>
<span class=line>  musleabihf</span>
<span class=line>  msvc</span>
<span class=line>  itanium</span>
<span class=line>  cygnus</span>
<span class=line>  coreclr</span>
<span class=line>  simulator</span>
<span class=line></span>
<span class=line>Available libcs:</span>
<span class=line>  aarch64_be-linux-gnu</span>
<span class=line>  aarch64_be-linux-musl</span>
<span class=line>  aarch64-linux-gnu</span>
<span class=line>  aarch64-linux-musleabi</span>
<span class=line>  armeb-linux-gnueabi</span>
<span class=line>  armeb-linux-gnueabihf</span>
<span class=line>  armeb-linux-musleabi</span>
<span class=line>  armeb-linux-musleabihf</span>
<span class=line>  arm-linux-gnueabi</span>
<span class=line>  arm-linux-gnueabihf</span>
<span class=line>  arm-linux-musleabi</span>
<span class=line>  arm-linux-musleabihf</span>
<span class=line>  i386-linux-gnu</span>
<span class=line>  i386-linux-musl</span>
<span class=line>  mips64el-linux-gnuabi64</span>
<span class=line>  mips64el-linux-gnuabin32</span>
<span class=line>  mips64el-linux-musl</span>
<span class=line>  mips64-linux-gnuabi64</span>
<span class=line>  mips64-linux-gnuabin32</span>
<span class=line>  mips64-linux-musl</span>
<span class=line>  mipsel-linux-gnu</span>
<span class=line>  mipsel-linux-musl</span>
<span class=line>  mips-linux-gnu</span>
<span class=line>  mips-linux-musl</span>
<span class=line>  nios2-linux-gnu</span>
<span class=line>  powerpc64le-linux-gnu</span>
<span class=line>  powerpc64le-linux-musl</span>
<span class=line>  powerpc64-linux-gnu</span>
<span class=line>  powerpc64-linux-musl</span>
<span class=line>  powerpc-linux-gnu</span>
<span class=line>  powerpc-linux-musl</span>
<span class=line>  riscv32-linux-musl</span>
<span class=line>  riscv64-linux-gnu</span>
<span class=line>  riscv64-linux-musl</span>
<span class=line>  s390x-linux-gnu</span>
<span class=line>  s390x-linux-musl</span>
<span class=line>  sparc-linux-gnu</span>
<span class=line>  sparc64-linux-gnu</span>
<span class=line>  wasm32-freestanding-musl</span>
<span class=line>  wasm32-wasi-musl</span>
<span class=line>  x86_64-linux-gnu</span>
<span class=line>  x86_64-linux-gnux32</span>
<span class=line>  x86_64-linux-musl</span>
</samp></pre></figure> <p> The Zig Standard Library (<code><span class=line><span class=tok-builtin>@import</span>(<span class=tok-str>"std"</span>)</span></code>) has architecture, environment, and operating system abstractions, and thus takes additional work to support more platforms. Not all standard library code requires operating system abstractions, however, so things such as generic data structures work on all above platforms. </p> <p>The current list of targets supported by the Zig Standard Library is:</p> <ul> <li>Linux x86_64</li> <li>Windows x86_64</li> <li>macOS x86_64</li> </ul> <a name=//apple_ref/cpp/Guide/Style%20Guide class=dashAnchor></a><h2 id=Style-Guide>Style Guide</h2> <p> These coding conventions are not enforced by the compiler, but they are shipped in this documentation along with the compiler in order to provide a point of reference, should anyone wish to point to an authority on agreed upon Zig coding style. </p> <a name=//apple_ref/cpp/Guide/Whitespace class=dashAnchor></a><h3 id=Whitespace>Whitespace</h3> <ul> <li> 4 space indentation </li> <li> Open braces on same line, unless you need to wrap. </li> <li>If a list of things is longer than 2, put each item on its own line and exercise the ability to put an extra comma at the end. </li> <li> Line length: aim for 100; use common sense. </li> </ul> <a name=//apple_ref/cpp/Guide/Names class=dashAnchor></a><h3 id=Names>Names</h3> <p> Roughly speaking: <code><span class=line>camelCaseFunctionName</span></code>, <code><span class=line>TitleCaseTypeName</span></code>, <code><span class=line>snake_case_variable_name</span></code>. More precisely: </p> <ul> <li> If <code><span class=line>x</span></code> is a <code><span class=line><span class=tok-type>type</span></span></code> then <code><span class=line>x</span></code> should be <code><span class=line>TitleCase</span></code>, unless it is a <code><span class=line><span class=tok-kw>struct</span></span></code> with 0 fields and is never meant to be instantiated, in which case it is considered to be a "namespace" and uses <code><span class=line>snake_case</span></code>. </li> <li> If <code><span class=line>x</span></code> is callable, and <code><span class=line>x</span></code>'s return type is <code><span class=line><span class=tok-type>type</span></span></code>, then <code><span class=line>x</span></code> should be <code><span class=line>TitleCase</span></code>. </li> <li> If <code><span class=line>x</span></code> is otherwise callable, then <code><span class=line>x</span></code> should be <code><span class=line>camelCase</span></code>. </li> <li> Otherwise, <code><span class=line>x</span></code> should be <code><span class=line>snake_case</span></code>. </li> </ul> <p> Acronyms, initialisms, proper nouns, or any other word that has capitalization rules in written English are subject to naming conventions just like any other word. Even acronyms that are only 2 letters long are subject to these conventions. </p> <p> File names fall into two categories: types and namespaces. If the file (implicitly a struct) has top level fields, it should be named like any other struct with fields using <code class=file>TitleCase</code>. Otherwise, it should use <code class=file>snake_case</code>. Directory names should be <code class=file>snake_case</code>. </p> <p> These are general rules of thumb; if it makes sense to do something different, do what makes sense. For example, if there is an established convention such as <code><span class=line>ENOENT</span></code>, follow the established convention. </p> <a name=//apple_ref/cpp/Guide/Examples class=dashAnchor></a><h3 id=Examples>Examples</h3> <figure><figcaption class=zig-cap><cite class=file>style_example.zig</cite></figcaption><pre><code><span class=line><span class=tok-kw>const</span> namespace_name = <span class=tok-builtin>@import</span>(<span class=tok-str>"dir_name/file_name.zig"</span>);</span>
<span class=line><span class=tok-kw>const</span> TypeName = <span class=tok-builtin>@import</span>(<span class=tok-str>"dir_name/TypeName.zig"</span>);</span>
<span class=line><span class=tok-kw>var</span> global_var: <span class=tok-type>i32</span> = <span class=tok-null>undefined</span>;</span>
<span class=line><span class=tok-kw>const</span> const_name = <span class=tok-number>42</span>;</span>
<span class=line><span class=tok-kw>const</span> primitive_type_alias = <span class=tok-type>f32</span>;</span>
<span class=line><span class=tok-kw>const</span> string_alias = []<span class=tok-type>u8</span>;</span>
<span class=line></span>
<span class=line><span class=tok-kw>const</span> StructName = <span class=tok-kw>struct</span> {</span>
<span class=line>    field: <span class=tok-type>i32</span>,</span>
<span class=line>};</span>
<span class=line><span class=tok-kw>const</span> StructAlias = StructName;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>functionName</span>(param_name: TypeName) <span class=tok-type>void</span> {</span>
<span class=line>    <span class=tok-kw>var</span> functionPointer = functionName;</span>
<span class=line>    functionPointer();</span>
<span class=line>    functionPointer = otherFunction;</span>
<span class=line>    functionPointer();</span>
<span class=line>}</span>
<span class=line><span class=tok-kw>const</span> functionAlias = functionName;</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>ListTemplateFunction</span>(<span class=tok-kw>comptime</span> ChildType: <span class=tok-type>type</span>, <span class=tok-kw>comptime</span> fixed_size: <span class=tok-type>usize</span>) <span class=tok-type>type</span> {</span>
<span class=line>    <span class=tok-kw>return</span> List(ChildType, fixed_size);</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>ShortList</span>(<span class=tok-kw>comptime</span> T: <span class=tok-type>type</span>, <span class=tok-kw>comptime</span> n: <span class=tok-type>usize</span>) <span class=tok-type>type</span> {</span>
<span class=line>    <span class=tok-kw>return</span> <span class=tok-kw>struct</span> {</span>
<span class=line>        field_name: [n]T,</span>
<span class=line>        <span class=tok-kw>fn</span> <span class=tok-fn>methodName</span>() <span class=tok-type>void</span> {}</span>
<span class=line>    };</span>
<span class=line>}</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The word XML loses its casing when used in Zig identifiers.</span></span>
<span class=line><span class=tok-kw>const</span> xml_document =</span>
<span class=line>    <span class=tok-str>\\&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span>
<span class=line>    <span class=tok-str>\\&lt;document&gt;</span></span>
<span class=line>    <span class=tok-str>\\&lt;/document&gt;</span></span>
<span class=line>;</span>
<span class=line><span class=tok-kw>const</span> XmlParser = <span class=tok-kw>struct</span> {</span>
<span class=line>    field: <span class=tok-type>i32</span>,</span>
<span class=line>};</span>
<span class=line></span>
<span class=line><span class=tok-comment>// The initials BE (Big Endian) are just another word in Zig identifier names.</span></span>
<span class=line><span class=tok-kw>fn</span> <span class=tok-fn>readU32Be</span>() <span class=tok-type>u32</span> {}</span></code></pre></figure> <p> See the <a href=#Zig-Standard-Library>Zig Standard Library</a> for more examples. </p> <a name=//apple_ref/cpp/Guide/Doc%20Comment%20Guidance class=dashAnchor></a><h3 id=Doc-Comment-Guidance>Doc Comment Guidance</h3> <ul> <li>Omit any information that is redundant based on the name of the thing being documented.</li> <li>Duplicating information onto multiple similar functions is encouraged because it helps IDEs and other tools provide better help text.</li> <li>Use the word <strong>assume</strong> to indicate invariants that cause <a href=#Undefined-Behavior>Undefined Behavior</a> when violated.</li> <li>Use the word <strong>assert</strong> to indicate invariants that cause <em>safety-checked</em> <a href=#Undefined-Behavior>Undefined Behavior</a> when violated.</li> </ul> <a name=//apple_ref/cpp/Guide/Source%20Encoding class=dashAnchor></a><h2 id=Source-Encoding>Source Encoding</h2> <p>Zig source code is encoded in UTF-8. An invalid UTF-8 byte sequence results in a compile error.</p> <p>Throughout all zig source code (including in comments), some code points are never allowed:</p> <ul> <li>Ascii control characters, except for U+000a (LF), U+000d (CR), and U+0009 (HT): U+0000 - U+0008, U+000b - U+000c, U+000e - U+0001f, U+007f.</li> <li>Non-Ascii Unicode line endings: U+0085 (NEL), U+2028 (LS), U+2029 (PS).</li> </ul> <p> LF (byte value 0x0a, code point U+000a, <code><span class=line><span class=tok-str>'\n'</span></span></code>) is the line terminator in Zig source code. This byte value terminates every line of zig source code except the last line of the file. It is recommended that non-empty source files end with an empty line, which means the last byte would be 0x0a (LF). </p> <p> Each LF may be immediately preceded by a single CR (byte value 0x0d, code point U+000d, <code><span class=line><span class=tok-str>'\r'</span></span></code>) to form a Windows style line ending, but this is discouraged. A CR in any other context is not allowed. </p> <p> HT hard tabs (byte value 0x09, code point U+0009, <code><span class=line><span class=tok-str>'\t'</span></span></code>) are interchangeable with SP spaces (byte value 0x20, code point U+0020, <code><span class=line><span class=tok-str>' '</span></span></code>) as a token separator, but use of hard tabs is discouraged. See <a href=#Grammar>Grammar</a>. </p> <p> Note that running <kbd>zig fmt</kbd> on a source file will implement all recommendations mentioned here. Note also that the stage1 compiler does <a href=https://github.com/ziglang/zig/wiki/FAQ#why-does-zig-force-me-to-use-spaces-instead-of-tabs>not yet support CR or HT</a> control characters. </p> <p> Note that a tool reading Zig source code can make assumptions if the source code is assumed to be correct Zig code. For example, when identifying the ends of lines, a tool can use a naive search such as <code>/\n/</code>, or an <a href=https://msdn.microsoft.com/en-us/library/dd409797.aspx>advanced</a> search such as <code>/\r\n?|[\n\u0085\u2028\u2029]/</code>, and in either case line endings will be correctly identified. For another example, when identifying the whitespace before the first token on a line, a tool can either use a naive search such as <code>/[ \t]/</code>, or an <a href=https://tc39.es/ecma262/#sec-characterclassescape>advanced</a> search such as <code>/\s/</code>, and in either case whitespace will be correctly identified. </p> <a name=//apple_ref/cpp/Guide/Keyword%20Reference class=dashAnchor></a><h2 id=Keyword-Reference>Keyword Reference</h2> <div class=table-wrapper> <table> <caption>Keywords</caption> <thead> <tr> <th scope=col>Keyword</th> <th scope=col>Description</th> </tr> </thead> <tbody> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>align</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>align</span></span></code> can be used to specify the alignment of a pointer. It can also be used after a variable or function declaration to specify the alignment of pointers to that variable or function. <ul> <li>See also <a href=#Alignment>Alignment</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>allowzero</span></span></code></pre> </th> <td> The pointer attribute <code><span class=line><span class=tok-kw>allowzero</span></span></code> allows a pointer to have address zero. <ul> <li>See also <a href=#allowzero>allowzero</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>and</span></span></code></pre> </th> <td> The boolean operator <code><span class=line><span class=tok-kw>and</span></span></code>. <ul> <li>See also <a href=#Operators>Operators</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>anyframe</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>anyframe</span></span></code> can be used as a type for variables which hold pointers to function frames. <ul> <li>See also <a href=#Async-Functions>Async Functions</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>anytype</span></span></code></pre> </th> <td> Function parameters can be declared with <code><span class=line><span class=tok-kw>anytype</span></span></code> in place of the type. The type will be inferred where the function is called. <ul> <li>See also <a href=#Function-Parameter-Type-Inference>Function Parameter Type Inference</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>asm</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>asm</span></span></code> begins an inline assembly expression. This allows for directly controlling the machine code generated on compilation. <ul> <li>See also <a href=#Assembly>Assembly</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>async</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>async</span></span></code> can be used before a function call to get a pointer to the function's frame when it suspends. <ul> <li>See also <a href=#Async-Functions>Async Functions</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>await</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>await</span></span></code> can be used to suspend the current function until the frame provided after the <code><span class=line><span class=tok-kw>await</span></span></code> completes. <code><span class=line><span class=tok-kw>await</span></span></code> copies the value returned from the target function's frame to the caller. <ul> <li>See also <a href=#Async-Functions>Async Functions</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>break</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>break</span></span></code> can be used with a block label to return a value from the block. It can also be used to exit a loop before iteration completes naturally. <ul> <li>See also <a href=#Blocks>Blocks</a>, <a href=#while>while</a>, <a href=#for>for</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>catch</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>catch</span></span></code> can be used to evaluate an expression if the expression before it evaluates to an error. The expression after the <code><span class=line><span class=tok-kw>catch</span></span></code> can optionally capture the error value. <ul> <li>See also <a href=#catch>catch</a>, <a href=#Operators>Operators</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>comptime</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>comptime</span></span></code> before a declaration can be used to label variables or function parameters as known at compile time. It can also be used to guarantee an expression is run at compile time. <ul> <li>See also <a href=#comptime>comptime</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>const</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>const</span></span></code> declares a variable that can not be modified. Used as a pointer attribute, it denotes the value referenced by the pointer cannot be modified. <ul> <li>See also <a href=#Variables>Variables</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>continue</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>continue</span></span></code> can be used in a loop to jump back to the beginning of the loop. <ul> <li>See also <a href=#while>while</a>, <a href=#for>for</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>defer</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>defer</span></span></code> will execute an expression when control flow leaves the current block. <ul> <li>See also <a href=#defer>defer</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>else</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>else</span></span></code> can be used to provide an alternate branch for <code><span class=line><span class=tok-kw>if</span></span></code>, <code><span class=line><span class=tok-kw>switch</span></span></code>, <code><span class=line><span class=tok-kw>while</span></span></code>, and <code><span class=line><span class=tok-kw>for</span></span></code> expressions. <ul> <li>If used after an if expression, the else branch will be executed if the test value returns false, null, or an error.</li> <li>If used within a switch expression, the else branch will be executed if the test value matches no other cases.</li> <li>If used after a loop expression, the else branch will be executed if the loop finishes without breaking.</li> <li>See also <a href=#if>if</a>, <a href=#switch>switch</a>, <a href=#while>while</a>, <a href=#for>for</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>enum</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>enum</span></span></code> defines an enum type. <ul> <li>See also <a href=#enum>enum</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>errdefer</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>errdefer</span></span></code> will execute an expression when control flow leaves the current block if the function returns an error, the errdefer expression can capture the unwrapped value. <ul> <li>See also <a href=#errdefer>errdefer</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>error</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>error</span></span></code> defines an error type. <ul> <li>See also <a href=#Errors>Errors</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>export</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>export</span></span></code> makes a function or variable externally visible in the generated object file. Exported functions default to the C calling convention. <ul> <li>See also <a href=#Functions>Functions</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>extern</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>extern</span></span></code> can be used to declare a function or variable that will be resolved at link time, when linking statically or at runtime, when linking dynamically. <ul> <li>See also <a href=#Functions>Functions</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>fn</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>fn</span></span></code> declares a function. <ul> <li>See also <a href=#Functions>Functions</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>for</span></span></code></pre> </th> <td> A <code><span class=line><span class=tok-kw>for</span></span></code> expression can be used to iterate over the elements of a slice, array, or tuple. <ul> <li>See also <a href=#for>for</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>if</span></span></code></pre> </th> <td> An <code><span class=line><span class=tok-kw>if</span></span></code> expression can test boolean expressions, optional values, or error unions. For optional values or error unions, the if expression can capture the unwrapped value. <ul> <li>See also <a href=#if>if</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>inline</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>inline</span></span></code> can be used to label a loop expression such that it will be unrolled at compile time. It can also be used to force a function to be inlined at all call sites. <ul> <li>See also <a href=#inline-while>inline while</a>, <a href=#inline-for>inline for</a>, <a href=#Functions>Functions</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>noalias</span></span></code></pre> </th> <td> The <code><span class=line><span class=tok-kw>noalias</span></span></code> keyword. <ul> <li>TODO add documentation for noalias</li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>nosuspend</span></span></code></pre> </th> <td> The <code><span class=line><span class=tok-kw>nosuspend</span></span></code> keyword can be used in front of a block, statement or expression, to mark a scope where no suspension points are reached. In particular, inside a <code><span class=line><span class=tok-kw>nosuspend</span></span></code> scope: <ul> <li>Using the <code><span class=line><span class=tok-kw>suspend</span></span></code> keyword results in a compile error.</li> <li>Using <code><span class=line><span class=tok-kw>await</span></span></code> on a function frame which hasn't completed yet results in safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a>.</li> <li>Calling an async function may result in safety-checked <a href=#Undefined-Behavior>Undefined Behavior</a>, because it's equivalent to <code>await async some_async_fn()</code>, which contains an <code><span class=line><span class=tok-kw>await</span></span></code>.</li> </ul> Code inside a <code><span class=line><span class=tok-kw>nosuspend</span></span></code> scope does not cause the enclosing function to become an <a href=#Async-Functions>async function</a>. <ul> <li>See also <a href=#Async-Functions>Async Functions</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>or</span></span></code></pre> </th> <td> The boolean operator <code><span class=line><span class=tok-kw>or</span></span></code>. <ul> <li>See also <a href=#Operators>Operators</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>orelse</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>orelse</span></span></code> can be used to evaluate an expression if the expression before it evaluates to null. <ul> <li>See also <a href=#Optionals>Optionals</a>, <a href=#Operators>Operators</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>packed</span></span></code></pre> </th> <td> The <code><span class=line><span class=tok-kw>packed</span></span></code> keyword before a struct definition changes the struct's in-memory layout to the guaranteed <code><span class=line><span class=tok-kw>packed</span></span></code> layout. <ul> <li>See also <a href=#packed-struct>packed struct</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>pub</span></span></code></pre> </th> <td> The <code><span class=line><span class=tok-kw>pub</span></span></code> in front of a top level declaration makes the declaration available to reference from a different file than the one it is declared in. <ul> <li>See also <a href=#import>import</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>resume</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>resume</span></span></code> will continue execution of a function frame after the point the function was suspended. <ul> <li>See also <a href=#Suspend-and-Resume>Suspend and Resume</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>return</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>return</span></span></code> exits a function with a value. <ul> <li>See also <a href=#Functions>Functions</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>linksection</span></span></code></pre> </th> <td> The <code><span class=line><span class=tok-kw>linksection</span></span></code> keyword. <ul> <li>TODO add documentation for linksection</li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>struct</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>struct</span></span></code> defines a struct. <ul> <li>See also <a href=#struct>struct</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>suspend</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>suspend</span></span></code> will cause control flow to return to the call site or resumer of the function. <code><span class=line><span class=tok-kw>suspend</span></span></code> can also be used before a block within a function, to allow the function access to its frame before control flow returns to the call site. <ul> <li>See also <a href=#Suspend-and-Resume>Suspend and Resume</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>switch</span></span></code></pre> </th> <td> A <code><span class=line><span class=tok-kw>switch</span></span></code> expression can be used to test values of a common type. <code><span class=line><span class=tok-kw>switch</span></span></code> cases can capture field values of a <a href=#Tagged-union>Tagged union</a>. <ul> <li>See also <a href=#switch>switch</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>test</span></span></code></pre> </th> <td> The <code><span class=line><span class=tok-kw>test</span></span></code> keyword can be used to denote a top-level block of code used to make sure behavior meets expectations. <ul> <li>See also <a href=#Zig-Test>Zig Test</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>threadlocal</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>threadlocal</span></span></code> can be used to specify a variable as thread-local. <ul> <li>See also <a href=#Thread-Local-Variables>Thread Local Variables</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>try</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>try</span></span></code> evaluates an error union expression. If it is an error, it returns from the current function with the same error. Otherwise, the expression results in the unwrapped value. <ul> <li>See also <a href=#try>try</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>union</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>union</span></span></code> defines a union. <ul> <li>See also <a href=#union>union</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>unreachable</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>unreachable</span></span></code> can be used to assert that control flow will never happen upon a particular location. Depending on the build mode, <code><span class=line><span class=tok-kw>unreachable</span></span></code> may emit a panic. <ul> <li>Emits a panic in <code><span class=line>Debug</span></code> and <code><span class=line>ReleaseSafe</span></code> mode, or when using <kbd>zig test</kbd>.</li> <li>Does not emit a panic in <code><span class=line>ReleaseFast</span></code> mode, unless <kbd>zig test</kbd> is being used.</li> <li>See also <a href=#unreachable>unreachable</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>usingnamespace</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>usingnamespace</span></span></code> is a top-level declaration that imports all the public declarations of the operand, which must be a struct, union, or enum, into the current scope. <ul> <li>See also <a href=#usingnamespace>usingnamespace</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>var</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>var</span></span></code> declares a variable that may be modified. <ul> <li>See also <a href=#Variables>Variables</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>volatile</span></span></code></pre> </th> <td> <code><span class=line><span class=tok-kw>volatile</span></span></code> can be used to denote loads or stores of a pointer have side effects. It can also modify an inline assembly expression to denote it has side effects. <ul> <li>See also <a href=#volatile>volatile</a>, <a href=#Assembly>Assembly</a></li> </ul> </td> </tr> <tr> <th scope=row> <pre><code><span class=line><span class=tok-kw>while</span></span></code></pre> </th> <td> A <code><span class=line><span class=tok-kw>while</span></span></code> expression can be used to repeatedly test a boolean, optional, or error union expression, and cease looping when that expression evaluates to false, null, or an error, respectively. <ul> <li>See also <a href=#while>while</a></li> </ul> </td> </tr> </tbody> </table> </div> <a name=//apple_ref/cpp/Guide/Grammar class=dashAnchor></a><h2 id=Grammar>Grammar</h2> <figure><figcaption class=peg-cap><cite class=file>grammar.y</cite></figcaption><pre><code><span class=line>Root &lt;- skip container_doc_comment? ContainerMembers eof</span>
<span class=line></span>
<span class=line># *** Top level ***</span>
<span class=line>ContainerMembers &lt;- ContainerDeclarations (ContainerField COMMA)* (ContainerField / ContainerDeclarations)</span>
<span class=line></span>
<span class=line>ContainerDeclarations</span>
<span class=line>    &lt;- TestDecl ContainerDeclarations</span>
<span class=line>     / TopLevelComptime ContainerDeclarations</span>
<span class=line>     / doc_comment? KEYWORD_pub? TopLevelDecl ContainerDeclarations</span>
<span class=line>     /</span>
<span class=line></span>
<span class=line>TestDecl &lt;- doc_comment? KEYWORD_test STRINGLITERALSINGLE? Block</span>
<span class=line></span>
<span class=line>TopLevelComptime &lt;- doc_comment? KEYWORD_comptime BlockExpr</span>
<span class=line></span>
<span class=line>TopLevelDecl</span>
<span class=line>    &lt;- (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE? / (KEYWORD_inline / KEYWORD_noinline))? FnProto (SEMICOLON / Block)</span>
<span class=line>     / (KEYWORD_export / KEYWORD_extern STRINGLITERALSINGLE?)? KEYWORD_threadlocal? VarDecl</span>
<span class=line>     / KEYWORD_usingnamespace Expr SEMICOLON</span>
<span class=line></span>
<span class=line>FnProto &lt;- KEYWORD_fn IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr</span>
<span class=line></span>
<span class=line>VarDecl &lt;- (KEYWORD_const / KEYWORD_var) IDENTIFIER (COLON TypeExpr)? ByteAlign? LinkSection? (EQUAL Expr)? SEMICOLON</span>
<span class=line></span>
<span class=line>ContainerField &lt;- doc_comment? KEYWORD_comptime? IDENTIFIER (COLON (KEYWORD_anytype / TypeExpr) ByteAlign?)? (EQUAL Expr)?</span>
<span class=line></span>
<span class=line># *** Block Level ***</span>
<span class=line>Statement</span>
<span class=line>    &lt;- KEYWORD_comptime? VarDecl</span>
<span class=line>     / KEYWORD_comptime BlockExprStatement</span>
<span class=line>     / KEYWORD_nosuspend BlockExprStatement</span>
<span class=line>     / KEYWORD_suspend BlockExprStatement</span>
<span class=line>     / KEYWORD_defer BlockExprStatement</span>
<span class=line>     / KEYWORD_errdefer Payload? BlockExprStatement</span>
<span class=line>     / IfStatement</span>
<span class=line>     / LabeledStatement</span>
<span class=line>     / SwitchExpr</span>
<span class=line>     / AssignExpr SEMICOLON</span>
<span class=line></span>
<span class=line>IfStatement</span>
<span class=line>    &lt;- IfPrefix BlockExpr ( KEYWORD_else Payload? Statement )?</span>
<span class=line>     / IfPrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )</span>
<span class=line></span>
<span class=line>LabeledStatement &lt;- BlockLabel? (Block / LoopStatement)</span>
<span class=line></span>
<span class=line>LoopStatement &lt;- KEYWORD_inline? (ForStatement / WhileStatement)</span>
<span class=line></span>
<span class=line>ForStatement</span>
<span class=line>    &lt;- ForPrefix BlockExpr ( KEYWORD_else Statement )?</span>
<span class=line>     / ForPrefix AssignExpr ( SEMICOLON / KEYWORD_else Statement )</span>
<span class=line></span>
<span class=line>WhileStatement</span>
<span class=line>    &lt;- WhilePrefix BlockExpr ( KEYWORD_else Payload? Statement )?</span>
<span class=line>     / WhilePrefix AssignExpr ( SEMICOLON / KEYWORD_else Payload? Statement )</span>
<span class=line></span>
<span class=line>BlockExprStatement</span>
<span class=line>    &lt;- BlockExpr</span>
<span class=line>     / AssignExpr SEMICOLON</span>
<span class=line></span>
<span class=line>BlockExpr &lt;- BlockLabel? Block</span>
<span class=line></span>
<span class=line># *** Expression Level ***</span>
<span class=line>AssignExpr &lt;- Expr (AssignOp Expr)?</span>
<span class=line></span>
<span class=line>Expr &lt;- BoolOrExpr</span>
<span class=line></span>
<span class=line>BoolOrExpr &lt;- BoolAndExpr (KEYWORD_or BoolAndExpr)*</span>
<span class=line></span>
<span class=line>BoolAndExpr &lt;- CompareExpr (KEYWORD_and CompareExpr)*</span>
<span class=line></span>
<span class=line>CompareExpr &lt;- BitwiseExpr (CompareOp BitwiseExpr)?</span>
<span class=line></span>
<span class=line>BitwiseExpr &lt;- BitShiftExpr (BitwiseOp BitShiftExpr)*</span>
<span class=line></span>
<span class=line>BitShiftExpr &lt;- AdditionExpr (BitShiftOp AdditionExpr)*</span>
<span class=line></span>
<span class=line>AdditionExpr &lt;- MultiplyExpr (AdditionOp MultiplyExpr)*</span>
<span class=line></span>
<span class=line>MultiplyExpr &lt;- PrefixExpr (MultiplyOp PrefixExpr)*</span>
<span class=line></span>
<span class=line>PrefixExpr &lt;- PrefixOp* PrimaryExpr</span>
<span class=line></span>
<span class=line>PrimaryExpr</span>
<span class=line>    &lt;- AsmExpr</span>
<span class=line>     / IfExpr</span>
<span class=line>     / KEYWORD_break BreakLabel? Expr?</span>
<span class=line>     / KEYWORD_comptime Expr</span>
<span class=line>     / KEYWORD_nosuspend Expr</span>
<span class=line>     / KEYWORD_continue BreakLabel?</span>
<span class=line>     / KEYWORD_resume Expr</span>
<span class=line>     / KEYWORD_return Expr?</span>
<span class=line>     / BlockLabel? LoopExpr</span>
<span class=line>     / Block</span>
<span class=line>     / CurlySuffixExpr</span>
<span class=line></span>
<span class=line>IfExpr &lt;- IfPrefix Expr (KEYWORD_else Payload? Expr)?</span>
<span class=line></span>
<span class=line>Block &lt;- LBRACE Statement* RBRACE</span>
<span class=line></span>
<span class=line>LoopExpr &lt;- KEYWORD_inline? (ForExpr / WhileExpr)</span>
<span class=line></span>
<span class=line>ForExpr &lt;- ForPrefix Expr (KEYWORD_else Expr)?</span>
<span class=line></span>
<span class=line>WhileExpr &lt;- WhilePrefix Expr (KEYWORD_else Payload? Expr)?</span>
<span class=line></span>
<span class=line>CurlySuffixExpr &lt;- TypeExpr InitList?</span>
<span class=line></span>
<span class=line>InitList</span>
<span class=line>    &lt;- LBRACE FieldInit (COMMA FieldInit)* COMMA? RBRACE</span>
<span class=line>     / LBRACE Expr (COMMA Expr)* COMMA? RBRACE</span>
<span class=line>     / LBRACE RBRACE</span>
<span class=line></span>
<span class=line>TypeExpr &lt;- PrefixTypeOp* ErrorUnionExpr</span>
<span class=line></span>
<span class=line>ErrorUnionExpr &lt;- SuffixExpr (EXCLAMATIONMARK TypeExpr)?</span>
<span class=line></span>
<span class=line>SuffixExpr</span>
<span class=line>    &lt;- KEYWORD_async PrimaryTypeExpr SuffixOp* FnCallArguments</span>
<span class=line>     / PrimaryTypeExpr (SuffixOp / FnCallArguments)*</span>
<span class=line></span>
<span class=line>PrimaryTypeExpr</span>
<span class=line>    &lt;- BUILTINIDENTIFIER FnCallArguments</span>
<span class=line>     / CHAR_LITERAL</span>
<span class=line>     / ContainerDecl</span>
<span class=line>     / DOT IDENTIFIER</span>
<span class=line>     / DOT InitList</span>
<span class=line>     / ErrorSetDecl</span>
<span class=line>     / FLOAT</span>
<span class=line>     / FnProto</span>
<span class=line>     / GroupedExpr</span>
<span class=line>     / LabeledTypeExpr</span>
<span class=line>     / IDENTIFIER</span>
<span class=line>     / IfTypeExpr</span>
<span class=line>     / INTEGER</span>
<span class=line>     / KEYWORD_comptime TypeExpr</span>
<span class=line>     / KEYWORD_error DOT IDENTIFIER</span>
<span class=line>     / KEYWORD_anyframe</span>
<span class=line>     / KEYWORD_unreachable</span>
<span class=line>     / STRINGLITERAL</span>
<span class=line>     / SwitchExpr</span>
<span class=line></span>
<span class=line>ContainerDecl &lt;- (KEYWORD_extern / KEYWORD_packed)? ContainerDeclAuto</span>
<span class=line></span>
<span class=line>ErrorSetDecl &lt;- KEYWORD_error LBRACE IdentifierList RBRACE</span>
<span class=line></span>
<span class=line>GroupedExpr &lt;- LPAREN Expr RPAREN</span>
<span class=line></span>
<span class=line>IfTypeExpr &lt;- IfPrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?</span>
<span class=line></span>
<span class=line>LabeledTypeExpr</span>
<span class=line>    &lt;- BlockLabel Block</span>
<span class=line>     / BlockLabel? LoopTypeExpr</span>
<span class=line></span>
<span class=line>LoopTypeExpr &lt;- KEYWORD_inline? (ForTypeExpr / WhileTypeExpr)</span>
<span class=line></span>
<span class=line>ForTypeExpr &lt;- ForPrefix TypeExpr (KEYWORD_else TypeExpr)?</span>
<span class=line></span>
<span class=line>WhileTypeExpr &lt;- WhilePrefix TypeExpr (KEYWORD_else Payload? TypeExpr)?</span>
<span class=line></span>
<span class=line>SwitchExpr &lt;- KEYWORD_switch LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE</span>
<span class=line></span>
<span class=line># *** Assembly ***</span>
<span class=line>AsmExpr &lt;- KEYWORD_asm KEYWORD_volatile? LPAREN Expr AsmOutput? RPAREN</span>
<span class=line></span>
<span class=line>AsmOutput &lt;- COLON AsmOutputList AsmInput?</span>
<span class=line></span>
<span class=line>AsmOutputItem &lt;- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN (MINUSRARROW TypeExpr / IDENTIFIER) RPAREN</span>
<span class=line></span>
<span class=line>AsmInput &lt;- COLON AsmInputList AsmClobbers?</span>
<span class=line></span>
<span class=line>AsmInputItem &lt;- LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN</span>
<span class=line></span>
<span class=line>AsmClobbers &lt;- COLON StringList</span>
<span class=line></span>
<span class=line># *** Helper grammar ***</span>
<span class=line>BreakLabel &lt;- COLON IDENTIFIER</span>
<span class=line></span>
<span class=line>BlockLabel &lt;- IDENTIFIER COLON</span>
<span class=line></span>
<span class=line>FieldInit &lt;- DOT IDENTIFIER EQUAL Expr</span>
<span class=line></span>
<span class=line>WhileContinueExpr &lt;- COLON LPAREN AssignExpr RPAREN</span>
<span class=line></span>
<span class=line>LinkSection &lt;- KEYWORD_linksection LPAREN Expr RPAREN</span>
<span class=line></span>
<span class=line># Fn specific</span>
<span class=line>CallConv &lt;- KEYWORD_callconv LPAREN Expr RPAREN</span>
<span class=line></span>
<span class=line>ParamDecl</span>
<span class=line>    &lt;- doc_comment? (KEYWORD_noalias / KEYWORD_comptime)? (IDENTIFIER COLON)? ParamType</span>
<span class=line>     / DOT3</span>
<span class=line></span>
<span class=line>ParamType</span>
<span class=line>    &lt;- KEYWORD_anytype</span>
<span class=line>     / TypeExpr</span>
<span class=line></span>
<span class=line># Control flow prefixes</span>
<span class=line>IfPrefix &lt;- KEYWORD_if LPAREN Expr RPAREN PtrPayload?</span>
<span class=line></span>
<span class=line>WhilePrefix &lt;- KEYWORD_while LPAREN Expr RPAREN PtrPayload? WhileContinueExpr?</span>
<span class=line></span>
<span class=line>ForPrefix &lt;- KEYWORD_for LPAREN Expr RPAREN PtrIndexPayload</span>
<span class=line></span>
<span class=line># Payloads</span>
<span class=line>Payload &lt;- PIPE IDENTIFIER PIPE</span>
<span class=line></span>
<span class=line>PtrPayload &lt;- PIPE ASTERISK? IDENTIFIER PIPE</span>
<span class=line></span>
<span class=line>PtrIndexPayload &lt;- PIPE ASTERISK? IDENTIFIER (COMMA IDENTIFIER)? PIPE</span>
<span class=line></span>
<span class=line></span>
<span class=line># Switch specific</span>
<span class=line>SwitchProng &lt;- SwitchCase EQUALRARROW PtrPayload? AssignExpr</span>
<span class=line></span>
<span class=line>SwitchCase</span>
<span class=line>    &lt;- SwitchItem (COMMA SwitchItem)* COMMA?</span>
<span class=line>     / KEYWORD_else</span>
<span class=line></span>
<span class=line>SwitchItem &lt;- Expr (DOT3 Expr)?</span>
<span class=line></span>
<span class=line># Operators</span>
<span class=line>AssignOp</span>
<span class=line>    &lt;- ASTERISKEQUAL</span>
<span class=line>     / SLASHEQUAL</span>
<span class=line>     / PERCENTEQUAL</span>
<span class=line>     / PLUSEQUAL</span>
<span class=line>     / MINUSEQUAL</span>
<span class=line>     / LARROW2EQUAL</span>
<span class=line>     / RARROW2EQUAL</span>
<span class=line>     / AMPERSANDEQUAL</span>
<span class=line>     / CARETEQUAL</span>
<span class=line>     / PIPEEQUAL</span>
<span class=line>     / ASTERISKPERCENTEQUAL</span>
<span class=line>     / PLUSPERCENTEQUAL</span>
<span class=line>     / MINUSPERCENTEQUAL</span>
<span class=line>     / EQUAL</span>
<span class=line></span>
<span class=line>CompareOp</span>
<span class=line>    &lt;- EQUALEQUAL</span>
<span class=line>     / EXCLAMATIONMARKEQUAL</span>
<span class=line>     / LARROW</span>
<span class=line>     / RARROW</span>
<span class=line>     / LARROWEQUAL</span>
<span class=line>     / RARROWEQUAL</span>
<span class=line></span>
<span class=line>BitwiseOp</span>
<span class=line>    &lt;- AMPERSAND</span>
<span class=line>     / CARET</span>
<span class=line>     / PIPE</span>
<span class=line>     / KEYWORD_orelse</span>
<span class=line>     / KEYWORD_catch Payload?</span>
<span class=line></span>
<span class=line>BitShiftOp</span>
<span class=line>    &lt;- LARROW2</span>
<span class=line>     / RARROW2</span>
<span class=line></span>
<span class=line>AdditionOp</span>
<span class=line>    &lt;- PLUS</span>
<span class=line>     / MINUS</span>
<span class=line>     / PLUS2</span>
<span class=line>     / PLUSPERCENT</span>
<span class=line>     / MINUSPERCENT</span>
<span class=line></span>
<span class=line>MultiplyOp</span>
<span class=line>    &lt;- PIPE2</span>
<span class=line>     / ASTERISK</span>
<span class=line>     / SLASH</span>
<span class=line>     / PERCENT</span>
<span class=line>     / ASTERISK2</span>
<span class=line>     / ASTERISKPERCENT</span>
<span class=line></span>
<span class=line>PrefixOp</span>
<span class=line>    &lt;- EXCLAMATIONMARK</span>
<span class=line>     / MINUS</span>
<span class=line>     / TILDE</span>
<span class=line>     / MINUSPERCENT</span>
<span class=line>     / AMPERSAND</span>
<span class=line>     / KEYWORD_try</span>
<span class=line>     / KEYWORD_await</span>
<span class=line></span>
<span class=line>PrefixTypeOp</span>
<span class=line>    &lt;- QUESTIONMARK</span>
<span class=line>     / KEYWORD_anyframe MINUSRARROW</span>
<span class=line>     / SliceTypeStart (ByteAlign / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*</span>
<span class=line>     / PtrTypeStart (KEYWORD_align LPAREN Expr (COLON INTEGER COLON INTEGER)? RPAREN / KEYWORD_const / KEYWORD_volatile / KEYWORD_allowzero)*</span>
<span class=line>     / ArrayTypeStart</span>
<span class=line></span>
<span class=line>SuffixOp</span>
<span class=line>    &lt;- LBRACKET Expr (DOT2 (Expr? (COLON Expr)?)?)? RBRACKET</span>
<span class=line>     / DOT IDENTIFIER</span>
<span class=line>     / DOTASTERISK</span>
<span class=line>     / DOTQUESTIONMARK</span>
<span class=line></span>
<span class=line>FnCallArguments &lt;- LPAREN ExprList RPAREN</span>
<span class=line></span>
<span class=line># Ptr specific</span>
<span class=line>SliceTypeStart &lt;- LBRACKET (COLON Expr)? RBRACKET</span>
<span class=line></span>
<span class=line>PtrTypeStart</span>
<span class=line>    &lt;- ASTERISK</span>
<span class=line>     / ASTERISK2</span>
<span class=line>     / LBRACKET ASTERISK (LETTERC / COLON Expr)? RBRACKET</span>
<span class=line></span>
<span class=line>ArrayTypeStart &lt;- LBRACKET Expr (COLON Expr)? RBRACKET</span>
<span class=line></span>
<span class=line># ContainerDecl specific</span>
<span class=line>ContainerDeclAuto &lt;- ContainerDeclType LBRACE container_doc_comment? ContainerMembers RBRACE</span>
<span class=line></span>
<span class=line>ContainerDeclType</span>
<span class=line>    &lt;- KEYWORD_struct</span>
<span class=line>     / KEYWORD_opaque</span>
<span class=line>     / KEYWORD_enum (LPAREN Expr RPAREN)?</span>
<span class=line>     / KEYWORD_union (LPAREN (KEYWORD_enum (LPAREN Expr RPAREN)? / Expr) RPAREN)?</span>
<span class=line></span>
<span class=line># Alignment</span>
<span class=line>ByteAlign &lt;- KEYWORD_align LPAREN Expr RPAREN</span>
<span class=line></span>
<span class=line># Lists</span>
<span class=line>IdentifierList &lt;- (doc_comment? IDENTIFIER COMMA)* (doc_comment? IDENTIFIER)?</span>
<span class=line></span>
<span class=line>SwitchProngList &lt;- (SwitchProng COMMA)* SwitchProng?</span>
<span class=line></span>
<span class=line>AsmOutputList &lt;- (AsmOutputItem COMMA)* AsmOutputItem?</span>
<span class=line></span>
<span class=line>AsmInputList &lt;- (AsmInputItem COMMA)* AsmInputItem?</span>
<span class=line></span>
<span class=line>StringList &lt;- (STRINGLITERAL COMMA)* STRINGLITERAL?</span>
<span class=line></span>
<span class=line>ParamDeclList &lt;- (ParamDecl COMMA)* ParamDecl?</span>
<span class=line></span>
<span class=line>ExprList &lt;- (Expr COMMA)* Expr?</span>
<span class=line></span>
<span class=line># *** Tokens ***</span>
<span class=line>eof &lt;- !.</span>
<span class=line>bin &lt;- [01]</span>
<span class=line>bin_ &lt;- '_'? bin</span>
<span class=line>oct &lt;- [0-7]</span>
<span class=line>oct_ &lt;- '_'? oct</span>
<span class=line>hex &lt;- [0-9a-fA-F]</span>
<span class=line>hex_ &lt;- '_'? hex</span>
<span class=line>dec &lt;- [0-9]</span>
<span class=line>dec_ &lt;- '_'? dec</span>
<span class=line></span>
<span class=line>bin_int &lt;- bin bin_*</span>
<span class=line>oct_int &lt;- oct oct_*</span>
<span class=line>dec_int &lt;- dec dec_*</span>
<span class=line>hex_int &lt;- hex hex_*</span>
<span class=line></span>
<span class=line>ox80_oxBF &lt;- [\200-\277]</span>
<span class=line>oxF4 &lt;- '\364'</span>
<span class=line>ox80_ox8F &lt;- [\200-\217]</span>
<span class=line>oxF1_oxF3 &lt;- [\361-\363]</span>
<span class=line>oxF0 &lt;- '\360'</span>
<span class=line>ox90_0xBF &lt;- [\220-\277]</span>
<span class=line>oxEE_oxEF &lt;- [\356-\357]</span>
<span class=line>oxED &lt;- '\355'</span>
<span class=line>ox80_ox9F &lt;- [\200-\237]</span>
<span class=line>oxE1_oxEC &lt;- [\341-\354]</span>
<span class=line>oxE0 &lt;- '\340'</span>
<span class=line>oxA0_oxBF &lt;- [\240-\277]</span>
<span class=line>oxC2_oxDF &lt;- [\302-\337]</span>
<span class=line></span>
<span class=line># From https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/</span>
<span class=line># First Byte      Second Byte     Third Byte      Fourth Byte</span>
<span class=line># [0x00,0x7F]</span>
<span class=line># [0xC2,0xDF]     [0x80,0xBF]</span>
<span class=line>#    0xE0         [0xA0,0xBF]     [0x80,0xBF]</span>
<span class=line># [0xE1,0xEC]     [0x80,0xBF]     [0x80,0xBF]</span>
<span class=line>#    0xED         [0x80,0x9F]     [0x80,0xBF]</span>
<span class=line># [0xEE,0xEF]     [0x80,0xBF]     [0x80,0xBF]</span>
<span class=line>#    0xF0         [0x90,0xBF]     [0x80,0xBF]     [0x80,0xBF]</span>
<span class=line># [0xF1,0xF3]     [0x80,0xBF]     [0x80,0xBF]     [0x80,0xBF]</span>
<span class=line>#    0xF4         [0x80,0x8F]     [0x80,0xBF]     [0x80,0xBF]</span>
<span class=line></span>
<span class=line>mb_utf8_literal &lt;-</span>
<span class=line>       oxF4      ox80_ox8F ox80_oxBF ox80_oxBF</span>
<span class=line>     / oxF1_oxF3 ox80_oxBF ox80_oxBF ox80_oxBF</span>
<span class=line>     / oxF0      ox90_0xBF ox80_oxBF ox80_oxBF</span>
<span class=line>     / oxEE_oxEF ox80_oxBF ox80_oxBF</span>
<span class=line>     / oxED      ox80_ox9F ox80_oxBF</span>
<span class=line>     / oxE1_oxEC ox80_oxBF ox80_oxBF</span>
<span class=line>     / oxE0      oxA0_oxBF ox80_oxBF</span>
<span class=line>     / oxC2_oxDF ox80_oxBF</span>
<span class=line></span>
<span class=line>ascii_char_not_nl_slash_squote &lt;- [\000-\011\013-\046-\050-\133\135-\177]</span>
<span class=line></span>
<span class=line>char_escape</span>
<span class=line>    &lt;- "\\x" hex hex</span>
<span class=line>     / "\\u{" hex+ "}"</span>
<span class=line>     / "\\" [nr\\t'"]</span>
<span class=line>char_char</span>
<span class=line>    &lt;- mb_utf8_literal</span>
<span class=line>     / char_escape</span>
<span class=line>     / ascii_char_not_nl_slash_squote</span>
<span class=line></span>
<span class=line>string_char</span>
<span class=line>    &lt;- char_escape</span>
<span class=line>     / [^\\"\n]</span>
<span class=line></span>
<span class=line>container_doc_comment &lt;- ('//!' [^\n]* [ \n]*)+</span>
<span class=line>doc_comment &lt;- ('///' [^\n]* [ \n]*)+</span>
<span class=line>line_comment &lt;- '//' ![!/][^\n]* / '////' [^\n]*</span>
<span class=line>line_string &lt;- ("\\\\" [^\n]* [ \n]*)+</span>
<span class=line>skip &lt;- ([ \n] / line_comment)*</span>
<span class=line></span>
<span class=line>CHAR_LITERAL &lt;- "'" char_char "'" skip</span>
<span class=line>FLOAT</span>
<span class=line>    &lt;- "0x" hex_int "." hex_int ([pP] [-+]? dec_int)? skip</span>
<span class=line>     /      dec_int "." dec_int ([eE] [-+]? dec_int)? skip</span>
<span class=line>     / "0x" hex_int [pP] [-+]? dec_int skip</span>
<span class=line>     /      dec_int [eE] [-+]? dec_int skip</span>
<span class=line>INTEGER</span>
<span class=line>    &lt;- "0b" bin_int skip</span>
<span class=line>     / "0o" oct_int skip</span>
<span class=line>     / "0x" hex_int skip</span>
<span class=line>     /      dec_int   skip</span>
<span class=line>STRINGLITERALSINGLE &lt;- "\"" string_char* "\"" skip</span>
<span class=line>STRINGLITERAL</span>
<span class=line>    &lt;- STRINGLITERALSINGLE</span>
<span class=line>     / (line_string                 skip)+</span>
<span class=line>IDENTIFIER</span>
<span class=line>    &lt;- !keyword [A-Za-z_] [A-Za-z0-9_]* skip</span>
<span class=line>     / "@\"" string_char* "\""                            skip</span>
<span class=line>BUILTINIDENTIFIER &lt;- "@"[A-Za-z_][A-Za-z0-9_]* skip</span>
<span class=line></span>
<span class=line></span>
<span class=line>AMPERSAND            &lt;- '&amp;'      ![=]      skip</span>
<span class=line>AMPERSANDEQUAL       &lt;- '&amp;='               skip</span>
<span class=line>ASTERISK             &lt;- '*'      ![*%=]    skip</span>
<span class=line>ASTERISK2            &lt;- '**'               skip</span>
<span class=line>ASTERISKEQUAL        &lt;- '*='               skip</span>
<span class=line>ASTERISKPERCENT      &lt;- '*%'     ![=]      skip</span>
<span class=line>ASTERISKPERCENTEQUAL &lt;- '*%='              skip</span>
<span class=line>CARET                &lt;- '^'      ![=]      skip</span>
<span class=line>CARETEQUAL           &lt;- '^='               skip</span>
<span class=line>COLON                &lt;- ':'                skip</span>
<span class=line>COMMA                &lt;- ','                skip</span>
<span class=line>DOT                  &lt;- '.'      ![*.?]    skip</span>
<span class=line>DOT2                 &lt;- '..'     ![.]      skip</span>
<span class=line>DOT3                 &lt;- '...'              skip</span>
<span class=line>DOTASTERISK          &lt;- '.*'               skip</span>
<span class=line>DOTQUESTIONMARK      &lt;- '.?'               skip</span>
<span class=line>EQUAL                &lt;- '='      ![&gt;=]     skip</span>
<span class=line>EQUALEQUAL           &lt;- '=='               skip</span>
<span class=line>EQUALRARROW          &lt;- '=&gt;'               skip</span>
<span class=line>EXCLAMATIONMARK      &lt;- '!'      ![=]      skip</span>
<span class=line>EXCLAMATIONMARKEQUAL &lt;- '!='               skip</span>
<span class=line>LARROW               &lt;- '&lt;'      ![&lt;=]     skip</span>
<span class=line>LARROW2              &lt;- '&lt;&lt;'     ![=]      skip</span>
<span class=line>LARROW2EQUAL         &lt;- '&lt;&lt;='              skip</span>
<span class=line>LARROWEQUAL          &lt;- '&lt;='               skip</span>
<span class=line>LBRACE               &lt;- '{'                skip</span>
<span class=line>LBRACKET             &lt;- '['                skip</span>
<span class=line>LPAREN               &lt;- '('                skip</span>
<span class=line>MINUS                &lt;- '-'      ![%=&gt;]    skip</span>
<span class=line>MINUSEQUAL           &lt;- '-='               skip</span>
<span class=line>MINUSPERCENT         &lt;- '-%'     ![=]      skip</span>
<span class=line>MINUSPERCENTEQUAL    &lt;- '-%='              skip</span>
<span class=line>MINUSRARROW          &lt;- '-&gt;'               skip</span>
<span class=line>PERCENT              &lt;- '%'      ![=]      skip</span>
<span class=line>PERCENTEQUAL         &lt;- '%='               skip</span>
<span class=line>PIPE                 &lt;- '|'      ![|=]     skip</span>
<span class=line>PIPE2                &lt;- '||'               skip</span>
<span class=line>PIPEEQUAL            &lt;- '|='               skip</span>
<span class=line>PLUS                 &lt;- '+'      ![%+=]    skip</span>
<span class=line>PLUS2                &lt;- '++'               skip</span>
<span class=line>PLUSEQUAL            &lt;- '+='               skip</span>
<span class=line>PLUSPERCENT          &lt;- '+%'     ![=]      skip</span>
<span class=line>PLUSPERCENTEQUAL     &lt;- '+%='              skip</span>
<span class=line>LETTERC              &lt;- 'c'                skip</span>
<span class=line>QUESTIONMARK         &lt;- '?'                skip</span>
<span class=line>RARROW               &lt;- '&gt;'      ![&gt;=]     skip</span>
<span class=line>RARROW2              &lt;- '&gt;&gt;'     ![=]      skip</span>
<span class=line>RARROW2EQUAL         &lt;- '&gt;&gt;='              skip</span>
<span class=line>RARROWEQUAL          &lt;- '&gt;='               skip</span>
<span class=line>RBRACE               &lt;- '}'                skip</span>
<span class=line>RBRACKET             &lt;- ']'                skip</span>
<span class=line>RPAREN               &lt;- ')'                skip</span>
<span class=line>SEMICOLON            &lt;- ';'                skip</span>
<span class=line>SLASH                &lt;- '/'      ![=]      skip</span>
<span class=line>SLASHEQUAL           &lt;- '/='               skip</span>
<span class=line>TILDE                &lt;- '~'                skip</span>
<span class=line></span>
<span class=line>end_of_word &lt;- ![a-zA-Z0-9_] skip</span>
<span class=line>KEYWORD_align       &lt;- 'align'       end_of_word</span>
<span class=line>KEYWORD_allowzero   &lt;- 'allowzero'   end_of_word</span>
<span class=line>KEYWORD_and         &lt;- 'and'         end_of_word</span>
<span class=line>KEYWORD_anyframe    &lt;- 'anyframe'    end_of_word</span>
<span class=line>KEYWORD_anytype     &lt;- 'anytype'     end_of_word</span>
<span class=line>KEYWORD_asm         &lt;- 'asm'         end_of_word</span>
<span class=line>KEYWORD_async       &lt;- 'async'       end_of_word</span>
<span class=line>KEYWORD_await       &lt;- 'await'       end_of_word</span>
<span class=line>KEYWORD_break       &lt;- 'break'       end_of_word</span>
<span class=line>KEYWORD_callconv    &lt;- 'callconv'    end_of_word</span>
<span class=line>KEYWORD_catch       &lt;- 'catch'       end_of_word</span>
<span class=line>KEYWORD_comptime    &lt;- 'comptime'    end_of_word</span>
<span class=line>KEYWORD_const       &lt;- 'const'       end_of_word</span>
<span class=line>KEYWORD_continue    &lt;- 'continue'    end_of_word</span>
<span class=line>KEYWORD_defer       &lt;- 'defer'       end_of_word</span>
<span class=line>KEYWORD_else        &lt;- 'else'        end_of_word</span>
<span class=line>KEYWORD_enum        &lt;- 'enum'        end_of_word</span>
<span class=line>KEYWORD_errdefer    &lt;- 'errdefer'    end_of_word</span>
<span class=line>KEYWORD_error       &lt;- 'error'       end_of_word</span>
<span class=line>KEYWORD_export      &lt;- 'export'      end_of_word</span>
<span class=line>KEYWORD_extern      &lt;- 'extern'      end_of_word</span>
<span class=line>KEYWORD_fn          &lt;- 'fn'          end_of_word</span>
<span class=line>KEYWORD_for         &lt;- 'for'         end_of_word</span>
<span class=line>KEYWORD_if          &lt;- 'if'          end_of_word</span>
<span class=line>KEYWORD_inline      &lt;- 'inline'      end_of_word</span>
<span class=line>KEYWORD_noalias     &lt;- 'noalias'     end_of_word</span>
<span class=line>KEYWORD_nosuspend   &lt;- 'nosuspend'   end_of_word</span>
<span class=line>KEYWORD_noinline    &lt;- 'noinline'    end_of_word</span>
<span class=line>KEYWORD_opaque      &lt;- 'opaque'      end_of_word</span>
<span class=line>KEYWORD_or          &lt;- 'or'          end_of_word</span>
<span class=line>KEYWORD_orelse      &lt;- 'orelse'      end_of_word</span>
<span class=line>KEYWORD_packed      &lt;- 'packed'      end_of_word</span>
<span class=line>KEYWORD_pub         &lt;- 'pub'         end_of_word</span>
<span class=line>KEYWORD_resume      &lt;- 'resume'      end_of_word</span>
<span class=line>KEYWORD_return      &lt;- 'return'      end_of_word</span>
<span class=line>KEYWORD_linksection &lt;- 'linksection' end_of_word</span>
<span class=line>KEYWORD_struct      &lt;- 'struct'      end_of_word</span>
<span class=line>KEYWORD_suspend     &lt;- 'suspend'     end_of_word</span>
<span class=line>KEYWORD_switch      &lt;- 'switch'      end_of_word</span>
<span class=line>KEYWORD_test        &lt;- 'test'        end_of_word</span>
<span class=line>KEYWORD_threadlocal &lt;- 'threadlocal' end_of_word</span>
<span class=line>KEYWORD_try         &lt;- 'try'         end_of_word</span>
<span class=line>KEYWORD_union       &lt;- 'union'       end_of_word</span>
<span class=line>KEYWORD_unreachable &lt;- 'unreachable' end_of_word</span>
<span class=line>KEYWORD_usingnamespace &lt;- 'usingnamespace' end_of_word</span>
<span class=line>KEYWORD_var         &lt;- 'var'         end_of_word</span>
<span class=line>KEYWORD_volatile    &lt;- 'volatile'    end_of_word</span>
<span class=line>KEYWORD_while       &lt;- 'while'       end_of_word</span>
<span class=line></span>
<span class=line>keyword &lt;- KEYWORD_align / KEYWORD_allowzero / KEYWORD_and / KEYWORD_anyframe</span>
<span class=line>         / KEYWORD_anytype / KEYWORD_asm / KEYWORD_async / KEYWORD_await</span>
<span class=line>         / KEYWORD_break / KEYWORD_callconv / KEYWORD_catch / KEYWORD_comptime</span>
<span class=line>         / KEYWORD_const / KEYWORD_continue / KEYWORD_defer / KEYWORD_else</span>
<span class=line>         / KEYWORD_enum / KEYWORD_errdefer / KEYWORD_error / KEYWORD_export</span>
<span class=line>         / KEYWORD_extern / KEYWORD_fn / KEYWORD_for / KEYWORD_if</span>
<span class=line>         / KEYWORD_inline / KEYWORD_noalias / KEYWORD_nosuspend / KEYWORD_noinline</span>
<span class=line>         / KEYWORD_opaque / KEYWORD_or / KEYWORD_orelse / KEYWORD_packed</span>
<span class=line>         / KEYWORD_pub / KEYWORD_resume / KEYWORD_return / KEYWORD_linksection</span>
<span class=line>         / KEYWORD_struct / KEYWORD_suspend / KEYWORD_switch / KEYWORD_test</span>
<span class=line>         / KEYWORD_threadlocal / KEYWORD_try / KEYWORD_union / KEYWORD_unreachable</span>
<span class=line>         / KEYWORD_usingnamespace / KEYWORD_var / KEYWORD_volatile / KEYWORD_while</span></code></pre></figure> <a name=//apple_ref/cpp/Guide/Zen class=dashAnchor></a><h2 id=Zen>Zen</h2> <ul> <li>Communicate intent precisely.</li> <li>Edge cases matter.</li> <li>Favor reading code over writing code.</li> <li>Only one obvious way to do things.</li> <li>Runtime crashes are better than bugs.</li> <li>Compile errors are better than runtime crashes.</li> <li>Incremental improvements.</li> <li>Avoid local maximums.</li> <li>Reduce the amount one must remember.</li> <li>Focus on code rather than style.</li> <li>Resource allocation may fail; resource deallocation must succeed.</li> <li>Memory is a resource.</li> <li>Together we serve the users.</li> </ul> </main></div> </div> </body></html>